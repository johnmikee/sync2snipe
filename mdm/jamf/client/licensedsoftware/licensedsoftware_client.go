// Code generated by go-swagger; DO NOT EDIT.

package licensedsoftware

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new licensedsoftware API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for licensedsoftware API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateLicensedSoftwareByID(params *CreateLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateLicensedSoftwareByIDCreated, error)

	DeleteLicensedSoftwareByID(params *DeleteLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLicensedSoftwareByIDOK, error)

	DeleteLicensedSoftwareByName(params *DeleteLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLicensedSoftwareByNameOK, error)

	FindLicensedSoftware(params *FindLicensedSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareOK, error)

	FindLicensedSoftwareByID(params *FindLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareByIDOK, error)

	FindLicensedSoftwareByName(params *FindLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareByNameOK, error)

	UpdateLicensedSoftwareByID(params *UpdateLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLicensedSoftwareByIDCreated, error)

	UpdateLicensedSoftwareByName(params *UpdateLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLicensedSoftwareByNameCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateLicensedSoftwareByID creates new licensed software by ID

Matching computers are derived from software definitions, therefore they cannot be set with this operation.
*/
func (a *Client) CreateLicensedSoftwareByID(params *CreateLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateLicensedSoftwareByIDCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateLicensedSoftwareByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createLicensedSoftwareById",
		Method:             "POST",
		PathPattern:        "/licensedsoftware/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateLicensedSoftwareByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateLicensedSoftwareByIDCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createLicensedSoftwareById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteLicensedSoftwareByID deletes licensed software by ID
*/
func (a *Client) DeleteLicensedSoftwareByID(params *DeleteLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLicensedSoftwareByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLicensedSoftwareByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteLicensedSoftwareById",
		Method:             "DELETE",
		PathPattern:        "/licensedsoftware/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLicensedSoftwareByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteLicensedSoftwareByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteLicensedSoftwareById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteLicensedSoftwareByName deletes licensed software by name
*/
func (a *Client) DeleteLicensedSoftwareByName(params *DeleteLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLicensedSoftwareByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLicensedSoftwareByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteLicensedSoftwareByName",
		Method:             "DELETE",
		PathPattern:        "/licensedsoftware/name/{name}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLicensedSoftwareByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteLicensedSoftwareByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteLicensedSoftwareByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLicensedSoftware finds all licensed software
*/
func (a *Client) FindLicensedSoftware(params *FindLicensedSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLicensedSoftwareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLicensedSoftware",
		Method:             "GET",
		PathPattern:        "/licensedsoftware",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLicensedSoftwareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLicensedSoftwareOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLicensedSoftware: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLicensedSoftwareByID finds licensed software by ID
*/
func (a *Client) FindLicensedSoftwareByID(params *FindLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLicensedSoftwareByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLicensedSoftwareById",
		Method:             "GET",
		PathPattern:        "/licensedsoftware/id/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLicensedSoftwareByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLicensedSoftwareByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLicensedSoftwareById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLicensedSoftwareByName finds licensed software by name
*/
func (a *Client) FindLicensedSoftwareByName(params *FindLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLicensedSoftwareByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLicensedSoftwareByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLicensedSoftwareByName",
		Method:             "GET",
		PathPattern:        "/licensedsoftware/name/{name}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLicensedSoftwareByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLicensedSoftwareByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLicensedSoftwareByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateLicensedSoftwareByID updates existing licensed software by ID

Matching computers are derived from software definitions, therefore they cannot be set with this operation.
*/
func (a *Client) UpdateLicensedSoftwareByID(params *UpdateLicensedSoftwareByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLicensedSoftwareByIDCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLicensedSoftwareByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateLicensedSoftwareById",
		Method:             "PUT",
		PathPattern:        "/licensedsoftware/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLicensedSoftwareByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateLicensedSoftwareByIDCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateLicensedSoftwareById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateLicensedSoftwareByName updates an existing licensed software by name

Matching computers are derived from software definitions, therefore they cannot be set with this operation.
*/
func (a *Client) UpdateLicensedSoftwareByName(params *UpdateLicensedSoftwareByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLicensedSoftwareByNameCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLicensedSoftwareByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateLicensedSoftwareByName",
		Method:             "PUT",
		PathPattern:        "/licensedsoftware/name/{name}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLicensedSoftwareByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateLicensedSoftwareByNameCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateLicensedSoftwareByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
