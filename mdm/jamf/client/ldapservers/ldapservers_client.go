// Code generated by go-swagger; DO NOT EDIT.

package ldapservers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new ldapservers API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for ldapservers API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateLDAPServerByID(params *CreateLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateLDAPServerByIDCreated, error)

	DeleteLDAPServerByID(params *DeleteLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLDAPServerByIDOK, error)

	DeleteLDAPServerByName(params *DeleteLDAPServerByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLDAPServerByNameOK, error)

	FindLDAPServerGroupByID(params *FindLDAPServerGroupByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupByIDOK, error)

	FindLDAPServerGroupByName(params *FindLDAPServerGroupByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupByNameOK, error)

	FindLDAPServerGroupUserByID(params *FindLDAPServerGroupUserByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupUserByIDOK, error)

	FindLDAPServerGroupUserByName(params *FindLDAPServerGroupUserByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupUserByNameOK, error)

	FindLDAPServerUserByID(params *FindLDAPServerUserByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerUserByIDOK, error)

	FindLDAPServerUserByName(params *FindLDAPServerUserByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerUserByNameOK, error)

	FindLDAPServers(params *FindLDAPServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersOK, error)

	FindLDAPServersByID(params *FindLDAPServersByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersByIDOK, error)

	FindLDAPServersByName(params *FindLDAPServersByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersByNameOK, error)

	UpdateLDAPServerByID(params *UpdateLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLDAPServerByIDCreated, error)

	UpdateLDAPServerByName(params *UpdateLDAPServerByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLDAPServerByNameCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateLDAPServerByID creates a new l d a p server by ID
*/
func (a *Client) CreateLDAPServerByID(params *CreateLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateLDAPServerByIDCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateLDAPServerByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createLDAPServerById",
		Method:             "POST",
		PathPattern:        "/ldapservers/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateLDAPServerByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateLDAPServerByIDCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createLDAPServerById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteLDAPServerByID deletes an l d a p server by ID
*/
func (a *Client) DeleteLDAPServerByID(params *DeleteLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLDAPServerByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLDAPServerByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteLDAPServerById",
		Method:             "DELETE",
		PathPattern:        "/ldapservers/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLDAPServerByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteLDAPServerByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteLDAPServerById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteLDAPServerByName deletes an l d a p server by name
*/
func (a *Client) DeleteLDAPServerByName(params *DeleteLDAPServerByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteLDAPServerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLDAPServerByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteLDAPServerByName",
		Method:             "DELETE",
		PathPattern:        "/ldapservers/name/{name}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteLDAPServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteLDAPServerByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteLDAPServerByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerGroupByID displays information for matching groups for an l d a p server

Displays information about matching groups for an ldap server specified with the {id} parameter.
*/
func (a *Client) FindLDAPServerGroupByID(params *FindLDAPServerGroupByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerGroupByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerGroupById",
		Method:             "GET",
		PathPattern:        "/ldapservers/id/{id}/group/{group}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerGroupByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerGroupByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerGroupById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerGroupByName displays information for matching groups for an l d a p server

Displays information about matching groups for an ldap server specified with the {name} parameter.
*/
func (a *Client) FindLDAPServerGroupByName(params *FindLDAPServerGroupByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerGroupByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerGroupByName",
		Method:             "GET",
		PathPattern:        "/ldapservers/name/{name}/group/{group}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerGroupByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerGroupByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerGroupByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerGroupUserByID displays information about user membership in a group for an l d a p server

Displays information about user membership in a group for an ldap server specified with the {id} parameter. Multiple users separated by a comma are allowed.
*/
func (a *Client) FindLDAPServerGroupUserByID(params *FindLDAPServerGroupUserByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupUserByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerGroupUserByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerGroupUserById",
		Method:             "GET",
		PathPattern:        "/ldapservers/id/{id}/group/{group}/user/{user}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerGroupUserByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerGroupUserByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerGroupUserById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerGroupUserByName displays information about user membership in a group for an l d a p server

Displays information about user membership in a group for an ldap server specified with the {name} parameter. Multiple users separated by a comma are allowed.
*/
func (a *Client) FindLDAPServerGroupUserByName(params *FindLDAPServerGroupUserByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerGroupUserByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerGroupUserByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerGroupUserByName",
		Method:             "GET",
		PathPattern:        "/ldapservers/name/{name}/group/{group}/user/{user}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerGroupUserByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerGroupUserByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerGroupUserByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerUserByID displays information for matching users for an l d a p server

Displays information about matching users for an ldap server specified with the {id} parameter.
*/
func (a *Client) FindLDAPServerUserByID(params *FindLDAPServerUserByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerUserByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerUserByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerUserById",
		Method:             "GET",
		PathPattern:        "/ldapservers/id/{id}/user/{user}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerUserByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerUserByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerUserById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServerUserByName displays information for matching users for an l d a p server

Displays information about matching users for an ldap server specified with the {name} parameter.
*/
func (a *Client) FindLDAPServerUserByName(params *FindLDAPServerUserByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServerUserByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServerUserByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServerUserByName",
		Method:             "GET",
		PathPattern:        "/ldapservers/name/{name}/user/{user}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServerUserByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServerUserByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServerUserByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServers finds all l d a p servers
*/
func (a *Client) FindLDAPServers(params *FindLDAPServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServers",
		Method:             "GET",
		PathPattern:        "/ldapservers",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServersByID finds l d a p servers by ID
*/
func (a *Client) FindLDAPServersByID(params *FindLDAPServersByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServersByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServersById",
		Method:             "GET",
		PathPattern:        "/ldapservers/id/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServersByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServersById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
FindLDAPServersByName finds l d a p servers by name
*/
func (a *Client) FindLDAPServersByName(params *FindLDAPServersByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*FindLDAPServersByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindLDAPServersByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "findLDAPServersByName",
		Method:             "GET",
		PathPattern:        "/ldapservers/name/{name}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &FindLDAPServersByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindLDAPServersByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for findLDAPServersByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateLDAPServerByID updates an existing l d a p server by ID
*/
func (a *Client) UpdateLDAPServerByID(params *UpdateLDAPServerByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLDAPServerByIDCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLDAPServerByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateLDAPServerById",
		Method:             "PUT",
		PathPattern:        "/ldapservers/id/{id}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLDAPServerByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateLDAPServerByIDCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateLDAPServerById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateLDAPServerByName updates an existing l d a p server by name
*/
func (a *Client) UpdateLDAPServerByName(params *UpdateLDAPServerByNameParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateLDAPServerByNameCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateLDAPServerByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateLDAPServerByName",
		Method:             "PUT",
		PathPattern:        "/ldapservers/name/{name}",
		ProducesMediaTypes: []string{"application/xml"},
		ConsumesMediaTypes: []string{"application/xml"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateLDAPServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateLDAPServerByNameCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateLDAPServerByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
