// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Ebook ebook
//
// swagger:model ebook
type Ebook struct {

	// general
	General *EbookGeneral `json:"general,omitempty"`

	// scope
	Scope *EbookScope `json:"scope,omitempty"`

	// self service
	SelfService *EbookSelfService `json:"self_service,omitempty"`
}

// Validate validates this ebook
func (m *Ebook) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Ebook) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *Ebook) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *Ebook) validateSelfService(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfService) { // not required
		return nil
	}

	if m.SelfService != nil {
		if err := m.SelfService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook based on the context it is used
func (m *Ebook) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Ebook) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *Ebook) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *Ebook) contextValidateSelfService(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfService != nil {

		if swag.IsZero(m.SelfService) { // not required
			return nil
		}

		if err := m.SelfService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Ebook) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Ebook) UnmarshalBinary(b []byte) error {
	var res Ebook
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookGeneral ebook general
//
// swagger:model EbookGeneral
type EbookGeneral struct {

	// author
	// Example: Apple Inc.
	Author string `json:"author,omitempty"`

	// category
	Category *CategoryObject `json:"category,omitempty"`

	// deploy as managed
	DeployAsManaged bool `json:"deploy_as_managed,omitempty"`

	// deployment type
	// Enum: [Make Available in Self Service Install Automatically/Prompt Users to Install]
	DeploymentType string `json:"deployment_type,omitempty"`

	// file type
	// Enum: [PDF IBOOK EPUB]
	FileType string `json:"file_type,omitempty"`

	// free
	Free bool `json:"free,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the ebook
	// Example: iPhone User Guide for iOS 10.3
	// Required: true
	Name *string `json:"name"`

	// self service icon
	SelfServiceIcon *EbookGeneralSelfServiceIcon `json:"self_service_icon,omitempty"`

	// site
	Site *SiteObject `json:"site,omitempty"`

	// Download URL for the ebook
	// Example: https://itunes.apple.com/us/book/iphone-user-guide-for-ios-10-3/id1134772174?mt=11\u0026amp;uo=4
	URL string `json:"url,omitempty"`

	// version
	Version string `json:"version,omitempty"`
}

// Validate validates this ebook general
func (m *EbookGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeploymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfServiceIcon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookGeneral) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

var ebookGeneralTypeDeploymentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Make Available in Self Service","Install Automatically/Prompt Users to Install"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ebookGeneralTypeDeploymentTypePropEnum = append(ebookGeneralTypeDeploymentTypePropEnum, v)
	}
}

const (

	// EbookGeneralDeploymentTypeMakeAvailableInSelfService captures enum value "Make Available in Self Service"
	EbookGeneralDeploymentTypeMakeAvailableInSelfService string = "Make Available in Self Service"

	// EbookGeneralDeploymentTypeInstallAutomaticallyPromptUsersToInstall captures enum value "Install Automatically/Prompt Users to Install"
	EbookGeneralDeploymentTypeInstallAutomaticallyPromptUsersToInstall string = "Install Automatically/Prompt Users to Install"
)

// prop value enum
func (m *EbookGeneral) validateDeploymentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ebookGeneralTypeDeploymentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EbookGeneral) validateDeploymentType(formats strfmt.Registry) error {
	if swag.IsZero(m.DeploymentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeploymentTypeEnum("general"+"."+"deployment_type", "body", m.DeploymentType); err != nil {
		return err
	}

	return nil
}

var ebookGeneralTypeFileTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PDF","IBOOK","EPUB"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ebookGeneralTypeFileTypePropEnum = append(ebookGeneralTypeFileTypePropEnum, v)
	}
}

const (

	// EbookGeneralFileTypePDF captures enum value "PDF"
	EbookGeneralFileTypePDF string = "PDF"

	// EbookGeneralFileTypeIBOOK captures enum value "IBOOK"
	EbookGeneralFileTypeIBOOK string = "IBOOK"

	// EbookGeneralFileTypeEPUB captures enum value "EPUB"
	EbookGeneralFileTypeEPUB string = "EPUB"
)

// prop value enum
func (m *EbookGeneral) validateFileTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ebookGeneralTypeFileTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EbookGeneral) validateFileType(formats strfmt.Registry) error {
	if swag.IsZero(m.FileType) { // not required
		return nil
	}

	// value enum
	if err := m.validateFileTypeEnum("general"+"."+"file_type", "body", m.FileType); err != nil {
		return err
	}

	return nil
}

func (m *EbookGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *EbookGeneral) validateSelfServiceIcon(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceIcon) { // not required
		return nil
	}

	if m.SelfServiceIcon != nil {
		if err := m.SelfServiceIcon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

func (m *EbookGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook general based on the context it is used
func (m *EbookGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfServiceIcon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookGeneral) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *EbookGeneral) contextValidateSelfServiceIcon(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceIcon != nil {

		if swag.IsZero(m.SelfServiceIcon) { // not required
			return nil
		}

		if err := m.SelfServiceIcon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

func (m *EbookGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookGeneral) UnmarshalBinary(b []byte) error {
	var res EbookGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookGeneralSelfServiceIcon ebook general self service icon
//
// swagger:model EbookGeneralSelfServiceIcon
type EbookGeneralSelfServiceIcon struct {

	// data
	Data string `json:"data,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// uri
	// Example: https://company.jamfcloud.com/iconservlet/?id=1
	URI string `json:"uri,omitempty"`
}

// Validate validates this ebook general self service icon
func (m *EbookGeneralSelfServiceIcon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook general self service icon based on context it is used
func (m *EbookGeneralSelfServiceIcon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookGeneralSelfServiceIcon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookGeneralSelfServiceIcon) UnmarshalBinary(b []byte) error {
	var res EbookGeneralSelfServiceIcon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScope ebook scope
//
// swagger:model EbookScope
type EbookScope struct {

	// all computers
	AllComputers *bool `json:"all_computers,omitempty"`

	// all jss users
	AllJssUsers *bool `json:"all_jss_users,omitempty"`

	// all mobile devices
	AllMobileDevices *bool `json:"all_mobile_devices,omitempty"`

	// buildings
	Buildings []*EbookScopeBuildingsItems0 `json:"buildings"`

	// classes
	Classes []*EbookScopeClassesItems0 `json:"classes"`

	// computer groups
	ComputerGroups []*EbookScopeComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*EbookScopeComputersItems0 `json:"computers"`

	// departments
	Departments []*EbookScopeDepartmentsItems0 `json:"departments"`

	// exclusions
	Exclusions *EbookScopeExclusions `json:"exclusions,omitempty"`

	// jss user groups
	JssUserGroups []*EbookScopeJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*EbookScopeJssUsersItems0 `json:"jss_users"`

	// limitations
	Limitations *EbookScopeLimitations `json:"limitations,omitempty"`

	// mobile device groups
	MobileDeviceGroups []*EbookScopeMobileDeviceGroupsItems0 `json:"mobile_device_groups"`

	// mobile devices
	MobileDevices []*EbookScopeMobileDevicesItems0 `json:"mobile_devices"`
}

// Validate validates this ebook scope
func (m *EbookScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClasses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobileDeviceGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobileDevices(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScope) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateClasses(formats strfmt.Registry) error {
	if swag.IsZero(m.Classes) { // not required
		return nil
	}

	for i := 0; i < len(m.Classes); i++ {
		if swag.IsZero(m.Classes[i]) { // not required
			continue
		}

		if m.Classes[i] != nil {
			if err := m.Classes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "classes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "classes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *EbookScope) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

func (m *EbookScope) validateMobileDeviceGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDeviceGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.MobileDeviceGroups); i++ {
		if swag.IsZero(m.MobileDeviceGroups[i]) { // not required
			continue
		}

		if m.MobileDeviceGroups[i] != nil {
			if err := m.MobileDeviceGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) validateMobileDevices(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDevices) { // not required
		return nil
	}

	for i := 0; i < len(m.MobileDevices); i++ {
		if swag.IsZero(m.MobileDevices[i]) { // not required
			continue
		}

		if m.MobileDevices[i] != nil {
			if err := m.MobileDevices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this ebook scope based on the context it is used
func (m *EbookScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClasses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMobileDeviceGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMobileDevices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScope) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateClasses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Classes); i++ {

		if m.Classes[i] != nil {

			if swag.IsZero(m.Classes[i]) { // not required
				return nil
			}

			if err := m.Classes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "classes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "classes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *EbookScope) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

func (m *EbookScope) contextValidateMobileDeviceGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MobileDeviceGroups); i++ {

		if m.MobileDeviceGroups[i] != nil {

			if swag.IsZero(m.MobileDeviceGroups[i]) { // not required
				return nil
			}

			if err := m.MobileDeviceGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScope) contextValidateMobileDevices(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MobileDevices); i++ {

		if m.MobileDevices[i] != nil {

			if swag.IsZero(m.MobileDevices[i]) { // not required
				return nil
			}

			if err := m.MobileDevices[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScope) UnmarshalBinary(b []byte) error {
	var res EbookScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeBuildingsItems0 ebook scope buildings items0
//
// swagger:model EbookScopeBuildingsItems0
type EbookScopeBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this ebook scope buildings items0
func (m *EbookScopeBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope buildings items0 based on the context it is used
func (m *EbookScopeBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeClassesItems0 ebook scope classes items0
//
// swagger:model EbookScopeClassesItems0
type EbookScopeClassesItems0 struct {

	// class
	Class *IDName `json:"class,omitempty"`
}

// Validate validates this ebook scope classes items0
func (m *EbookScopeClassesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeClassesItems0) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(m.Class) { // not required
		return nil
	}

	if m.Class != nil {
		if err := m.Class.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("class")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("class")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope classes items0 based on the context it is used
func (m *EbookScopeClassesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClass(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeClassesItems0) contextValidateClass(ctx context.Context, formats strfmt.Registry) error {

	if m.Class != nil {

		if swag.IsZero(m.Class) { // not required
			return nil
		}

		if err := m.Class.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("class")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("class")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeClassesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeClassesItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeClassesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeComputerGroupsItems0 ebook scope computer groups items0
//
// swagger:model EbookScopeComputerGroupsItems0
type EbookScopeComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this ebook scope computer groups items0
func (m *EbookScopeComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope computer groups items0 based on the context it is used
func (m *EbookScopeComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeComputersItems0 ebook scope computers items0
//
// swagger:model EbookScopeComputersItems0
type EbookScopeComputersItems0 struct {

	// computer
	Computer *EbookScopeComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this ebook scope computers items0
func (m *EbookScopeComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope computers items0 based on the context it is used
func (m *EbookScopeComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeComputersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeComputersItems0Computer ebook scope computers items0 computer
//
// swagger:model EbookScopeComputersItems0Computer
type EbookScopeComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Admins MacBook Pro
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this ebook scope computers items0 computer
func (m *EbookScopeComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope computers items0 computer based on context it is used
func (m *EbookScopeComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res EbookScopeComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeDepartmentsItems0 ebook scope departments items0
//
// swagger:model EbookScopeDepartmentsItems0
type EbookScopeDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this ebook scope departments items0
func (m *EbookScopeDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope departments items0 based on the context it is used
func (m *EbookScopeDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusions ebook scope exclusions
//
// swagger:model EbookScopeExclusions
type EbookScopeExclusions struct {

	// buildings
	Buildings []*EbookScopeExclusionsBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*EbookScopeExclusionsComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*EbookScopeExclusionsComputersItems0 `json:"computers"`

	// departments
	Departments []*EbookScopeExclusionsDepartmentsItems0 `json:"departments"`

	// jss user groups
	JssUserGroups []*EbookScopeExclusionsJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*EbookScopeExclusionsJssUsersItems0 `json:"jss_users"`

	// mobile device groups
	MobileDeviceGroups []*EbookScopeExclusionsMobileDeviceGroupsItems0 `json:"mobile_device_groups"`

	// mobile devices
	MobileDevices []*EbookScopeExclusionsMobileDevicesItems0 `json:"mobile_devices"`

	// network segments
	NetworkSegments []*EbookScopeExclusionsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*EbookScopeExclusionsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*EbookScopeExclusionsUsersItems0 `json:"users"`
}

// Validate validates this ebook scope exclusions
func (m *EbookScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobileDeviceGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobileDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusions) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateMobileDeviceGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDeviceGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.MobileDeviceGroups); i++ {
		if swag.IsZero(m.MobileDeviceGroups[i]) { // not required
			continue
		}

		if m.MobileDeviceGroups[i] != nil {
			if err := m.MobileDeviceGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateMobileDevices(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDevices) { // not required
		return nil
	}

	for i := 0; i < len(m.MobileDevices); i++ {
		if swag.IsZero(m.MobileDevices[i]) { // not required
			continue
		}

		if m.MobileDevices[i] != nil {
			if err := m.MobileDevices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this ebook scope exclusions based on the context it is used
func (m *EbookScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMobileDeviceGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMobileDevices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusions) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateMobileDeviceGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MobileDeviceGroups); i++ {

		if m.MobileDeviceGroups[i] != nil {

			if swag.IsZero(m.MobileDeviceGroups[i]) { // not required
				return nil
			}

			if err := m.MobileDeviceGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "mobile_device_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateMobileDevices(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MobileDevices); i++ {

		if m.MobileDevices[i] != nil {

			if swag.IsZero(m.MobileDevices[i]) { // not required
				return nil
			}

			if err := m.MobileDevices[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "mobile_devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeExclusions) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusions) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsBuildingsItems0 ebook scope exclusions buildings items0
//
// swagger:model EbookScopeExclusionsBuildingsItems0
type EbookScopeExclusionsBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this ebook scope exclusions buildings items0
func (m *EbookScopeExclusionsBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions buildings items0 based on the context it is used
func (m *EbookScopeExclusionsBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsComputerGroupsItems0 ebook scope exclusions computer groups items0
//
// swagger:model EbookScopeExclusionsComputerGroupsItems0
type EbookScopeExclusionsComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this ebook scope exclusions computer groups items0
func (m *EbookScopeExclusionsComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions computer groups items0 based on the context it is used
func (m *EbookScopeExclusionsComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsComputersItems0 ebook scope exclusions computers items0
//
// swagger:model EbookScopeExclusionsComputersItems0
type EbookScopeExclusionsComputersItems0 struct {

	// computer
	Computer *EbookScopeExclusionsComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this ebook scope exclusions computers items0
func (m *EbookScopeExclusionsComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions computers items0 based on the context it is used
func (m *EbookScopeExclusionsComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsComputersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsComputersItems0Computer ebook scope exclusions computers items0 computer
//
// swagger:model EbookScopeExclusionsComputersItems0Computer
type EbookScopeExclusionsComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Johns iMac
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this ebook scope exclusions computers items0 computer
func (m *EbookScopeExclusionsComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope exclusions computers items0 computer based on context it is used
func (m *EbookScopeExclusionsComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsDepartmentsItems0 ebook scope exclusions departments items0
//
// swagger:model EbookScopeExclusionsDepartmentsItems0
type EbookScopeExclusionsDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this ebook scope exclusions departments items0
func (m *EbookScopeExclusionsDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions departments items0 based on the context it is used
func (m *EbookScopeExclusionsDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsJssUserGroupsItems0 ebook scope exclusions jss user groups items0
//
// swagger:model EbookScopeExclusionsJssUserGroupsItems0
type EbookScopeExclusionsJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this ebook scope exclusions jss user groups items0
func (m *EbookScopeExclusionsJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions jss user groups items0 based on the context it is used
func (m *EbookScopeExclusionsJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsJssUsersItems0 ebook scope exclusions jss users items0
//
// swagger:model EbookScopeExclusionsJssUsersItems0
type EbookScopeExclusionsJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this ebook scope exclusions jss users items0
func (m *EbookScopeExclusionsJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions jss users items0 based on the context it is used
func (m *EbookScopeExclusionsJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsMobileDeviceGroupsItems0 ebook scope exclusions mobile device groups items0
//
// swagger:model EbookScopeExclusionsMobileDeviceGroupsItems0
type EbookScopeExclusionsMobileDeviceGroupsItems0 struct {

	// mobile device group
	MobileDeviceGroup *IDName `json:"mobile_device_group,omitempty"`
}

// Validate validates this ebook scope exclusions mobile device groups items0
func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMobileDeviceGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) validateMobileDeviceGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDeviceGroup) { // not required
		return nil
	}

	if m.MobileDeviceGroup != nil {
		if err := m.MobileDeviceGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions mobile device groups items0 based on the context it is used
func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMobileDeviceGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) contextValidateMobileDeviceGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.MobileDeviceGroup != nil {

		if swag.IsZero(m.MobileDeviceGroup) { // not required
			return nil
		}

		if err := m.MobileDeviceGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDeviceGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsMobileDeviceGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsMobileDevicesItems0 ebook scope exclusions mobile devices items0
//
// swagger:model EbookScopeExclusionsMobileDevicesItems0
type EbookScopeExclusionsMobileDevicesItems0 struct {

	// mobile device
	MobileDevice *EbookScopeExclusionsMobileDevicesItems0MobileDevice `json:"mobile_device,omitempty"`
}

// Validate validates this ebook scope exclusions mobile devices items0
func (m *EbookScopeExclusionsMobileDevicesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMobileDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsMobileDevicesItems0) validateMobileDevice(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDevice) { // not required
		return nil
	}

	if m.MobileDevice != nil {
		if err := m.MobileDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions mobile devices items0 based on the context it is used
func (m *EbookScopeExclusionsMobileDevicesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMobileDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsMobileDevicesItems0) contextValidateMobileDevice(ctx context.Context, formats strfmt.Registry) error {

	if m.MobileDevice != nil {

		if swag.IsZero(m.MobileDevice) { // not required
			return nil
		}

		if err := m.MobileDevice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDevicesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDevicesItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsMobileDevicesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsMobileDevicesItems0MobileDevice ebook scope exclusions mobile devices items0 mobile device
//
// swagger:model EbookScopeExclusionsMobileDevicesItems0MobileDevice
type EbookScopeExclusionsMobileDevicesItems0MobileDevice struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the device
	// Example: Johns iPad
	Name string `json:"name,omitempty"`

	// udid
	// Example: 270aae10800b6e61a2ee2bbc285eb967050b5984
	Udid string `json:"udid,omitempty"`

	// wifi mac address
	// Example: E0:AC:CB:97:36:G4
	WifiMacAddress string `json:"wifi_mac_address,omitempty"`
}

// Validate validates this ebook scope exclusions mobile devices items0 mobile device
func (m *EbookScopeExclusionsMobileDevicesItems0MobileDevice) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope exclusions mobile devices items0 mobile device based on context it is used
func (m *EbookScopeExclusionsMobileDevicesItems0MobileDevice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDevicesItems0MobileDevice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsMobileDevicesItems0MobileDevice) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsMobileDevicesItems0MobileDevice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsNetworkSegmentsItems0 ebook scope exclusions network segments items0
//
// swagger:model EbookScopeExclusionsNetworkSegmentsItems0
type EbookScopeExclusionsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment `json:"network_segment,omitempty"`
}

// Validate validates this ebook scope exclusions network segments items0
func (m *EbookScopeExclusionsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions network segments items0 based on the context it is used
func (m *EbookScopeExclusionsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment ebook scope exclusions network segments items0 network segment
//
// swagger:model EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment
type EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the network segment
	// Example: New York
	Name string `json:"name,omitempty"`

	// uid
	UID string `json:"uid,omitempty"`
}

// Validate validates this ebook scope exclusions network segments items0 network segment
func (m *EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope exclusions network segments items0 network segment based on context it is used
func (m *EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsNetworkSegmentsItems0NetworkSegment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsUserGroupsItems0 ebook scope exclusions user groups items0
//
// swagger:model EbookScopeExclusionsUserGroupsItems0
type EbookScopeExclusionsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this ebook scope exclusions user groups items0
func (m *EbookScopeExclusionsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions user groups items0 based on the context it is used
func (m *EbookScopeExclusionsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsUsersItems0 ebook scope exclusions users items0
//
// swagger:model EbookScopeExclusionsUsersItems0
type EbookScopeExclusionsUsersItems0 struct {

	// user
	User *EbookScopeExclusionsUsersItems0User `json:"user,omitempty"`
}

// Validate validates this ebook scope exclusions users items0
func (m *EbookScopeExclusionsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope exclusions users items0 based on the context it is used
func (m *EbookScopeExclusionsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeExclusionsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsUsersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeExclusionsUsersItems0User ebook scope exclusions users items0 user
//
// swagger:model EbookScopeExclusionsUsersItems0User
type EbookScopeExclusionsUsersItems0User struct {

	// name
	// Example: Adam
	Name string `json:"name,omitempty"`
}

// Validate validates this ebook scope exclusions users items0 user
func (m *EbookScopeExclusionsUsersItems0User) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope exclusions users items0 user based on context it is used
func (m *EbookScopeExclusionsUsersItems0User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeExclusionsUsersItems0User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeExclusionsUsersItems0User) UnmarshalBinary(b []byte) error {
	var res EbookScopeExclusionsUsersItems0User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeJssUserGroupsItems0 ebook scope jss user groups items0
//
// swagger:model EbookScopeJssUserGroupsItems0
type EbookScopeJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this ebook scope jss user groups items0
func (m *EbookScopeJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope jss user groups items0 based on the context it is used
func (m *EbookScopeJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeJssUsersItems0 ebook scope jss users items0
//
// swagger:model EbookScopeJssUsersItems0
type EbookScopeJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this ebook scope jss users items0
func (m *EbookScopeJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope jss users items0 based on the context it is used
func (m *EbookScopeJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeLimitations ebook scope limitations
//
// swagger:model EbookScopeLimitations
type EbookScopeLimitations struct {

	// network segments
	NetworkSegments []*EbookScopeLimitationsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*EbookScopeLimitationsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*EbookScopeLimitationsUsersItems0 `json:"users"`
}

// Validate validates this ebook scope limitations
func (m *EbookScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitations) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeLimitations) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeLimitations) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this ebook scope limitations based on the context it is used
func (m *EbookScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitations) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeLimitations) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *EbookScopeLimitations) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeLimitations) UnmarshalBinary(b []byte) error {
	var res EbookScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeLimitationsNetworkSegmentsItems0 ebook scope limitations network segments items0
//
// swagger:model EbookScopeLimitationsNetworkSegmentsItems0
type EbookScopeLimitationsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

// Validate validates this ebook scope limitations network segments items0
func (m *EbookScopeLimitationsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope limitations network segments items0 based on the context it is used
func (m *EbookScopeLimitationsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeLimitationsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeLimitationsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeLimitationsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeLimitationsUserGroupsItems0 ebook scope limitations user groups items0
//
// swagger:model EbookScopeLimitationsUserGroupsItems0
type EbookScopeLimitationsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this ebook scope limitations user groups items0
func (m *EbookScopeLimitationsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope limitations user groups items0 based on the context it is used
func (m *EbookScopeLimitationsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeLimitationsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeLimitationsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeLimitationsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeLimitationsUsersItems0 ebook scope limitations users items0
//
// swagger:model EbookScopeLimitationsUsersItems0
type EbookScopeLimitationsUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this ebook scope limitations users items0
func (m *EbookScopeLimitationsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope limitations users items0 based on the context it is used
func (m *EbookScopeLimitationsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeLimitationsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeLimitationsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeLimitationsUsersItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeLimitationsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeMobileDeviceGroupsItems0 ebook scope mobile device groups items0
//
// swagger:model EbookScopeMobileDeviceGroupsItems0
type EbookScopeMobileDeviceGroupsItems0 struct {

	// mobile device group
	MobileDeviceGroup *IDName `json:"mobile_device_group,omitempty"`
}

// Validate validates this ebook scope mobile device groups items0
func (m *EbookScopeMobileDeviceGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMobileDeviceGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeMobileDeviceGroupsItems0) validateMobileDeviceGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDeviceGroup) { // not required
		return nil
	}

	if m.MobileDeviceGroup != nil {
		if err := m.MobileDeviceGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope mobile device groups items0 based on the context it is used
func (m *EbookScopeMobileDeviceGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMobileDeviceGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeMobileDeviceGroupsItems0) contextValidateMobileDeviceGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.MobileDeviceGroup != nil {

		if swag.IsZero(m.MobileDeviceGroup) { // not required
			return nil
		}

		if err := m.MobileDeviceGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeMobileDeviceGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeMobileDeviceGroupsItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeMobileDeviceGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeMobileDevicesItems0 ebook scope mobile devices items0
//
// swagger:model EbookScopeMobileDevicesItems0
type EbookScopeMobileDevicesItems0 struct {

	// mobile device
	MobileDevice *EbookScopeMobileDevicesItems0MobileDevice `json:"mobile_device,omitempty"`
}

// Validate validates this ebook scope mobile devices items0
func (m *EbookScopeMobileDevicesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMobileDevice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeMobileDevicesItems0) validateMobileDevice(formats strfmt.Registry) error {
	if swag.IsZero(m.MobileDevice) { // not required
		return nil
	}

	if m.MobileDevice != nil {
		if err := m.MobileDevice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook scope mobile devices items0 based on the context it is used
func (m *EbookScopeMobileDevicesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMobileDevice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookScopeMobileDevicesItems0) contextValidateMobileDevice(ctx context.Context, formats strfmt.Registry) error {

	if m.MobileDevice != nil {

		if swag.IsZero(m.MobileDevice) { // not required
			return nil
		}

		if err := m.MobileDevice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile_device")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mobile_device")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeMobileDevicesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeMobileDevicesItems0) UnmarshalBinary(b []byte) error {
	var res EbookScopeMobileDevicesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookScopeMobileDevicesItems0MobileDevice ebook scope mobile devices items0 mobile device
//
// swagger:model EbookScopeMobileDevicesItems0MobileDevice
type EbookScopeMobileDevicesItems0MobileDevice struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the device
	// Example: Admins iPad
	Name string `json:"name,omitempty"`

	// udid
	// Example: 270aae10800b6e61a2ee2bbc285eb967050b5984
	Udid string `json:"udid,omitempty"`

	// wifi mac address
	// Example: E0:AC:CB:97:36:G4
	WifiMacAddress string `json:"wifi_mac_address,omitempty"`
}

// Validate validates this ebook scope mobile devices items0 mobile device
func (m *EbookScopeMobileDevicesItems0MobileDevice) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook scope mobile devices items0 mobile device based on context it is used
func (m *EbookScopeMobileDevicesItems0MobileDevice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookScopeMobileDevicesItems0MobileDevice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookScopeMobileDevicesItems0MobileDevice) UnmarshalBinary(b []byte) error {
	var res EbookScopeMobileDevicesItems0MobileDevice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookSelfService ebook self service
//
// swagger:model EbookSelfService
type EbookSelfService struct {

	// feature on main page
	FeatureOnMainPage bool `json:"feature_on_main_page,omitempty"`

	// force users to view description
	ForceUsersToViewDescription bool `json:"force_users_to_view_description,omitempty"`

	// install button text
	// Example: Install
	InstallButtonText string `json:"install_button_text,omitempty"`

	// notification
	Notification bool `json:"notification,omitempty"`

	// notification message
	NotificationMessage string `json:"notification_message,omitempty"`

	// notification subject
	NotificationSubject string `json:"notification_subject,omitempty"`

	// self service categories
	SelfServiceCategories *EbookSelfServiceSelfServiceCategories `json:"self_service_categories,omitempty"`

	// self service description
	SelfServiceDescription string `json:"self_service_description,omitempty"`

	// self service display name
	// Example: iPhone User Guide for iOS 10.3
	SelfServiceDisplayName string `json:"self_service_display_name,omitempty"`

	// self service icon
	SelfServiceIcon *EbookSelfServiceSelfServiceIcon `json:"self_service_icon,omitempty"`
}

// Validate validates this ebook self service
func (m *EbookSelfService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelfServiceCategories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfServiceIcon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookSelfService) validateSelfServiceCategories(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceCategories) { // not required
		return nil
	}

	if m.SelfServiceCategories != nil {
		if err := m.SelfServiceCategories.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories")
			}
			return err
		}
	}

	return nil
}

func (m *EbookSelfService) validateSelfServiceIcon(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceIcon) { // not required
		return nil
	}

	if m.SelfServiceIcon != nil {
		if err := m.SelfServiceIcon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook self service based on the context it is used
func (m *EbookSelfService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelfServiceCategories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfServiceIcon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookSelfService) contextValidateSelfServiceCategories(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceCategories != nil {

		if swag.IsZero(m.SelfServiceCategories) { // not required
			return nil
		}

		if err := m.SelfServiceCategories.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories")
			}
			return err
		}
	}

	return nil
}

func (m *EbookSelfService) contextValidateSelfServiceIcon(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceIcon != nil {

		if swag.IsZero(m.SelfServiceIcon) { // not required
			return nil
		}

		if err := m.SelfServiceIcon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookSelfService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookSelfService) UnmarshalBinary(b []byte) error {
	var res EbookSelfService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookSelfServiceSelfServiceCategories ebook self service self service categories
//
// swagger:model EbookSelfServiceSelfServiceCategories
type EbookSelfServiceSelfServiceCategories struct {

	// category
	Category *EbookSelfServiceSelfServiceCategoriesCategory `json:"category,omitempty"`
}

// Validate validates this ebook self service self service categories
func (m *EbookSelfServiceSelfServiceCategories) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookSelfServiceSelfServiceCategories) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ebook self service self service categories based on the context it is used
func (m *EbookSelfServiceSelfServiceCategories) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EbookSelfServiceSelfServiceCategories) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceCategories) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceCategories) UnmarshalBinary(b []byte) error {
	var res EbookSelfServiceSelfServiceCategories
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookSelfServiceSelfServiceCategoriesCategory ebook self service self service categories category
//
// swagger:model EbookSelfServiceSelfServiceCategoriesCategory
type EbookSelfServiceSelfServiceCategoriesCategory struct {

	// Self Service categories to be displayed ebook in
	DisplayIn string `json:"display_in,omitempty"`

	// feature in
	FeatureIn bool `json:"feature_in,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the category
	// Example: eBooks
	Name string `json:"name,omitempty"`
}

// Validate validates this ebook self service self service categories category
func (m *EbookSelfServiceSelfServiceCategoriesCategory) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook self service self service categories category based on context it is used
func (m *EbookSelfServiceSelfServiceCategoriesCategory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceCategoriesCategory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceCategoriesCategory) UnmarshalBinary(b []byte) error {
	var res EbookSelfServiceSelfServiceCategoriesCategory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// EbookSelfServiceSelfServiceIcon ebook self service self service icon
//
// swagger:model EbookSelfServiceSelfServiceIcon
type EbookSelfServiceSelfServiceIcon struct {

	// data
	Data string `json:"data,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// uri
	// Example: https://company.jamfcloud.com/iconservlet/?id=1
	URI string `json:"uri,omitempty"`
}

// Validate validates this ebook self service self service icon
func (m *EbookSelfServiceSelfServiceIcon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ebook self service self service icon based on context it is used
func (m *EbookSelfServiceSelfServiceIcon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceIcon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EbookSelfServiceSelfServiceIcon) UnmarshalBinary(b []byte) error {
	var res EbookSelfServiceSelfServiceIcon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
