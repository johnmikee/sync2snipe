// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Logflush logflush
//
// swagger:model logflush
type Logflush struct {

	// computers
	Computers *LogflushComputers `json:"computers,omitempty"`

	// interval
	// Required: true
	// Enum: [Zero Days Zero Weeks Zero Months Zero Years One Days One Weeks One Months One Years Two Days Two Weeks Two Months Two Years Three Days Three Weeks Three Months Three Years Six Days Six Weeks Six Months Six Years]
	Interval *string `json:"interval"`

	// log
	// Required: true
	// Enum: [policy]
	Log *string `json:"log"`

	// log id
	// Example: 1
	// Required: true
	LogID *int64 `json:"log_id"`
}

// Validate validates this logflush
func (m *Logflush) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLog(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Logflush) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	if m.Computers != nil {
		if err := m.Computers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computers")
			}
			return err
		}
	}

	return nil
}

var logflushTypeIntervalPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Zero Days","Zero Weeks","Zero Months","Zero Years","One Days","One Weeks","One Months","One Years","Two Days","Two Weeks","Two Months","Two Years","Three Days","Three Weeks","Three Months","Three Years","Six Days","Six Weeks","Six Months","Six Years"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		logflushTypeIntervalPropEnum = append(logflushTypeIntervalPropEnum, v)
	}
}

const (

	// LogflushIntervalZeroDays captures enum value "Zero Days"
	LogflushIntervalZeroDays string = "Zero Days"

	// LogflushIntervalZeroWeeks captures enum value "Zero Weeks"
	LogflushIntervalZeroWeeks string = "Zero Weeks"

	// LogflushIntervalZeroMonths captures enum value "Zero Months"
	LogflushIntervalZeroMonths string = "Zero Months"

	// LogflushIntervalZeroYears captures enum value "Zero Years"
	LogflushIntervalZeroYears string = "Zero Years"

	// LogflushIntervalOneDays captures enum value "One Days"
	LogflushIntervalOneDays string = "One Days"

	// LogflushIntervalOneWeeks captures enum value "One Weeks"
	LogflushIntervalOneWeeks string = "One Weeks"

	// LogflushIntervalOneMonths captures enum value "One Months"
	LogflushIntervalOneMonths string = "One Months"

	// LogflushIntervalOneYears captures enum value "One Years"
	LogflushIntervalOneYears string = "One Years"

	// LogflushIntervalTwoDays captures enum value "Two Days"
	LogflushIntervalTwoDays string = "Two Days"

	// LogflushIntervalTwoWeeks captures enum value "Two Weeks"
	LogflushIntervalTwoWeeks string = "Two Weeks"

	// LogflushIntervalTwoMonths captures enum value "Two Months"
	LogflushIntervalTwoMonths string = "Two Months"

	// LogflushIntervalTwoYears captures enum value "Two Years"
	LogflushIntervalTwoYears string = "Two Years"

	// LogflushIntervalThreeDays captures enum value "Three Days"
	LogflushIntervalThreeDays string = "Three Days"

	// LogflushIntervalThreeWeeks captures enum value "Three Weeks"
	LogflushIntervalThreeWeeks string = "Three Weeks"

	// LogflushIntervalThreeMonths captures enum value "Three Months"
	LogflushIntervalThreeMonths string = "Three Months"

	// LogflushIntervalThreeYears captures enum value "Three Years"
	LogflushIntervalThreeYears string = "Three Years"

	// LogflushIntervalSixDays captures enum value "Six Days"
	LogflushIntervalSixDays string = "Six Days"

	// LogflushIntervalSixWeeks captures enum value "Six Weeks"
	LogflushIntervalSixWeeks string = "Six Weeks"

	// LogflushIntervalSixMonths captures enum value "Six Months"
	LogflushIntervalSixMonths string = "Six Months"

	// LogflushIntervalSixYears captures enum value "Six Years"
	LogflushIntervalSixYears string = "Six Years"
)

// prop value enum
func (m *Logflush) validateIntervalEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, logflushTypeIntervalPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Logflush) validateInterval(formats strfmt.Registry) error {

	if err := validate.Required("interval", "body", m.Interval); err != nil {
		return err
	}

	// value enum
	if err := m.validateIntervalEnum("interval", "body", *m.Interval); err != nil {
		return err
	}

	return nil
}

var logflushTypeLogPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["policy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		logflushTypeLogPropEnum = append(logflushTypeLogPropEnum, v)
	}
}

const (

	// LogflushLogPolicy captures enum value "policy"
	LogflushLogPolicy string = "policy"
)

// prop value enum
func (m *Logflush) validateLogEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, logflushTypeLogPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Logflush) validateLog(formats strfmt.Registry) error {

	if err := validate.Required("log", "body", m.Log); err != nil {
		return err
	}

	// value enum
	if err := m.validateLogEnum("log", "body", *m.Log); err != nil {
		return err
	}

	return nil
}

func (m *Logflush) validateLogID(formats strfmt.Registry) error {

	if err := validate.Required("log_id", "body", m.LogID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this logflush based on the context it is used
func (m *Logflush) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Logflush) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	if m.Computers != nil {

		if swag.IsZero(m.Computers) { // not required
			return nil
		}

		if err := m.Computers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computers")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Logflush) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Logflush) UnmarshalBinary(b []byte) error {
	var res Logflush
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LogflushComputers logflush computers
//
// swagger:model LogflushComputers
type LogflushComputers struct {

	// computer
	Computer *LogflushComputersComputer `json:"computer,omitempty"`
}

// Validate validates this logflush computers
func (m *LogflushComputers) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogflushComputers) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computers" + "." + "computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computers" + "." + "computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this logflush computers based on the context it is used
func (m *LogflushComputers) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogflushComputers) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computers" + "." + "computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computers" + "." + "computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LogflushComputers) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogflushComputers) UnmarshalBinary(b []byte) error {
	var res LogflushComputers
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LogflushComputersComputer logflush computers computer
//
// swagger:model LogflushComputersComputer
type LogflushComputersComputer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`
}

// Validate validates this logflush computers computer
func (m *LogflushComputersComputer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this logflush computers computer based on context it is used
func (m *LogflushComputersComputer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LogflushComputersComputer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogflushComputersComputer) UnmarshalBinary(b []byte) error {
	var res LogflushComputersComputer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
