// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MacApplication mac application
//
// swagger:model mac_application
type MacApplication struct {

	// general
	General *MacApplicationGeneral `json:"general,omitempty"`

	// scope
	Scope *MacApplicationScope `json:"scope,omitempty"`

	// self service
	SelfService *MacApplicationSelfService `json:"self_service,omitempty"`
}

// Validate validates this mac application
func (m *MacApplication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfService(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplication) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplication) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplication) validateSelfService(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfService) { // not required
		return nil
	}

	if m.SelfService != nil {
		if err := m.SelfService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application based on the context it is used
func (m *MacApplication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplication) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplication) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplication) contextValidateSelfService(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfService != nil {

		if swag.IsZero(m.SelfService) { // not required
			return nil
		}

		if err := m.SelfService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplication) UnmarshalBinary(b []byte) error {
	var res MacApplication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationGeneral mac application general
//
// swagger:model MacApplicationGeneral
type MacApplicationGeneral struct {

	// bundle id
	// Example: com.barebones.textwrangler
	// Required: true
	BundleID *string `json:"bundle_id"`

	// category
	Category *CategoryObject `json:"category,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// is free
	IsFree bool `json:"is_free,omitempty"`

	// Name of the application
	// Example: TextWrangler.app
	// Required: true
	Name *string `json:"name"`

	// site
	Site *SiteObject `json:"site,omitempty"`

	// url
	// Example: https://itunes.apple.com/us/app/textwrangler/id404010395?mt=12\u0026amp;uo=4
	// Required: true
	URL *string `json:"url"`

	// version
	// Example: 5.5.2
	// Required: true
	Version *string `json:"version"`
}

// Validate validates this mac application general
func (m *MacApplicationGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBundleID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationGeneral) validateBundleID(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"bundle_id", "body", m.BundleID); err != nil {
		return err
	}

	return nil
}

func (m *MacApplicationGeneral) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *MacApplicationGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationGeneral) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"url", "body", m.URL); err != nil {
		return err
	}

	return nil
}

func (m *MacApplicationGeneral) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this mac application general based on the context it is used
func (m *MacApplicationGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationGeneral) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationGeneral) UnmarshalBinary(b []byte) error {
	var res MacApplicationGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScope mac application scope
//
// swagger:model MacApplicationScope
type MacApplicationScope struct {

	// all computers
	AllComputers *bool `json:"all_computers,omitempty"`

	// all jss users
	AllJssUsers *bool `json:"all_jss_users,omitempty"`

	// buildings
	Buildings []*MacApplicationScopeBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*MacApplicationScopeComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*MacApplicationScopeComputersItems0 `json:"computers"`

	// departments
	Departments []*MacApplicationScopeDepartmentsItems0 `json:"departments"`

	// exclusions
	Exclusions *MacApplicationScopeExclusions `json:"exclusions,omitempty"`

	// jss user groups
	JssUserGroups []*MacApplicationScopeJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*MacApplicationScopeJssUsersItems0 `json:"jss_users"`

	// limitations
	Limitations *MacApplicationScopeLimitations `json:"limitations,omitempty"`
}

// Validate validates this mac application scope
func (m *MacApplicationScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScope) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationScope) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope based on the context it is used
func (m *MacApplicationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScope) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationScope) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScope) UnmarshalBinary(b []byte) error {
	var res MacApplicationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeBuildingsItems0 mac application scope buildings items0
//
// swagger:model MacApplicationScopeBuildingsItems0
type MacApplicationScopeBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this mac application scope buildings items0
func (m *MacApplicationScopeBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope buildings items0 based on the context it is used
func (m *MacApplicationScopeBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeComputerGroupsItems0 mac application scope computer groups items0
//
// swagger:model MacApplicationScopeComputerGroupsItems0
type MacApplicationScopeComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this mac application scope computer groups items0
func (m *MacApplicationScopeComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope computer groups items0 based on the context it is used
func (m *MacApplicationScopeComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeComputersItems0 mac application scope computers items0
//
// swagger:model MacApplicationScopeComputersItems0
type MacApplicationScopeComputersItems0 struct {

	// computer
	Computer *MacApplicationScopeComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this mac application scope computers items0
func (m *MacApplicationScopeComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope computers items0 based on the context it is used
func (m *MacApplicationScopeComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeComputersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeComputersItems0Computer mac application scope computers items0 computer
//
// swagger:model MacApplicationScopeComputersItems0Computer
type MacApplicationScopeComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Admins MacBook Pro
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this mac application scope computers items0 computer
func (m *MacApplicationScopeComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application scope computers items0 computer based on context it is used
func (m *MacApplicationScopeComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeDepartmentsItems0 mac application scope departments items0
//
// swagger:model MacApplicationScopeDepartmentsItems0
type MacApplicationScopeDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this mac application scope departments items0
func (m *MacApplicationScopeDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope departments items0 based on the context it is used
func (m *MacApplicationScopeDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusions mac application scope exclusions
//
// swagger:model MacApplicationScopeExclusions
type MacApplicationScopeExclusions struct {

	// buildings
	Buildings []*MacApplicationScopeExclusionsBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*MacApplicationScopeExclusionsComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*MacApplicationScopeExclusionsComputersItems0 `json:"computers"`

	// departments
	Departments []*MacApplicationScopeExclusionsDepartmentsItems0 `json:"departments"`

	// jss user groups
	JssUserGroups []*MacApplicationScopeExclusionsJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*MacApplicationScopeExclusionsJssUsersItems0 `json:"jss_users"`

	// network segments
	NetworkSegments []*MacApplicationScopeExclusionsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*MacApplicationScopeExclusionsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*MacApplicationScopeExclusionsUsersItems0 `json:"users"`
}

// Validate validates this mac application scope exclusions
func (m *MacApplicationScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusions) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this mac application scope exclusions based on the context it is used
func (m *MacApplicationScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeExclusions) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusions) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsBuildingsItems0 mac application scope exclusions buildings items0
//
// swagger:model MacApplicationScopeExclusionsBuildingsItems0
type MacApplicationScopeExclusionsBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this mac application scope exclusions buildings items0
func (m *MacApplicationScopeExclusionsBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions buildings items0 based on the context it is used
func (m *MacApplicationScopeExclusionsBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsComputerGroupsItems0 mac application scope exclusions computer groups items0
//
// swagger:model MacApplicationScopeExclusionsComputerGroupsItems0
type MacApplicationScopeExclusionsComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this mac application scope exclusions computer groups items0
func (m *MacApplicationScopeExclusionsComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions computer groups items0 based on the context it is used
func (m *MacApplicationScopeExclusionsComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsComputersItems0 mac application scope exclusions computers items0
//
// swagger:model MacApplicationScopeExclusionsComputersItems0
type MacApplicationScopeExclusionsComputersItems0 struct {

	// computer
	Computer *MacApplicationScopeExclusionsComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this mac application scope exclusions computers items0
func (m *MacApplicationScopeExclusionsComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions computers items0 based on the context it is used
func (m *MacApplicationScopeExclusionsComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsComputersItems0Computer mac application scope exclusions computers items0 computer
//
// swagger:model MacApplicationScopeExclusionsComputersItems0Computer
type MacApplicationScopeExclusionsComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Johns iMac
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this mac application scope exclusions computers items0 computer
func (m *MacApplicationScopeExclusionsComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application scope exclusions computers items0 computer based on context it is used
func (m *MacApplicationScopeExclusionsComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsDepartmentsItems0 mac application scope exclusions departments items0
//
// swagger:model MacApplicationScopeExclusionsDepartmentsItems0
type MacApplicationScopeExclusionsDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this mac application scope exclusions departments items0
func (m *MacApplicationScopeExclusionsDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions departments items0 based on the context it is used
func (m *MacApplicationScopeExclusionsDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsJssUserGroupsItems0 mac application scope exclusions jss user groups items0
//
// swagger:model MacApplicationScopeExclusionsJssUserGroupsItems0
type MacApplicationScopeExclusionsJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this mac application scope exclusions jss user groups items0
func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions jss user groups items0 based on the context it is used
func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsJssUsersItems0 mac application scope exclusions jss users items0
//
// swagger:model MacApplicationScopeExclusionsJssUsersItems0
type MacApplicationScopeExclusionsJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this mac application scope exclusions jss users items0
func (m *MacApplicationScopeExclusionsJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions jss users items0 based on the context it is used
func (m *MacApplicationScopeExclusionsJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsNetworkSegmentsItems0 mac application scope exclusions network segments items0
//
// swagger:model MacApplicationScopeExclusionsNetworkSegmentsItems0
type MacApplicationScopeExclusionsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment `json:"network_segment,omitempty"`
}

// Validate validates this mac application scope exclusions network segments items0
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions network segments items0 based on the context it is used
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment mac application scope exclusions network segments items0 network segment
//
// swagger:model MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment
type MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the network segment
	// Example: New York
	Name string `json:"name,omitempty"`

	// uid
	UID string `json:"uid,omitempty"`
}

// Validate validates this mac application scope exclusions network segments items0 network segment
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application scope exclusions network segments items0 network segment based on context it is used
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsNetworkSegmentsItems0NetworkSegment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsUserGroupsItems0 mac application scope exclusions user groups items0
//
// swagger:model MacApplicationScopeExclusionsUserGroupsItems0
type MacApplicationScopeExclusionsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this mac application scope exclusions user groups items0
func (m *MacApplicationScopeExclusionsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions user groups items0 based on the context it is used
func (m *MacApplicationScopeExclusionsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsUsersItems0 mac application scope exclusions users items0
//
// swagger:model MacApplicationScopeExclusionsUsersItems0
type MacApplicationScopeExclusionsUsersItems0 struct {

	// user
	User *MacApplicationScopeExclusionsUsersItems0User `json:"user,omitempty"`
}

// Validate validates this mac application scope exclusions users items0
func (m *MacApplicationScopeExclusionsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope exclusions users items0 based on the context it is used
func (m *MacApplicationScopeExclusionsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeExclusionsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUsersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeExclusionsUsersItems0User mac application scope exclusions users items0 user
//
// swagger:model MacApplicationScopeExclusionsUsersItems0User
type MacApplicationScopeExclusionsUsersItems0User struct {

	// name
	// Example: Adam
	Name string `json:"name,omitempty"`
}

// Validate validates this mac application scope exclusions users items0 user
func (m *MacApplicationScopeExclusionsUsersItems0User) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application scope exclusions users items0 user based on context it is used
func (m *MacApplicationScopeExclusionsUsersItems0User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUsersItems0User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeExclusionsUsersItems0User) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeExclusionsUsersItems0User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeJssUserGroupsItems0 mac application scope jss user groups items0
//
// swagger:model MacApplicationScopeJssUserGroupsItems0
type MacApplicationScopeJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this mac application scope jss user groups items0
func (m *MacApplicationScopeJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope jss user groups items0 based on the context it is used
func (m *MacApplicationScopeJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeJssUsersItems0 mac application scope jss users items0
//
// swagger:model MacApplicationScopeJssUsersItems0
type MacApplicationScopeJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this mac application scope jss users items0
func (m *MacApplicationScopeJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope jss users items0 based on the context it is used
func (m *MacApplicationScopeJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeLimitations mac application scope limitations
//
// swagger:model MacApplicationScopeLimitations
type MacApplicationScopeLimitations struct {

	// network segments
	NetworkSegments []*MacApplicationScopeLimitationsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*MacApplicationScopeLimitationsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*MacApplicationScopeLimitationsUsersItems0 `json:"users"`
}

// Validate validates this mac application scope limitations
func (m *MacApplicationScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitations) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeLimitations) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeLimitations) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this mac application scope limitations based on the context it is used
func (m *MacApplicationScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitations) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeLimitations) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationScopeLimitations) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeLimitations) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeLimitationsNetworkSegmentsItems0 mac application scope limitations network segments items0
//
// swagger:model MacApplicationScopeLimitationsNetworkSegmentsItems0
type MacApplicationScopeLimitationsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

// Validate validates this mac application scope limitations network segments items0
func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope limitations network segments items0 based on the context it is used
func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeLimitationsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeLimitationsUserGroupsItems0 mac application scope limitations user groups items0
//
// swagger:model MacApplicationScopeLimitationsUserGroupsItems0
type MacApplicationScopeLimitationsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this mac application scope limitations user groups items0
func (m *MacApplicationScopeLimitationsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope limitations user groups items0 based on the context it is used
func (m *MacApplicationScopeLimitationsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeLimitationsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationScopeLimitationsUsersItems0 mac application scope limitations users items0
//
// swagger:model MacApplicationScopeLimitationsUsersItems0
type MacApplicationScopeLimitationsUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this mac application scope limitations users items0
func (m *MacApplicationScopeLimitationsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application scope limitations users items0 based on the context it is used
func (m *MacApplicationScopeLimitationsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationScopeLimitationsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationScopeLimitationsUsersItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationScopeLimitationsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationSelfService mac application self service
//
// swagger:model MacApplicationSelfService
type MacApplicationSelfService struct {

	// feature on main page
	FeatureOnMainPage bool `json:"feature_on_main_page,omitempty"`

	// force users to view description
	ForceUsersToViewDescription bool `json:"force_users_to_view_description,omitempty"`

	// install button text
	// Example: Install
	InstallButtonText string `json:"install_button_text,omitempty"`

	// notification
	Notification string `json:"notification,omitempty"`

	// notification message
	// Example: You can install TextWrangler by clicking this link or going to Self Service
	NotificationMessage string `json:"notification_message,omitempty"`

	// notification subject
	// Example: TextWrangler is Available to Install
	NotificationSubject string `json:"notification_subject,omitempty"`

	// self service categories
	SelfServiceCategories []*MacApplicationSelfServiceSelfServiceCategoriesItems0 `json:"self_service_categories"`

	// self service description
	// Example: Installs the TextWrangler application
	SelfServiceDescription string `json:"self_service_description,omitempty"`

	// self service icon
	SelfServiceIcon *MacApplicationSelfServiceSelfServiceIcon `json:"self_service_icon,omitempty"`

	// vpp
	Vpp *MacApplicationSelfServiceVpp `json:"vpp,omitempty"`
}

// Validate validates this mac application self service
func (m *MacApplicationSelfService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelfServiceCategories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfServiceIcon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVpp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationSelfService) validateSelfServiceCategories(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceCategories) { // not required
		return nil
	}

	for i := 0; i < len(m.SelfServiceCategories); i++ {
		if swag.IsZero(m.SelfServiceCategories[i]) { // not required
			continue
		}

		if m.SelfServiceCategories[i] != nil {
			if err := m.SelfServiceCategories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationSelfService) validateSelfServiceIcon(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceIcon) { // not required
		return nil
	}

	if m.SelfServiceIcon != nil {
		if err := m.SelfServiceIcon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationSelfService) validateVpp(formats strfmt.Registry) error {
	if swag.IsZero(m.Vpp) { // not required
		return nil
	}

	if m.Vpp != nil {
		if err := m.Vpp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "vpp")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "vpp")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application self service based on the context it is used
func (m *MacApplicationSelfService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelfServiceCategories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfServiceIcon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVpp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationSelfService) contextValidateSelfServiceCategories(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SelfServiceCategories); i++ {

		if m.SelfServiceCategories[i] != nil {

			if swag.IsZero(m.SelfServiceCategories[i]) { // not required
				return nil
			}

			if err := m.SelfServiceCategories[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MacApplicationSelfService) contextValidateSelfServiceIcon(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceIcon != nil {

		if swag.IsZero(m.SelfServiceIcon) { // not required
			return nil
		}

		if err := m.SelfServiceIcon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

func (m *MacApplicationSelfService) contextValidateVpp(ctx context.Context, formats strfmt.Registry) error {

	if m.Vpp != nil {

		if swag.IsZero(m.Vpp) { // not required
			return nil
		}

		if err := m.Vpp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "vpp")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "vpp")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationSelfService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationSelfService) UnmarshalBinary(b []byte) error {
	var res MacApplicationSelfService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationSelfServiceSelfServiceCategoriesItems0 mac application self service self service categories items0
//
// swagger:model MacApplicationSelfServiceSelfServiceCategoriesItems0
type MacApplicationSelfServiceSelfServiceCategoriesItems0 struct {

	// category
	Category *MacApplicationSelfServiceSelfServiceCategoriesItems0Category `json:"category,omitempty"`
}

// Validate validates this mac application self service self service categories items0
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("category")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this mac application self service self service categories items0 based on the context it is used
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("category")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0) UnmarshalBinary(b []byte) error {
	var res MacApplicationSelfServiceSelfServiceCategoriesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationSelfServiceSelfServiceCategoriesItems0Category mac application self service self service categories items0 category
//
// swagger:model MacApplicationSelfServiceSelfServiceCategoriesItems0Category
type MacApplicationSelfServiceSelfServiceCategoriesItems0Category struct {

	// display in
	// Example: true
	DisplayIn bool `json:"display_in,omitempty"`

	// feature in
	// Example: false
	FeatureIn bool `json:"feature_in,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Applications
	Name string `json:"name,omitempty"`
}

// Validate validates this mac application self service self service categories items0 category
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0Category) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application self service self service categories items0 category based on context it is used
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0Category) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0Category) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceCategoriesItems0Category) UnmarshalBinary(b []byte) error {
	var res MacApplicationSelfServiceSelfServiceCategoriesItems0Category
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationSelfServiceSelfServiceIcon mac application self service self service icon
//
// swagger:model MacApplicationSelfServiceSelfServiceIcon
type MacApplicationSelfServiceSelfServiceIcon struct {

	// data
	Data string `json:"data,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// uri
	// Example: https://company.jamfcloud.com/iconservlet/?id=1
	URI string `json:"uri,omitempty"`
}

// Validate validates this mac application self service self service icon
func (m *MacApplicationSelfServiceSelfServiceIcon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application self service self service icon based on context it is used
func (m *MacApplicationSelfServiceSelfServiceIcon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceIcon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationSelfServiceSelfServiceIcon) UnmarshalBinary(b []byte) error {
	var res MacApplicationSelfServiceSelfServiceIcon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MacApplicationSelfServiceVpp mac application self service vpp
//
// swagger:model MacApplicationSelfServiceVpp
type MacApplicationSelfServiceVpp struct {

	// assign vpp device based licenses
	AssignVppDeviceBasedLicenses *bool `json:"assign_vpp_device_based_licenses,omitempty"`

	// vpp admin account id
	VppAdminAccountID *int64 `json:"vpp_admin_account_id,omitempty"`
}

// Validate validates this mac application self service vpp
func (m *MacApplicationSelfServiceVpp) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this mac application self service vpp based on context it is used
func (m *MacApplicationSelfServiceVpp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MacApplicationSelfServiceVpp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MacApplicationSelfServiceVpp) UnmarshalBinary(b []byte) error {
	var res MacApplicationSelfServiceVpp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
