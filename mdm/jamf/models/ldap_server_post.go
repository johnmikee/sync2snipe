// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LdapServerPost ldap server post
//
// swagger:model ldap_server_post
type LdapServerPost struct {

	// connection
	Connection *LdapServerPostConnection `json:"connection,omitempty"`

	// mappings for users
	MappingsForUsers *LdapServerPostMappingsForUsers `json:"mappings_for_users,omitempty"`
}

// Validate validates this ldap server post
func (m *LdapServerPost) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConnection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMappingsForUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPost) validateConnection(formats strfmt.Registry) error {
	if swag.IsZero(m.Connection) { // not required
		return nil
	}

	if m.Connection != nil {
		if err := m.Connection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPost) validateMappingsForUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.MappingsForUsers) { // not required
		return nil
	}

	if m.MappingsForUsers != nil {
		if err := m.MappingsForUsers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ldap server post based on the context it is used
func (m *LdapServerPost) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConnection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMappingsForUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPost) contextValidateConnection(ctx context.Context, formats strfmt.Registry) error {

	if m.Connection != nil {

		if swag.IsZero(m.Connection) { // not required
			return nil
		}

		if err := m.Connection.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPost) contextValidateMappingsForUsers(ctx context.Context, formats strfmt.Registry) error {

	if m.MappingsForUsers != nil {

		if swag.IsZero(m.MappingsForUsers) { // not required
			return nil
		}

		if err := m.MappingsForUsers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPost) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPost) UnmarshalBinary(b []byte) error {
	var res LdapServerPost
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostConnection ldap server post connection
//
// swagger:model LdapServerPostConnection
type LdapServerPostConnection struct {

	// account
	Account *LdapServerPostConnectionAccount `json:"account,omitempty"`

	// authentication type
	// Enum: [simple CRAM-MD5 DIGEST-MD5 none]
	AuthenticationType string `json:"authentication_type,omitempty"`

	// Supports PEM and based64 encoded DER formats
	// Example: MIIEuzCCA6OgAwIBAgIBAjANBgkqhkiG9w0BAQUFADBiMQswCQYDVQQGEwJVUzETMBEGA1UEChMKQXBwbGUgSW5jLjEmMCQGA1UECxMdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNVBAMTDUFwcGxlIFJvb3QgQ0EwHhcNMDYwNDI1MjE0MDM2WhcNMzUwMjA5MjE0MDM2WjBiMQswCQYDVQQGEwJVUzETMBEGA1UEChMKQXBwbGUgSW5jLjEmMCQGA1UECxMdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxFjAUBgNVBAMTDUFwcGxlIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkkakJH5HbHkdQ6wXtXnmELes2oldMVeyLGYne+Uts9QerIjAC6Bg++FAJ039BqJj50cpmnCRrEdCju+QbKsMflZ56DKRHi1vUFjczy8QPTc4UadHJGXL1XQ7Vf1+b8iUDulWPTV0N8WQ1IxVLFVkds5T39pyez1C6wVhQZ48ItCD3y6wsIG9wtj8BMIy3Q88PnT3zK0koGsj+zrW5DtleHNbLPbU6rfQPDgCSC7EhFi501TwN22IWq6NxkkdTVcGvL0Gz+PvjcM3mo0xFfh9Ma1CWQYnEdGILEINBhzOKgbEwWOxaBDKMaLOPHd5lc/9nXmW8Sdh2nzMUZaF3lMktAgMBAAGjggF6MIIBdjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUK9BpR5R2Cf70a40uQKb3R01/CF4wHwYDVR0jBBgwFoAUK9BpR5R2Cf70a40uQKb3R01/CF4wggERBgNVHSAEggEIMIIBBDCCAQAGCSqGSIb3Y2QFATCB8jAqBggrBgEFBQcCARYeaHR0cHM6Ly93d3cuYXBwbGUuY29tL2FwcGxlY2EvMIHDBggrBgEFBQcCAjCBthqBs1JlbGlhbmNlIG9uIHRoaXMgY2VydGlmaWNhdGUgYnkgYW55IHBhcnR5IGFzc3VtZXMgYWNjZXB0YW5jZSBvZiB0aGUgdGhlbiBhcHBsaWNhYmxlIHN0YW5kYXJkIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHVzZSwgY2VydGlmaWNhdGUgcG9saWN5IGFuZCBjZXJ0aWZpY2F0aW9uIHByYWN0aWNlIHN0YXRlbWVudHMuMA0GCSqGSIb3DQEBBQUAA4IBAQBcNplMLXi37Yyb3PN3m/J20ncwT8EfhYOFG5k9RzfyqZtAjizUsZAS2L70c5vu0mQPy3lPNNiiPvl4/2vIB+x9OYOLUyDTOMSxv5pPCmv/K/xZpwUJfBdAVhEedNO3iyM7R6PVbyTi69G3cN8PReEnyvFteO3ntRcXqNx+IjXKJdXZD9Zr1KIkIxH3oayPc4FgxhtbCS+SsvhESPBgOJ4V9T0mZyCKM2r3DYLP3uujL/lTaltkwGMzd/c6ByxW69oPIQ7aunMZT7XZNn/Bh1XZp5m5MkL72NVxnn6hUrcbvZNCJBIqxw8dtk2cXmPIS4AXUKqK1drk/NAJBzewdXUh
	CertificateUsed string `json:"certificate_used,omitempty"`

	// connection is used for
	ConnectionIsUsedFor *string `json:"connection_is_used_for,omitempty"`

	// Hostname or IP address of the server
	// Example: company.ad.com
	Hostname string `json:"hostname,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the LDAP server
	// Example: Company Active Directory
	// Required: true
	Name *string `json:"name"`

	// Timeout in seconds
	// Example: 15
	OpenCloseTimeout int64 `json:"open_close_timeout,omitempty"`

	// port
	// Example: 389
	Port int64 `json:"port,omitempty"`

	// referral response
	// Enum: [ignore follow]
	ReferralResponse string `json:"referral_response,omitempty"`

	// Timeout in seconds
	// Example: 60
	SearchTimeout int64 `json:"search_timeout,omitempty"`

	// server type
	// Enum: [Active Directory Open Directory eDirectory Custom]
	ServerType string `json:"server_type,omitempty"`

	// use ssl
	// Example: true
	UseSsl *bool `json:"use_ssl,omitempty"`

	// use wildcards
	UseWildcards bool `json:"use_wildcards,omitempty"`
}

// Validate validates this ldap server post connection
func (m *LdapServerPostConnection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferralResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPostConnection) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connection" + "." + "account")
			}
			return err
		}
	}

	return nil
}

var ldapServerPostConnectionTypeAuthenticationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["simple","CRAM-MD5","DIGEST-MD5","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostConnectionTypeAuthenticationTypePropEnum = append(ldapServerPostConnectionTypeAuthenticationTypePropEnum, v)
	}
}

const (

	// LdapServerPostConnectionAuthenticationTypeSimple captures enum value "simple"
	LdapServerPostConnectionAuthenticationTypeSimple string = "simple"

	// LdapServerPostConnectionAuthenticationTypeCRAMDashMD5 captures enum value "CRAM-MD5"
	LdapServerPostConnectionAuthenticationTypeCRAMDashMD5 string = "CRAM-MD5"

	// LdapServerPostConnectionAuthenticationTypeDIGESTDashMD5 captures enum value "DIGEST-MD5"
	LdapServerPostConnectionAuthenticationTypeDIGESTDashMD5 string = "DIGEST-MD5"

	// LdapServerPostConnectionAuthenticationTypeNone captures enum value "none"
	LdapServerPostConnectionAuthenticationTypeNone string = "none"
)

// prop value enum
func (m *LdapServerPostConnection) validateAuthenticationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostConnectionTypeAuthenticationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostConnection) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthenticationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthenticationTypeEnum("connection"+"."+"authentication_type", "body", m.AuthenticationType); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerPostConnection) validateName(formats strfmt.Registry) error {

	if err := validate.Required("connection"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var ldapServerPostConnectionTypeReferralResponsePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ignore","follow"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostConnectionTypeReferralResponsePropEnum = append(ldapServerPostConnectionTypeReferralResponsePropEnum, v)
	}
}

const (

	// LdapServerPostConnectionReferralResponseIgnore captures enum value "ignore"
	LdapServerPostConnectionReferralResponseIgnore string = "ignore"

	// LdapServerPostConnectionReferralResponseFollow captures enum value "follow"
	LdapServerPostConnectionReferralResponseFollow string = "follow"
)

// prop value enum
func (m *LdapServerPostConnection) validateReferralResponseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostConnectionTypeReferralResponsePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostConnection) validateReferralResponse(formats strfmt.Registry) error {
	if swag.IsZero(m.ReferralResponse) { // not required
		return nil
	}

	// value enum
	if err := m.validateReferralResponseEnum("connection"+"."+"referral_response", "body", m.ReferralResponse); err != nil {
		return err
	}

	return nil
}

var ldapServerPostConnectionTypeServerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Active Directory","Open Directory","eDirectory","Custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostConnectionTypeServerTypePropEnum = append(ldapServerPostConnectionTypeServerTypePropEnum, v)
	}
}

const (

	// LdapServerPostConnectionServerTypeActiveDirectory captures enum value "Active Directory"
	LdapServerPostConnectionServerTypeActiveDirectory string = "Active Directory"

	// LdapServerPostConnectionServerTypeOpenDirectory captures enum value "Open Directory"
	LdapServerPostConnectionServerTypeOpenDirectory string = "Open Directory"

	// LdapServerPostConnectionServerTypeEDirectory captures enum value "eDirectory"
	LdapServerPostConnectionServerTypeEDirectory string = "eDirectory"

	// LdapServerPostConnectionServerTypeCustom captures enum value "Custom"
	LdapServerPostConnectionServerTypeCustom string = "Custom"
)

// prop value enum
func (m *LdapServerPostConnection) validateServerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostConnectionTypeServerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostConnection) validateServerType(formats strfmt.Registry) error {
	if swag.IsZero(m.ServerType) { // not required
		return nil
	}

	// value enum
	if err := m.validateServerTypeEnum("connection"+"."+"server_type", "body", m.ServerType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this ldap server post connection based on the context it is used
func (m *LdapServerPostConnection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPostConnection) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.Account != nil {

		if swag.IsZero(m.Account) { // not required
			return nil
		}

		if err := m.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connection" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostConnection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostConnection) UnmarshalBinary(b []byte) error {
	var res LdapServerPostConnection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostConnectionAccount ldap server post connection account
//
// swagger:model LdapServerPostConnectionAccount
type LdapServerPostConnectionAccount struct {

	// distinguished username
	// Example: CN=Administrator,CN=Users,DC=Company,DC=com
	DistinguishedUsername string `json:"distinguished_username,omitempty"`

	// password
	// Example: password
	Password string `json:"password,omitempty"`
}

// Validate validates this ldap server post connection account
func (m *LdapServerPostConnectionAccount) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this ldap server post connection account based on context it is used
func (m *LdapServerPostConnectionAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostConnectionAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostConnectionAccount) UnmarshalBinary(b []byte) error {
	var res LdapServerPostConnectionAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostMappingsForUsers ldap server post mappings for users
//
// swagger:model LdapServerPostMappingsForUsers
type LdapServerPostMappingsForUsers struct {

	// user group mappings
	UserGroupMappings *LdapServerPostMappingsForUsersUserGroupMappings `json:"user_group_mappings,omitempty"`

	// user group membership mappings
	UserGroupMembershipMappings *LdapServerPostMappingsForUsersUserGroupMembershipMappings `json:"user_group_membership_mappings,omitempty"`

	// user mappings
	UserMappings *LdapServerPostMappingsForUsersUserMappings `json:"user_mappings,omitempty"`
}

// Validate validates this ldap server post mappings for users
func (m *LdapServerPostMappingsForUsers) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroupMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroupMembershipMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserMappings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPostMappingsForUsers) validateUserGroupMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroupMappings) { // not required
		return nil
	}

	if m.UserGroupMappings != nil {
		if err := m.UserGroupMappings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_group_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_group_mappings")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPostMappingsForUsers) validateUserGroupMembershipMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroupMembershipMappings) { // not required
		return nil
	}

	if m.UserGroupMembershipMappings != nil {
		if err := m.UserGroupMembershipMappings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_group_membership_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_group_membership_mappings")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPostMappingsForUsers) validateUserMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.UserMappings) { // not required
		return nil
	}

	if m.UserMappings != nil {
		if err := m.UserMappings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_mappings")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this ldap server post mappings for users based on the context it is used
func (m *LdapServerPostMappingsForUsers) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroupMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroupMembershipMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerPostMappingsForUsers) contextValidateUserGroupMappings(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroupMappings != nil {

		if swag.IsZero(m.UserGroupMappings) { // not required
			return nil
		}

		if err := m.UserGroupMappings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_group_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_group_mappings")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPostMappingsForUsers) contextValidateUserGroupMembershipMappings(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroupMembershipMappings != nil {

		if swag.IsZero(m.UserGroupMembershipMappings) { // not required
			return nil
		}

		if err := m.UserGroupMembershipMappings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_group_membership_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_group_membership_mappings")
			}
			return err
		}
	}

	return nil
}

func (m *LdapServerPostMappingsForUsers) contextValidateUserMappings(ctx context.Context, formats strfmt.Registry) error {

	if m.UserMappings != nil {

		if swag.IsZero(m.UserMappings) { // not required
			return nil
		}

		if err := m.UserMappings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mappings_for_users" + "." + "user_mappings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mappings_for_users" + "." + "user_mappings")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsers) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsers) UnmarshalBinary(b []byte) error {
	var res LdapServerPostMappingsForUsers
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostMappingsForUsersUserGroupMappings ldap server post mappings for users user group mappings
//
// swagger:model LdapServerPostMappingsForUsersUserGroupMappings
type LdapServerPostMappingsForUsersUserGroupMappings struct {

	// map group id
	// Example: uSNCreated
	MapGroupID string `json:"map_group_id,omitempty"`

	// map group name
	// Example: name
	MapGroupName string `json:"map_group_name,omitempty"`

	// map group uuid
	// Example: objectGUID
	MapGroupUUID string `json:"map_group_uuid,omitempty"`

	// map object class to any or all
	// Enum: [all any]
	MapObjectClassToAnyOrAll string `json:"map_object_class_to_any_or_all,omitempty"`

	// object classes
	// Example: top, group
	ObjectClasses string `json:"object_classes,omitempty"`

	// search base
	// Example: DC=Company,DC=com
	SearchBase string `json:"search_base,omitempty"`

	// search scope
	// Enum: [All Subtrees First Level Only]
	SearchScope string `json:"search_scope,omitempty"`
}

// Validate validates this ldap server post mappings for users user group mappings
func (m *LdapServerPostMappingsForUsersUserGroupMappings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMapObjectClassToAnyOrAll(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ldapServerPostMappingsForUsersUserGroupMappingsTypeMapObjectClassToAnyOrAllPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserGroupMappingsTypeMapObjectClassToAnyOrAllPropEnum = append(ldapServerPostMappingsForUsersUserGroupMappingsTypeMapObjectClassToAnyOrAllPropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserGroupMappingsMapObjectClassToAnyOrAllAll captures enum value "all"
	LdapServerPostMappingsForUsersUserGroupMappingsMapObjectClassToAnyOrAllAll string = "all"

	// LdapServerPostMappingsForUsersUserGroupMappingsMapObjectClassToAnyOrAllAny captures enum value "any"
	LdapServerPostMappingsForUsersUserGroupMappingsMapObjectClassToAnyOrAllAny string = "any"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserGroupMappings) validateMapObjectClassToAnyOrAllEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserGroupMappingsTypeMapObjectClassToAnyOrAllPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserGroupMappings) validateMapObjectClassToAnyOrAll(formats strfmt.Registry) error {
	if swag.IsZero(m.MapObjectClassToAnyOrAll) { // not required
		return nil
	}

	// value enum
	if err := m.validateMapObjectClassToAnyOrAllEnum("mappings_for_users"+"."+"user_group_mappings"+"."+"map_object_class_to_any_or_all", "body", m.MapObjectClassToAnyOrAll); err != nil {
		return err
	}

	return nil
}

var ldapServerPostMappingsForUsersUserGroupMappingsTypeSearchScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All Subtrees","First Level Only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserGroupMappingsTypeSearchScopePropEnum = append(ldapServerPostMappingsForUsersUserGroupMappingsTypeSearchScopePropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserGroupMappingsSearchScopeAllSubtrees captures enum value "All Subtrees"
	LdapServerPostMappingsForUsersUserGroupMappingsSearchScopeAllSubtrees string = "All Subtrees"

	// LdapServerPostMappingsForUsersUserGroupMappingsSearchScopeFirstLevelOnly captures enum value "First Level Only"
	LdapServerPostMappingsForUsersUserGroupMappingsSearchScopeFirstLevelOnly string = "First Level Only"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserGroupMappings) validateSearchScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserGroupMappingsTypeSearchScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserGroupMappings) validateSearchScope(formats strfmt.Registry) error {
	if swag.IsZero(m.SearchScope) { // not required
		return nil
	}

	// value enum
	if err := m.validateSearchScopeEnum("mappings_for_users"+"."+"user_group_mappings"+"."+"search_scope", "body", m.SearchScope); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this ldap server post mappings for users user group mappings based on context it is used
func (m *LdapServerPostMappingsForUsersUserGroupMappings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserGroupMappings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserGroupMappings) UnmarshalBinary(b []byte) error {
	var res LdapServerPostMappingsForUsersUserGroupMappings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostMappingsForUsersUserGroupMembershipMappings ldap server post mappings for users user group membership mappings
//
// swagger:model LdapServerPostMappingsForUsersUserGroupMembershipMappings
type LdapServerPostMappingsForUsersUserGroupMembershipMappings struct {

	// append to username
	// Example: company.com
	AppendToUsername string `json:"append_to_username,omitempty"`

	// group id
	// Example: uSNCreated
	GroupID string `json:"group_id,omitempty"`

	// map group membership to user field
	// Example: memberOf
	MapGroupMembershipToUserField string `json:"map_group_membership_to_user_field,omitempty"`

	// map object class to any or all
	// Enum: [all any]
	MapObjectClassToAnyOrAll string `json:"map_object_class_to_any_or_all,omitempty"`

	// map user membership to group field
	MapUserMembershipToGroupField bool `json:"map_user_membership_to_group_field,omitempty"`

	// map user membership use dn
	MapUserMembershipUseDn bool `json:"map_user_membership_use_dn,omitempty"`

	// object classes
	// Example: group
	ObjectClasses string `json:"object_classes,omitempty"`

	// recursive lookups
	RecursiveLookups bool `json:"recursive_lookups,omitempty"`

	// search base
	// Example: DC=Company,DC=com
	SearchBase string `json:"search_base,omitempty"`

	// search scope
	// Enum: [All Subtrees First Level Only]
	SearchScope string `json:"search_scope,omitempty"`

	// use dn
	UseDn bool `json:"use_dn,omitempty"`

	// user group membership stored in
	// Enum: [user object group object]
	UserGroupMembershipStoredIn string `json:"user_group_membership_stored_in,omitempty"`

	// user group membership use ldap compare
	UserGroupMembershipUseLdapCompare bool `json:"user_group_membership_use_ldap_compare,omitempty"`

	// username
	// Example: sAMAccountName
	Username string `json:"username,omitempty"`
}

// Validate validates this ldap server post mappings for users user group membership mappings
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMapObjectClassToAnyOrAll(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroupMembershipStoredIn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeMapObjectClassToAnyOrAllPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeMapObjectClassToAnyOrAllPropEnum = append(ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeMapObjectClassToAnyOrAllPropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsMapObjectClassToAnyOrAllAll captures enum value "all"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsMapObjectClassToAnyOrAllAll string = "all"

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsMapObjectClassToAnyOrAllAny captures enum value "any"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsMapObjectClassToAnyOrAllAny string = "any"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateMapObjectClassToAnyOrAllEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeMapObjectClassToAnyOrAllPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateMapObjectClassToAnyOrAll(formats strfmt.Registry) error {
	if swag.IsZero(m.MapObjectClassToAnyOrAll) { // not required
		return nil
	}

	// value enum
	if err := m.validateMapObjectClassToAnyOrAllEnum("mappings_for_users"+"."+"user_group_membership_mappings"+"."+"map_object_class_to_any_or_all", "body", m.MapObjectClassToAnyOrAll); err != nil {
		return err
	}

	return nil
}

var ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeSearchScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All Subtrees","First Level Only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeSearchScopePropEnum = append(ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeSearchScopePropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsSearchScopeAllSubtrees captures enum value "All Subtrees"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsSearchScopeAllSubtrees string = "All Subtrees"

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsSearchScopeFirstLevelOnly captures enum value "First Level Only"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsSearchScopeFirstLevelOnly string = "First Level Only"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateSearchScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeSearchScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateSearchScope(formats strfmt.Registry) error {
	if swag.IsZero(m.SearchScope) { // not required
		return nil
	}

	// value enum
	if err := m.validateSearchScopeEnum("mappings_for_users"+"."+"user_group_membership_mappings"+"."+"search_scope", "body", m.SearchScope); err != nil {
		return err
	}

	return nil
}

var ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeUserGroupMembershipStoredInPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["user object","group object"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeUserGroupMembershipStoredInPropEnum = append(ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeUserGroupMembershipStoredInPropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsUserGroupMembershipStoredInUserObject captures enum value "user object"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsUserGroupMembershipStoredInUserObject string = "user object"

	// LdapServerPostMappingsForUsersUserGroupMembershipMappingsUserGroupMembershipStoredInGroupObject captures enum value "group object"
	LdapServerPostMappingsForUsersUserGroupMembershipMappingsUserGroupMembershipStoredInGroupObject string = "group object"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateUserGroupMembershipStoredInEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserGroupMembershipMappingsTypeUserGroupMembershipStoredInPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) validateUserGroupMembershipStoredIn(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroupMembershipStoredIn) { // not required
		return nil
	}

	// value enum
	if err := m.validateUserGroupMembershipStoredInEnum("mappings_for_users"+"."+"user_group_membership_mappings"+"."+"user_group_membership_stored_in", "body", m.UserGroupMembershipStoredIn); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this ldap server post mappings for users user group membership mappings based on context it is used
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserGroupMembershipMappings) UnmarshalBinary(b []byte) error {
	var res LdapServerPostMappingsForUsersUserGroupMembershipMappings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LdapServerPostMappingsForUsersUserMappings ldap server post mappings for users user mappings
//
// swagger:model LdapServerPostMappingsForUsersUserMappings
type LdapServerPostMappingsForUsersUserMappings struct {

	// append to email results
	// Example: company.com
	AppendToEmailResults string `json:"append_to_email_results,omitempty"`

	// map building
	// Example: streetAddress
	MapBuilding string `json:"map_building,omitempty"`

	// map department
	// Example: department
	MapDepartment string `json:"map_department,omitempty"`

	// map email address
	// Example: mail
	MapEmailAddress string `json:"map_email_address,omitempty"`

	// map object class to any or all
	// Enum: [all any]
	MapObjectClassToAnyOrAll string `json:"map_object_class_to_any_or_all,omitempty"`

	// map position
	// Example: title
	MapPosition string `json:"map_position,omitempty"`

	// map realname
	// Example: displayName
	MapRealname string `json:"map_realname,omitempty"`

	// map room
	// Example: room
	MapRoom string `json:"map_room,omitempty"`

	// map telephone
	// Example: telephoneNumber
	MapTelephone string `json:"map_telephone,omitempty"`

	// map user id
	// Example: uSNCreated
	MapUserID string `json:"map_user_id,omitempty"`

	// map user uuid
	// Example: objectGUID
	MapUserUUID string `json:"map_user_uuid,omitempty"`

	// map username
	// Example: sAMAccountName
	MapUsername string `json:"map_username,omitempty"`

	// object classes
	// Example: organizationalPerson, user
	ObjectClasses string `json:"object_classes,omitempty"`

	// search base
	// Example: DC=Company,DC=com
	SearchBase string `json:"search_base,omitempty"`

	// search scope
	// Enum: [All Subtrees First Level Only]
	SearchScope string `json:"search_scope,omitempty"`
}

// Validate validates this ldap server post mappings for users user mappings
func (m *LdapServerPostMappingsForUsersUserMappings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMapObjectClassToAnyOrAll(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ldapServerPostMappingsForUsersUserMappingsTypeMapObjectClassToAnyOrAllPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","any"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserMappingsTypeMapObjectClassToAnyOrAllPropEnum = append(ldapServerPostMappingsForUsersUserMappingsTypeMapObjectClassToAnyOrAllPropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserMappingsMapObjectClassToAnyOrAllAll captures enum value "all"
	LdapServerPostMappingsForUsersUserMappingsMapObjectClassToAnyOrAllAll string = "all"

	// LdapServerPostMappingsForUsersUserMappingsMapObjectClassToAnyOrAllAny captures enum value "any"
	LdapServerPostMappingsForUsersUserMappingsMapObjectClassToAnyOrAllAny string = "any"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserMappings) validateMapObjectClassToAnyOrAllEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserMappingsTypeMapObjectClassToAnyOrAllPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserMappings) validateMapObjectClassToAnyOrAll(formats strfmt.Registry) error {
	if swag.IsZero(m.MapObjectClassToAnyOrAll) { // not required
		return nil
	}

	// value enum
	if err := m.validateMapObjectClassToAnyOrAllEnum("mappings_for_users"+"."+"user_mappings"+"."+"map_object_class_to_any_or_all", "body", m.MapObjectClassToAnyOrAll); err != nil {
		return err
	}

	return nil
}

var ldapServerPostMappingsForUsersUserMappingsTypeSearchScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["All Subtrees","First Level Only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerPostMappingsForUsersUserMappingsTypeSearchScopePropEnum = append(ldapServerPostMappingsForUsersUserMappingsTypeSearchScopePropEnum, v)
	}
}

const (

	// LdapServerPostMappingsForUsersUserMappingsSearchScopeAllSubtrees captures enum value "All Subtrees"
	LdapServerPostMappingsForUsersUserMappingsSearchScopeAllSubtrees string = "All Subtrees"

	// LdapServerPostMappingsForUsersUserMappingsSearchScopeFirstLevelOnly captures enum value "First Level Only"
	LdapServerPostMappingsForUsersUserMappingsSearchScopeFirstLevelOnly string = "First Level Only"
)

// prop value enum
func (m *LdapServerPostMappingsForUsersUserMappings) validateSearchScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ldapServerPostMappingsForUsersUserMappingsTypeSearchScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerPostMappingsForUsersUserMappings) validateSearchScope(formats strfmt.Registry) error {
	if swag.IsZero(m.SearchScope) { // not required
		return nil
	}

	// value enum
	if err := m.validateSearchScopeEnum("mappings_for_users"+"."+"user_mappings"+"."+"search_scope", "body", m.SearchScope); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this ldap server post mappings for users user mappings based on context it is used
func (m *LdapServerPostMappingsForUsersUserMappings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserMappings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerPostMappingsForUsersUserMappings) UnmarshalBinary(b []byte) error {
	var res LdapServerPostMappingsForUsersUserMappings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
