// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchPolicy patch policy
//
// swagger:model patch_policy
type PatchPolicy struct {

	// general
	General *PatchPolicyGeneral `json:"general,omitempty"`

	// scope
	Scope *PatchPolicyScope `json:"scope,omitempty"`

	// software title configuration id
	// Example: 1
	SoftwareTitleConfigurationID int64 `json:"software_title_configuration_id,omitempty"`

	// user interaction
	UserInteraction *PatchPolicyUserInteraction `json:"user_interaction,omitempty"`
}

// Validate validates this patch policy
func (m *PatchPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserInteraction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicy) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicy) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicy) validateUserInteraction(formats strfmt.Registry) error {
	if swag.IsZero(m.UserInteraction) { // not required
		return nil
	}

	if m.UserInteraction != nil {
		if err := m.UserInteraction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy based on the context it is used
func (m *PatchPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserInteraction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicy) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicy) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicy) contextValidateUserInteraction(ctx context.Context, formats strfmt.Registry) error {

	if m.UserInteraction != nil {

		if swag.IsZero(m.UserInteraction) { // not required
			return nil
		}

		if err := m.UserInteraction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicy) UnmarshalBinary(b []byte) error {
	var res PatchPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyGeneral patch policy general
//
// swagger:model PatchPolicyGeneral
type PatchPolicyGeneral struct {

	// allow downgrade
	AllowDowngrade bool `json:"allow_downgrade,omitempty"`

	// distribution method
	// Enum: [selfservice prompt]
	DistributionMethod string `json:"distribution_method,omitempty"`

	// enabled
	// Example: true
	Enabled bool `json:"enabled,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// incremental updates
	// Example: false
	IncrementalUpdates bool `json:"incremental_updates,omitempty"`

	// kill apps
	KillApps []*PatchPolicyGeneralKillAppsItems0 `json:"kill_apps"`

	// minimum os
	// Example: 10.9
	MinimumOs string `json:"minimum_os,omitempty"`

	// name
	// Example: Google Chrome - 62.0.3202.75
	// Required: true
	Name *string `json:"name"`

	// Set to true to patch versions unidentified by Jamf Pro patch reporting
	PatchUnknown bool `json:"patch_unknown,omitempty"`

	// reboot
	Reboot bool `json:"reboot,omitempty"`

	// release date
	// Example: 1509048027663
	ReleaseDate int64 `json:"release_date,omitempty"`

	// target version
	// Example: 62.0.3202.75
	// Required: true
	TargetVersion *string `json:"target_version"`
}

// Validate validates this patch policy general
func (m *PatchPolicyGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDistributionMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKillApps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var patchPolicyGeneralTypeDistributionMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["selfservice","prompt"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchPolicyGeneralTypeDistributionMethodPropEnum = append(patchPolicyGeneralTypeDistributionMethodPropEnum, v)
	}
}

const (

	// PatchPolicyGeneralDistributionMethodSelfservice captures enum value "selfservice"
	PatchPolicyGeneralDistributionMethodSelfservice string = "selfservice"

	// PatchPolicyGeneralDistributionMethodPrompt captures enum value "prompt"
	PatchPolicyGeneralDistributionMethodPrompt string = "prompt"
)

// prop value enum
func (m *PatchPolicyGeneral) validateDistributionMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchPolicyGeneralTypeDistributionMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PatchPolicyGeneral) validateDistributionMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionMethodEnum("general"+"."+"distribution_method", "body", m.DistributionMethod); err != nil {
		return err
	}

	return nil
}

func (m *PatchPolicyGeneral) validateKillApps(formats strfmt.Registry) error {
	if swag.IsZero(m.KillApps) { // not required
		return nil
	}

	for i := 0; i < len(m.KillApps); i++ {
		if swag.IsZero(m.KillApps[i]) { // not required
			continue
		}

		if m.KillApps[i] != nil {
			if err := m.KillApps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("general" + "." + "kill_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("general" + "." + "kill_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *PatchPolicyGeneral) validateTargetVersion(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"target_version", "body", m.TargetVersion); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch policy general based on the context it is used
func (m *PatchPolicyGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateKillApps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyGeneral) contextValidateKillApps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.KillApps); i++ {

		if m.KillApps[i] != nil {

			if swag.IsZero(m.KillApps[i]) { // not required
				return nil
			}

			if err := m.KillApps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("general" + "." + "kill_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("general" + "." + "kill_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyGeneral) UnmarshalBinary(b []byte) error {
	var res PatchPolicyGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyGeneralKillAppsItems0 patch policy general kill apps items0
//
// swagger:model PatchPolicyGeneralKillAppsItems0
type PatchPolicyGeneralKillAppsItems0 struct {

	// kill app
	KillApp *PatchPolicyGeneralKillAppsItems0KillApp `json:"kill_app,omitempty"`
}

// Validate validates this patch policy general kill apps items0
func (m *PatchPolicyGeneralKillAppsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKillApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyGeneralKillAppsItems0) validateKillApp(formats strfmt.Registry) error {
	if swag.IsZero(m.KillApp) { // not required
		return nil
	}

	if m.KillApp != nil {
		if err := m.KillApp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kill_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kill_app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy general kill apps items0 based on the context it is used
func (m *PatchPolicyGeneralKillAppsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateKillApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyGeneralKillAppsItems0) contextValidateKillApp(ctx context.Context, formats strfmt.Registry) error {

	if m.KillApp != nil {

		if swag.IsZero(m.KillApp) { // not required
			return nil
		}

		if err := m.KillApp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kill_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kill_app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyGeneralKillAppsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyGeneralKillAppsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyGeneralKillAppsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyGeneralKillAppsItems0KillApp patch policy general kill apps items0 kill app
//
// swagger:model PatchPolicyGeneralKillAppsItems0KillApp
type PatchPolicyGeneralKillAppsItems0KillApp struct {

	// kill app bundle id
	// Example: com.google.Chrome
	KillAppBundleID string `json:"kill_app_bundle_id,omitempty"`

	// kill app name
	// Example: Google Chrome.app
	KillAppName string `json:"kill_app_name,omitempty"`
}

// Validate validates this patch policy general kill apps items0 kill app
func (m *PatchPolicyGeneralKillAppsItems0KillApp) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy general kill apps items0 kill app based on context it is used
func (m *PatchPolicyGeneralKillAppsItems0KillApp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyGeneralKillAppsItems0KillApp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyGeneralKillAppsItems0KillApp) UnmarshalBinary(b []byte) error {
	var res PatchPolicyGeneralKillAppsItems0KillApp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScope patch policy scope
//
// swagger:model PatchPolicyScope
type PatchPolicyScope struct {

	// all computers
	AllComputers bool `json:"all_computers,omitempty"`

	// buildings
	Buildings []*PatchPolicyScopeBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*PatchPolicyScopeComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*PatchPolicyScopeComputersItems0 `json:"computers"`

	// departments
	Departments []*PatchPolicyScopeDepartmentsItems0 `json:"departments"`

	// exclusions
	Exclusions *PatchPolicyScopeExclusions `json:"exclusions,omitempty"`

	// limitations
	Limitations *PatchPolicyScopeLimitations `json:"limitations,omitempty"`
}

// Validate validates this patch policy scope
func (m *PatchPolicyScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScope) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope based on the context it is used
func (m *PatchPolicyScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScope) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScope) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeBuildingsItems0 patch policy scope buildings items0
//
// swagger:model PatchPolicyScopeBuildingsItems0
type PatchPolicyScopeBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this patch policy scope buildings items0
func (m *PatchPolicyScopeBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope buildings items0 based on the context it is used
func (m *PatchPolicyScopeBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeComputerGroupsItems0 patch policy scope computer groups items0
//
// swagger:model PatchPolicyScopeComputerGroupsItems0
type PatchPolicyScopeComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this patch policy scope computer groups items0
func (m *PatchPolicyScopeComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope computer groups items0 based on the context it is used
func (m *PatchPolicyScopeComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeComputersItems0 patch policy scope computers items0
//
// swagger:model PatchPolicyScopeComputersItems0
type PatchPolicyScopeComputersItems0 struct {

	// computer
	Computer *PatchPolicyScopeComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this patch policy scope computers items0
func (m *PatchPolicyScopeComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope computers items0 based on the context it is used
func (m *PatchPolicyScopeComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeComputersItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeComputersItems0Computer patch policy scope computers items0 computer
//
// swagger:model PatchPolicyScopeComputersItems0Computer
type PatchPolicyScopeComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Joe's MacBook Pro
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this patch policy scope computers items0 computer
func (m *PatchPolicyScopeComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy scope computers items0 computer based on context it is used
func (m *PatchPolicyScopeComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeDepartmentsItems0 patch policy scope departments items0
//
// swagger:model PatchPolicyScopeDepartmentsItems0
type PatchPolicyScopeDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this patch policy scope departments items0
func (m *PatchPolicyScopeDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope departments items0 based on the context it is used
func (m *PatchPolicyScopeDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusions patch policy scope exclusions
//
// swagger:model PatchPolicyScopeExclusions
type PatchPolicyScopeExclusions struct {

	// buildings
	Buildings []*PatchPolicyScopeExclusionsBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*PatchPolicyScopeExclusionsComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*PatchPolicyScopeExclusionsComputersItems0 `json:"computers"`

	// departments
	Departments []*PatchPolicyScopeExclusionsDepartmentsItems0 `json:"departments"`

	// ibeacons
	Ibeacons []*PatchPolicyScopeExclusionsIbeaconsItems0 `json:"ibeacons"`

	// network segments
	NetworkSegments []*PatchPolicyScopeExclusionsNetworkSegmentsItems0 `json:"network_segments"`
}

// Validate validates this patch policy scope exclusions
func (m *PatchPolicyScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbeacons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusions) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) validateIbeacons(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacons) { // not required
		return nil
	}

	for i := 0; i < len(m.Ibeacons); i++ {
		if swag.IsZero(m.Ibeacons[i]) { // not required
			continue
		}

		if m.Ibeacons[i] != nil {
			if err := m.Ibeacons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions based on the context it is used
func (m *PatchPolicyScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIbeacons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateIbeacons(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ibeacons); i++ {

		if m.Ibeacons[i] != nil {

			if swag.IsZero(m.Ibeacons[i]) { // not required
				return nil
			}

			if err := m.Ibeacons[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeExclusions) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusions) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsBuildingsItems0 patch policy scope exclusions buildings items0
//
// swagger:model PatchPolicyScopeExclusionsBuildingsItems0
type PatchPolicyScopeExclusionsBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this patch policy scope exclusions buildings items0
func (m *PatchPolicyScopeExclusionsBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions buildings items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsComputerGroupsItems0 patch policy scope exclusions computer groups items0
//
// swagger:model PatchPolicyScopeExclusionsComputerGroupsItems0
type PatchPolicyScopeExclusionsComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this patch policy scope exclusions computer groups items0
func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions computer groups items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsComputersItems0 patch policy scope exclusions computers items0
//
// swagger:model PatchPolicyScopeExclusionsComputersItems0
type PatchPolicyScopeExclusionsComputersItems0 struct {

	// computer
	Computer *PatchPolicyScopeExclusionsComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this patch policy scope exclusions computers items0
func (m *PatchPolicyScopeExclusionsComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions computers items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputersItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsComputersItems0Computer patch policy scope exclusions computers items0 computer
//
// swagger:model PatchPolicyScopeExclusionsComputersItems0Computer
type PatchPolicyScopeExclusionsComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Joe's MacBook Pro
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this patch policy scope exclusions computers items0 computer
func (m *PatchPolicyScopeExclusionsComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy scope exclusions computers items0 computer based on context it is used
func (m *PatchPolicyScopeExclusionsComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsDepartmentsItems0 patch policy scope exclusions departments items0
//
// swagger:model PatchPolicyScopeExclusionsDepartmentsItems0
type PatchPolicyScopeExclusionsDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this patch policy scope exclusions departments items0
func (m *PatchPolicyScopeExclusionsDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions departments items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsIbeaconsItems0 patch policy scope exclusions ibeacons items0
//
// swagger:model PatchPolicyScopeExclusionsIbeaconsItems0
type PatchPolicyScopeExclusionsIbeaconsItems0 struct {

	// ibeacon
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

// Validate validates this patch policy scope exclusions ibeacons items0
func (m *PatchPolicyScopeExclusionsIbeaconsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsIbeaconsItems0) validateIbeacon(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacon) { // not required
		return nil
	}

	if m.Ibeacon != nil {
		if err := m.Ibeacon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions ibeacons items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsIbeaconsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsIbeaconsItems0) contextValidateIbeacon(ctx context.Context, formats strfmt.Registry) error {

	if m.Ibeacon != nil {

		if swag.IsZero(m.Ibeacon) { // not required
			return nil
		}

		if err := m.Ibeacon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsIbeaconsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsIbeaconsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsIbeaconsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeExclusionsNetworkSegmentsItems0 patch policy scope exclusions network segments items0
//
// swagger:model PatchPolicyScopeExclusionsNetworkSegmentsItems0
type PatchPolicyScopeExclusionsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

// Validate validates this patch policy scope exclusions network segments items0
func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope exclusions network segments items0 based on the context it is used
func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeExclusionsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeExclusionsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeLimitations patch policy scope limitations
//
// swagger:model PatchPolicyScopeLimitations
type PatchPolicyScopeLimitations struct {

	// ibeacons
	Ibeacons []*PatchPolicyScopeLimitationsIbeaconsItems0 `json:"ibeacons"`

	// network segments
	NetworkSegments []*PatchPolicyScopeLimitationsNetworkSegmentsItems0 `json:"network_segments"`
}

// Validate validates this patch policy scope limitations
func (m *PatchPolicyScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitations) validateIbeacons(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacons) { // not required
		return nil
	}

	for i := 0; i < len(m.Ibeacons); i++ {
		if swag.IsZero(m.Ibeacons[i]) { // not required
			continue
		}

		if m.Ibeacons[i] != nil {
			if err := m.Ibeacons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeLimitations) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch policy scope limitations based on the context it is used
func (m *PatchPolicyScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitations) contextValidateIbeacons(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ibeacons); i++ {

		if m.Ibeacons[i] != nil {

			if swag.IsZero(m.Ibeacons[i]) { // not required
				return nil
			}

			if err := m.Ibeacons[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchPolicyScopeLimitations) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeLimitations) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeLimitationsIbeaconsItems0 patch policy scope limitations ibeacons items0
//
// swagger:model PatchPolicyScopeLimitationsIbeaconsItems0
type PatchPolicyScopeLimitationsIbeaconsItems0 struct {

	// ibeacon
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

// Validate validates this patch policy scope limitations ibeacons items0
func (m *PatchPolicyScopeLimitationsIbeaconsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitationsIbeaconsItems0) validateIbeacon(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacon) { // not required
		return nil
	}

	if m.Ibeacon != nil {
		if err := m.Ibeacon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope limitations ibeacons items0 based on the context it is used
func (m *PatchPolicyScopeLimitationsIbeaconsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitationsIbeaconsItems0) contextValidateIbeacon(ctx context.Context, formats strfmt.Registry) error {

	if m.Ibeacon != nil {

		if swag.IsZero(m.Ibeacon) { // not required
			return nil
		}

		if err := m.Ibeacon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeLimitationsIbeaconsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeLimitationsIbeaconsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeLimitationsIbeaconsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyScopeLimitationsNetworkSegmentsItems0 patch policy scope limitations network segments items0
//
// swagger:model PatchPolicyScopeLimitationsNetworkSegmentsItems0
type PatchPolicyScopeLimitationsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

// Validate validates this patch policy scope limitations network segments items0
func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy scope limitations network segments items0 based on the context it is used
func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyScopeLimitationsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res PatchPolicyScopeLimitationsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteraction patch policy user interaction
//
// swagger:model PatchPolicyUserInteraction
type PatchPolicyUserInteraction struct {

	// deadlines
	Deadlines *PatchPolicyUserInteractionDeadlines `json:"deadlines,omitempty"`

	// grace period
	GracePeriod *PatchPolicyUserInteractionGracePeriod `json:"grace_period,omitempty"`

	// install button text
	// Example: Update
	InstallButtonText string `json:"install_button_text,omitempty"`

	// notifications
	Notifications *PatchPolicyUserInteractionNotifications `json:"notifications,omitempty"`

	// self service description
	// Example: Latest update for Google Chrome
	SelfServiceDescription string `json:"self_service_description,omitempty"`

	// self service icon
	SelfServiceIcon *PatchPolicyUserInteractionSelfServiceIcon `json:"self_service_icon,omitempty"`
}

// Validate validates this patch policy user interaction
func (m *PatchPolicyUserInteraction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDeadlines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGracePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfServiceIcon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyUserInteraction) validateDeadlines(formats strfmt.Registry) error {
	if swag.IsZero(m.Deadlines) { // not required
		return nil
	}

	if m.Deadlines != nil {
		if err := m.Deadlines.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "deadlines")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "deadlines")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) validateGracePeriod(formats strfmt.Registry) error {
	if swag.IsZero(m.GracePeriod) { // not required
		return nil
	}

	if m.GracePeriod != nil {
		if err := m.GracePeriod.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "grace_period")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "grace_period")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) validateNotifications(formats strfmt.Registry) error {
	if swag.IsZero(m.Notifications) { // not required
		return nil
	}

	if m.Notifications != nil {
		if err := m.Notifications.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "notifications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "notifications")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) validateSelfServiceIcon(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceIcon) { // not required
		return nil
	}

	if m.SelfServiceIcon != nil {
		if err := m.SelfServiceIcon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy user interaction based on the context it is used
func (m *PatchPolicyUserInteraction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDeadlines(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGracePeriod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotifications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfServiceIcon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyUserInteraction) contextValidateDeadlines(ctx context.Context, formats strfmt.Registry) error {

	if m.Deadlines != nil {

		if swag.IsZero(m.Deadlines) { // not required
			return nil
		}

		if err := m.Deadlines.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "deadlines")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "deadlines")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) contextValidateGracePeriod(ctx context.Context, formats strfmt.Registry) error {

	if m.GracePeriod != nil {

		if swag.IsZero(m.GracePeriod) { // not required
			return nil
		}

		if err := m.GracePeriod.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "grace_period")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "grace_period")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) contextValidateNotifications(ctx context.Context, formats strfmt.Registry) error {

	if m.Notifications != nil {

		if swag.IsZero(m.Notifications) { // not required
			return nil
		}

		if err := m.Notifications.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "notifications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "notifications")
			}
			return err
		}
	}

	return nil
}

func (m *PatchPolicyUserInteraction) contextValidateSelfServiceIcon(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceIcon != nil {

		if swag.IsZero(m.SelfServiceIcon) { // not required
			return nil
		}

		if err := m.SelfServiceIcon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteraction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteraction) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteraction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteractionDeadlines patch policy user interaction deadlines
//
// swagger:model PatchPolicyUserInteractionDeadlines
type PatchPolicyUserInteractionDeadlines struct {

	// deadline enabled
	// Example: true
	DeadlineEnabled bool `json:"deadline_enabled,omitempty"`

	// deadline period
	// Example: 7
	DeadlinePeriod int64 `json:"deadline_period,omitempty"`
}

// Validate validates this patch policy user interaction deadlines
func (m *PatchPolicyUserInteractionDeadlines) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy user interaction deadlines based on context it is used
func (m *PatchPolicyUserInteractionDeadlines) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteractionDeadlines) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteractionDeadlines) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteractionDeadlines
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteractionGracePeriod patch policy user interaction grace period
//
// swagger:model PatchPolicyUserInteractionGracePeriod
type PatchPolicyUserInteractionGracePeriod struct {

	// Number of minutes to wait before automatically closing all apps required to be closed for an update
	// Example: 15
	GracePeriodDuration int64 `json:"grace_period_duration,omitempty"`

	// message
	// Example: $APP_NAMES will quit in $DELAY_MINUTES minutes so that $SOFTWARE_TITLE can be updated. Save anything you are working on and quit the app(s)
	Message string `json:"message,omitempty"`

	// notification center subject
	// Example: Important
	NotificationCenterSubject string `json:"notification_center_subject,omitempty"`
}

// Validate validates this patch policy user interaction grace period
func (m *PatchPolicyUserInteractionGracePeriod) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy user interaction grace period based on context it is used
func (m *PatchPolicyUserInteractionGracePeriod) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteractionGracePeriod) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteractionGracePeriod) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteractionGracePeriod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteractionNotifications patch policy user interaction notifications
//
// swagger:model PatchPolicyUserInteractionNotifications
type PatchPolicyUserInteractionNotifications struct {

	// notification enabled
	// Example: true
	NotificationEnabled bool `json:"notification_enabled,omitempty"`

	// notification message
	// Example: An update for Google Chrome is available within Self Service
	NotificationMessage string `json:"notification_message,omitempty"`

	// notification subject
	// Example: Google Chrome Update Available
	NotificationSubject string `json:"notification_subject,omitempty"`

	// notification type
	// Enum: [Self Service Self Service and Notification Center]
	NotificationType string `json:"notification_type,omitempty"`

	// reminders
	Reminders *PatchPolicyUserInteractionNotificationsReminders `json:"reminders,omitempty"`
}

// Validate validates this patch policy user interaction notifications
func (m *PatchPolicyUserInteractionNotifications) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNotificationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReminders(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var patchPolicyUserInteractionNotificationsTypeNotificationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Self Service","Self Service and Notification Center"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchPolicyUserInteractionNotificationsTypeNotificationTypePropEnum = append(patchPolicyUserInteractionNotificationsTypeNotificationTypePropEnum, v)
	}
}

const (

	// PatchPolicyUserInteractionNotificationsNotificationTypeSelfService captures enum value "Self Service"
	PatchPolicyUserInteractionNotificationsNotificationTypeSelfService string = "Self Service"

	// PatchPolicyUserInteractionNotificationsNotificationTypeSelfServiceAndNotificationCenter captures enum value "Self Service and Notification Center"
	PatchPolicyUserInteractionNotificationsNotificationTypeSelfServiceAndNotificationCenter string = "Self Service and Notification Center"
)

// prop value enum
func (m *PatchPolicyUserInteractionNotifications) validateNotificationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, patchPolicyUserInteractionNotificationsTypeNotificationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PatchPolicyUserInteractionNotifications) validateNotificationType(formats strfmt.Registry) error {
	if swag.IsZero(m.NotificationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateNotificationTypeEnum("user_interaction"+"."+"notifications"+"."+"notification_type", "body", m.NotificationType); err != nil {
		return err
	}

	return nil
}

func (m *PatchPolicyUserInteractionNotifications) validateReminders(formats strfmt.Registry) error {
	if swag.IsZero(m.Reminders) { // not required
		return nil
	}

	if m.Reminders != nil {
		if err := m.Reminders.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "notifications" + "." + "reminders")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "notifications" + "." + "reminders")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch policy user interaction notifications based on the context it is used
func (m *PatchPolicyUserInteractionNotifications) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReminders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchPolicyUserInteractionNotifications) contextValidateReminders(ctx context.Context, formats strfmt.Registry) error {

	if m.Reminders != nil {

		if swag.IsZero(m.Reminders) { // not required
			return nil
		}

		if err := m.Reminders.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction" + "." + "notifications" + "." + "reminders")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction" + "." + "notifications" + "." + "reminders")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteractionNotifications) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteractionNotifications) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteractionNotifications
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteractionNotificationsReminders patch policy user interaction notifications reminders
//
// swagger:model PatchPolicyUserInteractionNotificationsReminders
type PatchPolicyUserInteractionNotificationsReminders struct {

	// notification reminder frequency
	// Example: 1
	NotificationReminderFrequency int64 `json:"notification_reminder_frequency,omitempty"`

	// notification reminders enabled
	// Example: true
	NotificationRemindersEnabled bool `json:"notification_reminders_enabled,omitempty"`
}

// Validate validates this patch policy user interaction notifications reminders
func (m *PatchPolicyUserInteractionNotificationsReminders) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy user interaction notifications reminders based on context it is used
func (m *PatchPolicyUserInteractionNotificationsReminders) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteractionNotificationsReminders) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteractionNotificationsReminders) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteractionNotificationsReminders
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PatchPolicyUserInteractionSelfServiceIcon patch policy user interaction self service icon
//
// swagger:model PatchPolicyUserInteractionSelfServiceIcon
type PatchPolicyUserInteractionSelfServiceIcon struct {

	// filename
	// Example: Chrome.png
	Filename string `json:"filename,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// uri
	// Example: https://jssURL.jamfcloud.com/iconservlet/?id=1
	URI string `json:"uri,omitempty"`
}

// Validate validates this patch policy user interaction self service icon
func (m *PatchPolicyUserInteractionSelfServiceIcon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch policy user interaction self service icon based on context it is used
func (m *PatchPolicyUserInteractionSelfServiceIcon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PatchPolicyUserInteractionSelfServiceIcon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchPolicyUserInteractionSelfServiceIcon) UnmarshalBinary(b []byte) error {
	var res PatchPolicyUserInteractionSelfServiceIcon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
