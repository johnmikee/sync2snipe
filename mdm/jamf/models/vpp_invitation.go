// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VppInvitation vpp invitation
//
// swagger:model vpp_invitation
type VppInvitation struct {

	// general
	General *VppInvitationGeneral `json:"general,omitempty"`

	// invitation usage
	InvitationUsage []*VppInvitationInvitationUsageItems0 `json:"invitation_usage"`

	// scope
	Scope *VppInvitationScope `json:"scope,omitempty"`
}

// Validate validates this vpp invitation
func (m *VppInvitation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvitationUsage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitation) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *VppInvitation) validateInvitationUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.InvitationUsage) { // not required
		return nil
	}

	for i := 0; i < len(m.InvitationUsage); i++ {
		if swag.IsZero(m.InvitationUsage[i]) { // not required
			continue
		}

		if m.InvitationUsage[i] != nil {
			if err := m.InvitationUsage[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invitation_usage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("invitation_usage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitation) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation based on the context it is used
func (m *VppInvitation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInvitationUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitation) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *VppInvitation) contextValidateInvitationUsage(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InvitationUsage); i++ {

		if m.InvitationUsage[i] != nil {

			if swag.IsZero(m.InvitationUsage[i]) { // not required
				return nil
			}

			if err := m.InvitationUsage[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invitation_usage" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("invitation_usage" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitation) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitation) UnmarshalBinary(b []byte) error {
	var res VppInvitation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationGeneral vpp invitation general
//
// swagger:model VppInvitationGeneral
type VppInvitationGeneral struct {

	// distribution method
	// Enum: [Prompt users to accept/make available in Self Service Send emails Make available in Self Service only]
	DistributionMethod string `json:"distribution_method,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// message
	Message string `json:"message,omitempty"`

	// name
	// Example: User VPP Invitations
	// Required: true
	Name *string `json:"name"`

	// require login
	RequireLogin *bool `json:"require_login,omitempty"`

	// sender email address
	SenderEmailAddress string `json:"sender_email_address,omitempty"`

	// sender name
	SenderName string `json:"sender_name,omitempty"`

	// subject
	Subject string `json:"subject,omitempty"`

	// vpp account
	VppAccount *VppInvitationGeneralVppAccount `json:"vpp_account,omitempty"`
}

// Validate validates this vpp invitation general
func (m *VppInvitationGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDistributionMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVppAccount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var vppInvitationGeneralTypeDistributionMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Prompt users to accept/make available in Self Service","Send emails","Make available in Self Service only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vppInvitationGeneralTypeDistributionMethodPropEnum = append(vppInvitationGeneralTypeDistributionMethodPropEnum, v)
	}
}

const (

	// VppInvitationGeneralDistributionMethodPromptUsersToAcceptMakeAvailableInSelfService captures enum value "Prompt users to accept/make available in Self Service"
	VppInvitationGeneralDistributionMethodPromptUsersToAcceptMakeAvailableInSelfService string = "Prompt users to accept/make available in Self Service"

	// VppInvitationGeneralDistributionMethodSendEmails captures enum value "Send emails"
	VppInvitationGeneralDistributionMethodSendEmails string = "Send emails"

	// VppInvitationGeneralDistributionMethodMakeAvailableInSelfServiceOnly captures enum value "Make available in Self Service only"
	VppInvitationGeneralDistributionMethodMakeAvailableInSelfServiceOnly string = "Make available in Self Service only"
)

// prop value enum
func (m *VppInvitationGeneral) validateDistributionMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vppInvitationGeneralTypeDistributionMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VppInvitationGeneral) validateDistributionMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.DistributionMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionMethodEnum("general"+"."+"distribution_method", "body", m.DistributionMethod); err != nil {
		return err
	}

	return nil
}

func (m *VppInvitationGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *VppInvitationGeneral) validateVppAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.VppAccount) { // not required
		return nil
	}

	if m.VppAccount != nil {
		if err := m.VppAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "vpp_account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "vpp_account")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation general based on the context it is used
func (m *VppInvitationGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVppAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationGeneral) contextValidateVppAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.VppAccount != nil {

		if swag.IsZero(m.VppAccount) { // not required
			return nil
		}

		if err := m.VppAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "vpp_account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "vpp_account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationGeneral) UnmarshalBinary(b []byte) error {
	var res VppInvitationGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationGeneralVppAccount vpp invitation general vpp account
//
// swagger:model VppInvitationGeneralVppAccount
type VppInvitationGeneralVppAccount struct {

	// id
	// Example: 1
	// Required: true
	ID *int64 `json:"id"`
}

// Validate validates this vpp invitation general vpp account
func (m *VppInvitationGeneralVppAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationGeneralVppAccount) validateID(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"vpp_account"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this vpp invitation general vpp account based on context it is used
func (m *VppInvitationGeneralVppAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationGeneralVppAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationGeneralVppAccount) UnmarshalBinary(b []byte) error {
	var res VppInvitationGeneralVppAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationInvitationUsageItems0 vpp invitation invitation usage items0
//
// swagger:model VppInvitationInvitationUsageItems0
type VppInvitationInvitationUsageItems0 struct {

	// size
	Size Size `json:"size,omitempty"`

	// usage
	Usage *VppInvitationInvitationUsageItems0Usage `json:"usage,omitempty"`
}

// Validate validates this vpp invitation invitation usage items0
func (m *VppInvitationInvitationUsageItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationInvitationUsageItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

func (m *VppInvitationInvitationUsageItems0) validateUsage(formats strfmt.Registry) error {
	if swag.IsZero(m.Usage) { // not required
		return nil
	}

	if m.Usage != nil {
		if err := m.Usage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation invitation usage items0 based on the context it is used
func (m *VppInvitationInvitationUsageItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationInvitationUsageItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

func (m *VppInvitationInvitationUsageItems0) contextValidateUsage(ctx context.Context, formats strfmt.Registry) error {

	if m.Usage != nil {

		if swag.IsZero(m.Usage) { // not required
			return nil
		}

		if err := m.Usage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationInvitationUsageItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationInvitationUsageItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationInvitationUsageItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationInvitationUsageItems0Usage vpp invitation invitation usage items0 usage
//
// swagger:model VppInvitationInvitationUsageItems0Usage
type VppInvitationInvitationUsageItems0Usage struct {

	// email address
	// Example: user@company.com
	EmailAddress string `json:"email_address,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// last action date utc
	// Example: 2017-07-07T18:37:04.555-0500
	LastActionDateUtc string `json:"last_action_date_utc,omitempty"`

	// last action epoch
	// Example: 1499470624555
	LastActionEpoch int64 `json:"last_action_epoch,omitempty"`

	// name
	// Example: Username
	Name string `json:"name,omitempty"`

	// status
	// Example: MDM Invitations was sent
	Status string `json:"status,omitempty"`

	// vpp account
	// Example: Company VPP Account
	VppAccount string `json:"vpp_account,omitempty"`
}

// Validate validates this vpp invitation invitation usage items0 usage
func (m *VppInvitationInvitationUsageItems0Usage) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp invitation invitation usage items0 usage based on context it is used
func (m *VppInvitationInvitationUsageItems0Usage) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationInvitationUsageItems0Usage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationInvitationUsageItems0Usage) UnmarshalBinary(b []byte) error {
	var res VppInvitationInvitationUsageItems0Usage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScope vpp invitation scope
//
// swagger:model VppInvitationScope
type VppInvitationScope struct {

	// all jss users
	AllJssUsers bool `json:"all_jss_users,omitempty"`

	// exclusions
	Exclusions *VppInvitationScopeExclusions `json:"exclusions,omitempty"`

	// jss user groups
	JssUserGroups []*VppInvitationScopeJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*VppInvitationScopeJssUsersItems0 `json:"jss_users"`

	// limitations
	Limitations *VppInvitationScopeLimitations `json:"limitations,omitempty"`
}

// Validate validates this vpp invitation scope
func (m *VppInvitationScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *VppInvitationScope) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScope) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope based on the context it is used
func (m *VppInvitationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *VppInvitationScope) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScope) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScope) UnmarshalBinary(b []byte) error {
	var res VppInvitationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeExclusions vpp invitation scope exclusions
//
// swagger:model VppInvitationScopeExclusions
type VppInvitationScopeExclusions struct {

	// jss user groups
	JssUserGroups []*VppInvitationScopeExclusionsJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*VppInvitationScopeExclusionsJssUsersItems0 `json:"jss_users"`

	// user groups
	UserGroups []*VppInvitationScopeExclusionsUserGroupsItems0 `json:"user_groups"`
}

// Validate validates this vpp invitation scope exclusions
func (m *VppInvitationScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusions) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScopeExclusions) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScopeExclusions) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this vpp invitation scope exclusions based on the context it is used
func (m *VppInvitationScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusions) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScopeExclusions) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppInvitationScopeExclusions) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeExclusions) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeExclusionsJssUserGroupsItems0 vpp invitation scope exclusions jss user groups items0
//
// swagger:model VppInvitationScopeExclusionsJssUserGroupsItems0
type VppInvitationScopeExclusionsJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp invitation scope exclusions jss user groups items0
func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope exclusions jss user groups items0 based on the context it is used
func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeExclusionsJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeExclusionsJssUsersItems0 vpp invitation scope exclusions jss users items0
//
// swagger:model VppInvitationScopeExclusionsJssUsersItems0
type VppInvitationScopeExclusionsJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this vpp invitation scope exclusions jss users items0
func (m *VppInvitationScopeExclusionsJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope exclusions jss users items0 based on the context it is used
func (m *VppInvitationScopeExclusionsJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeExclusionsJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeExclusionsUserGroupsItems0 vpp invitation scope exclusions user groups items0
//
// swagger:model VppInvitationScopeExclusionsUserGroupsItems0
type VppInvitationScopeExclusionsUserGroupsItems0 struct {

	// user group
	UserGroup *VppInvitationScopeExclusionsUserGroupsItems0UserGroup `json:"user_group,omitempty"`
}

// Validate validates this vpp invitation scope exclusions user groups items0
func (m *VppInvitationScopeExclusionsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope exclusions user groups items0 based on the context it is used
func (m *VppInvitationScopeExclusionsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeExclusionsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeExclusionsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeExclusionsUserGroupsItems0UserGroup vpp invitation scope exclusions user groups items0 user group
//
// swagger:model VppInvitationScopeExclusionsUserGroupsItems0UserGroup
type VppInvitationScopeExclusionsUserGroupsItems0UserGroup struct {

	// name
	// Example: LDAP User Group Name
	Name string `json:"name,omitempty"`
}

// Validate validates this vpp invitation scope exclusions user groups items0 user group
func (m *VppInvitationScopeExclusionsUserGroupsItems0UserGroup) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp invitation scope exclusions user groups items0 user group based on context it is used
func (m *VppInvitationScopeExclusionsUserGroupsItems0UserGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsUserGroupsItems0UserGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeExclusionsUserGroupsItems0UserGroup) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeExclusionsUserGroupsItems0UserGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeJssUserGroupsItems0 vpp invitation scope jss user groups items0
//
// swagger:model VppInvitationScopeJssUserGroupsItems0
type VppInvitationScopeJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp invitation scope jss user groups items0
func (m *VppInvitationScopeJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope jss user groups items0 based on the context it is used
func (m *VppInvitationScopeJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeJssUsersItems0 vpp invitation scope jss users items0
//
// swagger:model VppInvitationScopeJssUsersItems0
type VppInvitationScopeJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this vpp invitation scope jss users items0
func (m *VppInvitationScopeJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope jss users items0 based on the context it is used
func (m *VppInvitationScopeJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeLimitations vpp invitation scope limitations
//
// swagger:model VppInvitationScopeLimitations
type VppInvitationScopeLimitations struct {

	// user groups
	UserGroups []*VppInvitationScopeLimitationsUserGroupsItems0 `json:"user_groups"`
}

// Validate validates this vpp invitation scope limitations
func (m *VppInvitationScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeLimitations) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this vpp invitation scope limitations based on the context it is used
func (m *VppInvitationScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeLimitations) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeLimitations) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppInvitationScopeLimitationsUserGroupsItems0 vpp invitation scope limitations user groups items0
//
// swagger:model VppInvitationScopeLimitationsUserGroupsItems0
type VppInvitationScopeLimitationsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp invitation scope limitations user groups items0
func (m *VppInvitationScopeLimitationsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeLimitationsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp invitation scope limitations user groups items0 based on the context it is used
func (m *VppInvitationScopeLimitationsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppInvitationScopeLimitationsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppInvitationScopeLimitationsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppInvitationScopeLimitationsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppInvitationScopeLimitationsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
