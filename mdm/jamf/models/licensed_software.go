// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LicensedSoftware licensed software
//
// swagger:model licensed_software
type LicensedSoftware struct {

	// font definitions
	FontDefinitions []*LicensedSoftwareFontDefinitionsItems0 `json:"font_definitions"`

	// general
	General *LicensedSoftwareGeneral `json:"general,omitempty"`

	// licenses
	Licenses []*LicensedSoftwareLicensesItems0 `json:"licenses"`

	// plugin definitions
	PluginDefinitions []*LicensedSoftwarePluginDefinitionsItems0 `json:"plugin_definitions"`

	// software definitions
	SoftwareDefinitions []*LicensedSoftwareSoftwareDefinitionsItems0 `json:"software_definitions"`
}

// Validate validates this licensed software
func (m *LicensedSoftware) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFontDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePluginDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftware) validateFontDefinitions(formats strfmt.Registry) error {
	if swag.IsZero(m.FontDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.FontDefinitions); i++ {
		if swag.IsZero(m.FontDefinitions[i]) { // not required
			continue
		}

		if m.FontDefinitions[i] != nil {
			if err := m.FontDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("font_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("font_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *LicensedSoftware) validateLicenses(formats strfmt.Registry) error {
	if swag.IsZero(m.Licenses) { // not required
		return nil
	}

	for i := 0; i < len(m.Licenses); i++ {
		if swag.IsZero(m.Licenses[i]) { // not required
			continue
		}

		if m.Licenses[i] != nil {
			if err := m.Licenses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("licenses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("licenses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) validatePluginDefinitions(formats strfmt.Registry) error {
	if swag.IsZero(m.PluginDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.PluginDefinitions); i++ {
		if swag.IsZero(m.PluginDefinitions[i]) { // not required
			continue
		}

		if m.PluginDefinitions[i] != nil {
			if err := m.PluginDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugin_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugin_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) validateSoftwareDefinitions(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.SoftwareDefinitions); i++ {
		if swag.IsZero(m.SoftwareDefinitions[i]) { // not required
			continue
		}

		if m.SoftwareDefinitions[i] != nil {
			if err := m.SoftwareDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("software_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("software_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this licensed software based on the context it is used
func (m *LicensedSoftware) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFontDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLicenses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePluginDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareDefinitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftware) contextValidateFontDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FontDefinitions); i++ {

		if m.FontDefinitions[i] != nil {

			if swag.IsZero(m.FontDefinitions[i]) { // not required
				return nil
			}

			if err := m.FontDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("font_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("font_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *LicensedSoftware) contextValidateLicenses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Licenses); i++ {

		if m.Licenses[i] != nil {

			if swag.IsZero(m.Licenses[i]) { // not required
				return nil
			}

			if err := m.Licenses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("licenses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("licenses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) contextValidatePluginDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PluginDefinitions); i++ {

		if m.PluginDefinitions[i] != nil {

			if swag.IsZero(m.PluginDefinitions[i]) { // not required
				return nil
			}

			if err := m.PluginDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugin_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugin_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftware) contextValidateSoftwareDefinitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SoftwareDefinitions); i++ {

		if m.SoftwareDefinitions[i] != nil {

			if swag.IsZero(m.SoftwareDefinitions[i]) { // not required
				return nil
			}

			if err := m.SoftwareDefinitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("software_definitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("software_definitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftware) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftware) UnmarshalBinary(b []byte) error {
	var res LicensedSoftware
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareFontDefinitionsItems0 licensed software font definitions items0
//
// swagger:model LicensedSoftwareFontDefinitionsItems0
type LicensedSoftwareFontDefinitionsItems0 struct {

	// definition
	Definition *LicensedSoftwareDefintion `json:"definition,omitempty"`
}

// Validate validates this licensed software font definitions items0
func (m *LicensedSoftwareFontDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefinition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareFontDefinitionsItems0) validateDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.Definition) { // not required
		return nil
	}

	if m.Definition != nil {
		if err := m.Definition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software font definitions items0 based on the context it is used
func (m *LicensedSoftwareFontDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareFontDefinitionsItems0) contextValidateDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.Definition != nil {

		if swag.IsZero(m.Definition) { // not required
			return nil
		}

		if err := m.Definition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareFontDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareFontDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareFontDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareGeneral licensed software general
//
// swagger:model LicensedSoftwareGeneral
type LicensedSoftwareGeneral struct {

	// exclude titles purchased from app store
	ExcludeTitlesPurchasedFromAppStore bool `json:"exclude_titles_purchased_from_app_store,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the licensed software
	// Example: Adobe Creative Suite
	// Required: true
	Name *string `json:"name"`

	// notes
	Notes string `json:"notes,omitempty"`

	// platform
	// Example: Mac
	Platform string `json:"platform,omitempty"`

	// publisher
	// Example: Adobe Systems Incorporated
	Publisher string `json:"publisher,omitempty"`

	// remove titles from inventory reports
	RemoveTitlesFromInventoryReports bool `json:"remove_titles_from_inventory_reports,omitempty"`

	// send email on violation
	SendEmailOnViolation bool `json:"send_email_on_violation,omitempty"`

	// site
	Site *SiteObject `json:"site,omitempty"`
}

// Validate validates this licensed software general
func (m *LicensedSoftwareGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *LicensedSoftwareGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software general based on the context it is used
func (m *LicensedSoftwareGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareGeneral) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareLicensesItems0 licensed software licenses items0
//
// swagger:model LicensedSoftwareLicensesItems0
type LicensedSoftwareLicensesItems0 struct {

	// license
	License *LicensedSoftwareLicensesItems0License `json:"license,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this licensed software licenses items0
func (m *LicensedSoftwareLicensesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLicense(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0) validateLicense(formats strfmt.Registry) error {
	if swag.IsZero(m.License) { // not required
		return nil
	}

	if m.License != nil {
		if err := m.License.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *LicensedSoftwareLicensesItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this licensed software licenses items0 based on the context it is used
func (m *LicensedSoftwareLicensesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLicense(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0) contextValidateLicense(ctx context.Context, formats strfmt.Registry) error {

	if m.License != nil {

		if swag.IsZero(m.License) { // not required
			return nil
		}

		if err := m.License.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license")
			}
			return err
		}
	}

	return nil
}

func (m *LicensedSoftwareLicensesItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareLicensesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareLicensesItems0License licensed software licenses items0 license
//
// swagger:model LicensedSoftwareLicensesItems0License
type LicensedSoftwareLicensesItems0License struct {

	// attachments
	Attachments []*LicensedSoftwareLicensesItems0LicenseAttachmentsItems0 `json:"attachments"`

	// license count
	// Example: 500
	LicenseCount int64 `json:"license_count,omitempty"`

	// license type
	// Enum: [Standard Concurrent Site License]
	LicenseType string `json:"license_type,omitempty"`

	// notes
	Notes string `json:"notes,omitempty"`

	// organization name
	OrganizationName string `json:"organization_name,omitempty"`

	// purchasing
	Purchasing *LicensedSoftwareLicensesItems0LicensePurchasing `json:"purchasing,omitempty"`

	// registered to
	RegisteredTo string `json:"registered_to,omitempty"`

	// serial number 1
	SerialNumber1 string `json:"serial_number_1,omitempty"`

	// serial number 2
	SerialNumber2 string `json:"serial_number_2,omitempty"`
}

// Validate validates this licensed software licenses items0 license
func (m *LicensedSoftwareLicensesItems0License) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurchasing(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0License) validateAttachments(formats strfmt.Registry) error {
	if swag.IsZero(m.Attachments) { // not required
		return nil
	}

	for i := 0; i < len(m.Attachments); i++ {
		if swag.IsZero(m.Attachments[i]) { // not required
			continue
		}

		if m.Attachments[i] != nil {
			if err := m.Attachments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("license" + "." + "attachments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("license" + "." + "attachments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var licensedSoftwareLicensesItems0LicenseTypeLicenseTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Standard","Concurrent","Site License"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		licensedSoftwareLicensesItems0LicenseTypeLicenseTypePropEnum = append(licensedSoftwareLicensesItems0LicenseTypeLicenseTypePropEnum, v)
	}
}

const (

	// LicensedSoftwareLicensesItems0LicenseLicenseTypeStandard captures enum value "Standard"
	LicensedSoftwareLicensesItems0LicenseLicenseTypeStandard string = "Standard"

	// LicensedSoftwareLicensesItems0LicenseLicenseTypeConcurrent captures enum value "Concurrent"
	LicensedSoftwareLicensesItems0LicenseLicenseTypeConcurrent string = "Concurrent"

	// LicensedSoftwareLicensesItems0LicenseLicenseTypeSiteLicense captures enum value "Site License"
	LicensedSoftwareLicensesItems0LicenseLicenseTypeSiteLicense string = "Site License"
)

// prop value enum
func (m *LicensedSoftwareLicensesItems0License) validateLicenseTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, licensedSoftwareLicensesItems0LicenseTypeLicenseTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0License) validateLicenseType(formats strfmt.Registry) error {
	if swag.IsZero(m.LicenseType) { // not required
		return nil
	}

	// value enum
	if err := m.validateLicenseTypeEnum("license"+"."+"license_type", "body", m.LicenseType); err != nil {
		return err
	}

	return nil
}

func (m *LicensedSoftwareLicensesItems0License) validatePurchasing(formats strfmt.Registry) error {
	if swag.IsZero(m.Purchasing) { // not required
		return nil
	}

	if m.Purchasing != nil {
		if err := m.Purchasing.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license" + "." + "purchasing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license" + "." + "purchasing")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software licenses items0 license based on the context it is used
func (m *LicensedSoftwareLicensesItems0License) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttachments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePurchasing(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0License) contextValidateAttachments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Attachments); i++ {

		if m.Attachments[i] != nil {

			if swag.IsZero(m.Attachments[i]) { // not required
				return nil
			}

			if err := m.Attachments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("license" + "." + "attachments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("license" + "." + "attachments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *LicensedSoftwareLicensesItems0License) contextValidatePurchasing(ctx context.Context, formats strfmt.Registry) error {

	if m.Purchasing != nil {

		if swag.IsZero(m.Purchasing) { // not required
			return nil
		}

		if err := m.Purchasing.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license" + "." + "purchasing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license" + "." + "purchasing")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0License) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0License) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareLicensesItems0License
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareLicensesItems0LicenseAttachmentsItems0 licensed software licenses items0 license attachments items0
//
// swagger:model LicensedSoftwareLicensesItems0LicenseAttachmentsItems0
type LicensedSoftwareLicensesItems0LicenseAttachmentsItems0 struct {

	// attachment
	Attachment *Attachment `json:"attachment,omitempty"`
}

// Validate validates this licensed software licenses items0 license attachments items0
func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) validateAttachment(formats strfmt.Registry) error {
	if swag.IsZero(m.Attachment) { // not required
		return nil
	}

	if m.Attachment != nil {
		if err := m.Attachment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attachment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attachment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software licenses items0 license attachments items0 based on the context it is used
func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttachment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) contextValidateAttachment(ctx context.Context, formats strfmt.Registry) error {

	if m.Attachment != nil {

		if swag.IsZero(m.Attachment) { // not required
			return nil
		}

		if err := m.Attachment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attachment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attachment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0LicenseAttachmentsItems0) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareLicensesItems0LicenseAttachmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareLicensesItems0LicensePurchasing licensed software licenses items0 license purchasing
//
// swagger:model LicensedSoftwareLicensesItems0LicensePurchasing
type LicensedSoftwareLicensesItems0LicensePurchasing struct {

	// is annual
	IsAnnual *bool `json:"is_annual,omitempty"`

	// is perpetual
	IsPerpetual *bool `json:"is_perpetual,omitempty"`

	// license expires
	LicenseExpires string `json:"license_expires,omitempty"`

	// license expires epoch
	LicenseExpiresEpoch int64 `json:"license_expires_epoch,omitempty"`

	// license expires utc
	LicenseExpiresUtc string `json:"license_expires_utc,omitempty"`

	// life expectancy
	LifeExpectancy int64 `json:"life_expectancy,omitempty"`

	// po date
	PoDate string `json:"po_date,omitempty"`

	// po date epoch
	PoDateEpoch int64 `json:"po_date_epoch,omitempty"`

	// po date utc
	PoDateUtc string `json:"po_date_utc,omitempty"`

	// po number
	PoNumber string `json:"po_number,omitempty"`

	// purchase price
	PurchasePrice string `json:"purchase_price,omitempty"`

	// purchasing account
	PurchasingAccount string `json:"purchasing_account,omitempty"`

	// purchasing contact
	PurchasingContact string `json:"purchasing_contact,omitempty"`

	// vendor
	Vendor string `json:"vendor,omitempty"`
}

// Validate validates this licensed software licenses items0 license purchasing
func (m *LicensedSoftwareLicensesItems0LicensePurchasing) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this licensed software licenses items0 license purchasing based on context it is used
func (m *LicensedSoftwareLicensesItems0LicensePurchasing) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0LicensePurchasing) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareLicensesItems0LicensePurchasing) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareLicensesItems0LicensePurchasing
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwarePluginDefinitionsItems0 licensed software plugin definitions items0
//
// swagger:model LicensedSoftwarePluginDefinitionsItems0
type LicensedSoftwarePluginDefinitionsItems0 struct {

	// definition
	Definition *LicensedSoftwareDefintion `json:"definition,omitempty"`
}

// Validate validates this licensed software plugin definitions items0
func (m *LicensedSoftwarePluginDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefinition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwarePluginDefinitionsItems0) validateDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.Definition) { // not required
		return nil
	}

	if m.Definition != nil {
		if err := m.Definition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software plugin definitions items0 based on the context it is used
func (m *LicensedSoftwarePluginDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwarePluginDefinitionsItems0) contextValidateDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.Definition != nil {

		if swag.IsZero(m.Definition) { // not required
			return nil
		}

		if err := m.Definition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwarePluginDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwarePluginDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwarePluginDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// LicensedSoftwareSoftwareDefinitionsItems0 licensed software software definitions items0
//
// swagger:model LicensedSoftwareSoftwareDefinitionsItems0
type LicensedSoftwareSoftwareDefinitionsItems0 struct {

	// definition
	Definition *LicensedSoftwareDefintion `json:"definition,omitempty"`
}

// Validate validates this licensed software software definitions items0
func (m *LicensedSoftwareSoftwareDefinitionsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefinition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareSoftwareDefinitionsItems0) validateDefinition(formats strfmt.Registry) error {
	if swag.IsZero(m.Definition) { // not required
		return nil
	}

	if m.Definition != nil {
		if err := m.Definition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this licensed software software definitions items0 based on the context it is used
func (m *LicensedSoftwareSoftwareDefinitionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefinition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LicensedSoftwareSoftwareDefinitionsItems0) contextValidateDefinition(ctx context.Context, formats strfmt.Registry) error {

	if m.Definition != nil {

		if swag.IsZero(m.Definition) { // not required
			return nil
		}

		if err := m.Definition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("definition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("definition")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LicensedSoftwareSoftwareDefinitionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LicensedSoftwareSoftwareDefinitionsItems0) UnmarshalBinary(b []byte) error {
	var res LicensedSoftwareSoftwareDefinitionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
