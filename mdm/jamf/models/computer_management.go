// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ComputerManagement computer management
//
// swagger:model computer_management
type ComputerManagement struct {

	// ebooks
	Ebooks []*ComputerManagementEbooksItems0 `json:"ebooks"`

	// general
	General *ComputerManagementGeneral `json:"general,omitempty"`

	// mac app store apps
	MacAppStoreApps []*ComputerManagementMacAppStoreAppsItems0 `json:"mac_app_store_apps"`

	// managed preference profiles
	ManagedPreferenceProfiles []*ComputerManagementManagedPreferenceProfilesItems0 `json:"managed_preference_profiles"`

	// os x configuration profiles
	OsxConfigurationProfiles []*ComputerManagementOsxConfigurationProfilesItems0 `json:"os_x_configuration_profiles"`

	// patch policies
	PatchPolicies []*ComputerManagementPatchPoliciesItems0 `json:"patch_policies"`

	// patch reporting software titles
	PatchReportingSoftwareTitles []*ComputerManagementPatchReportingSoftwareTitlesItems0 `json:"patch_reporting_software_titles"`

	// policies
	Policies []*ComputerManagementPoliciesItems0 `json:"policies"`

	// restricted software
	RestrictedSoftware []*ComputerManagementRestrictedSoftwareItems0 `json:"restricted_software"`

	// smart groups
	SmartGroups []*ComputerManagementSmartGroupsItems0 `json:"smart_groups"`

	// static groups
	StaticGroups []*ComputerManagementStaticGroupsItems0 `json:"static_groups"`
}

// Validate validates this computer management
func (m *ComputerManagement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEbooks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMacAppStoreApps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagedPreferenceProfiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsxConfigurationProfiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatchPolicies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatchReportingSoftwareTitles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestrictedSoftware(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmartGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStaticGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagement) validateEbooks(formats strfmt.Registry) error {
	if swag.IsZero(m.Ebooks) { // not required
		return nil
	}

	for i := 0; i < len(m.Ebooks); i++ {
		if swag.IsZero(m.Ebooks[i]) { // not required
			continue
		}

		if m.Ebooks[i] != nil {
			if err := m.Ebooks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ebooks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ebooks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerManagement) validateMacAppStoreApps(formats strfmt.Registry) error {
	if swag.IsZero(m.MacAppStoreApps) { // not required
		return nil
	}

	for i := 0; i < len(m.MacAppStoreApps); i++ {
		if swag.IsZero(m.MacAppStoreApps[i]) { // not required
			continue
		}

		if m.MacAppStoreApps[i] != nil {
			if err := m.MacAppStoreApps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateManagedPreferenceProfiles(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagedPreferenceProfiles) { // not required
		return nil
	}

	for i := 0; i < len(m.ManagedPreferenceProfiles); i++ {
		if swag.IsZero(m.ManagedPreferenceProfiles[i]) { // not required
			continue
		}

		if m.ManagedPreferenceProfiles[i] != nil {
			if err := m.ManagedPreferenceProfiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("managed_preference_profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("managed_preference_profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateOsxConfigurationProfiles(formats strfmt.Registry) error {
	if swag.IsZero(m.OsxConfigurationProfiles) { // not required
		return nil
	}

	for i := 0; i < len(m.OsxConfigurationProfiles); i++ {
		if swag.IsZero(m.OsxConfigurationProfiles[i]) { // not required
			continue
		}

		if m.OsxConfigurationProfiles[i] != nil {
			if err := m.OsxConfigurationProfiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("os_x_configuration_profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("os_x_configuration_profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validatePatchPolicies(formats strfmt.Registry) error {
	if swag.IsZero(m.PatchPolicies) { // not required
		return nil
	}

	for i := 0; i < len(m.PatchPolicies); i++ {
		if swag.IsZero(m.PatchPolicies[i]) { // not required
			continue
		}

		if m.PatchPolicies[i] != nil {
			if err := m.PatchPolicies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patch_policies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patch_policies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validatePatchReportingSoftwareTitles(formats strfmt.Registry) error {
	if swag.IsZero(m.PatchReportingSoftwareTitles) { // not required
		return nil
	}

	for i := 0; i < len(m.PatchReportingSoftwareTitles); i++ {
		if swag.IsZero(m.PatchReportingSoftwareTitles[i]) { // not required
			continue
		}

		if m.PatchReportingSoftwareTitles[i] != nil {
			if err := m.PatchReportingSoftwareTitles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patch_reporting_software_titles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patch_reporting_software_titles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validatePolicies(formats strfmt.Registry) error {
	if swag.IsZero(m.Policies) { // not required
		return nil
	}

	for i := 0; i < len(m.Policies); i++ {
		if swag.IsZero(m.Policies[i]) { // not required
			continue
		}

		if m.Policies[i] != nil {
			if err := m.Policies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("policies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("policies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateRestrictedSoftware(formats strfmt.Registry) error {
	if swag.IsZero(m.RestrictedSoftware) { // not required
		return nil
	}

	for i := 0; i < len(m.RestrictedSoftware); i++ {
		if swag.IsZero(m.RestrictedSoftware[i]) { // not required
			continue
		}

		if m.RestrictedSoftware[i] != nil {
			if err := m.RestrictedSoftware[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("restricted_software" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("restricted_software" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateSmartGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.SmartGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.SmartGroups); i++ {
		if swag.IsZero(m.SmartGroups[i]) { // not required
			continue
		}

		if m.SmartGroups[i] != nil {
			if err := m.SmartGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("smart_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("smart_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) validateStaticGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.StaticGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.StaticGroups); i++ {
		if swag.IsZero(m.StaticGroups[i]) { // not required
			continue
		}

		if m.StaticGroups[i] != nil {
			if err := m.StaticGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("static_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("static_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this computer management based on the context it is used
func (m *ComputerManagement) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEbooks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAppStoreApps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagedPreferenceProfiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOsxConfigurationProfiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePatchPolicies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePatchReportingSoftwareTitles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePolicies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestrictedSoftware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSmartGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStaticGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagement) contextValidateEbooks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ebooks); i++ {

		if m.Ebooks[i] != nil {

			if swag.IsZero(m.Ebooks[i]) { // not required
				return nil
			}

			if err := m.Ebooks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ebooks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ebooks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerManagement) contextValidateMacAppStoreApps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MacAppStoreApps); i++ {

		if m.MacAppStoreApps[i] != nil {

			if swag.IsZero(m.MacAppStoreApps[i]) { // not required
				return nil
			}

			if err := m.MacAppStoreApps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateManagedPreferenceProfiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ManagedPreferenceProfiles); i++ {

		if m.ManagedPreferenceProfiles[i] != nil {

			if swag.IsZero(m.ManagedPreferenceProfiles[i]) { // not required
				return nil
			}

			if err := m.ManagedPreferenceProfiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("managed_preference_profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("managed_preference_profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateOsxConfigurationProfiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OsxConfigurationProfiles); i++ {

		if m.OsxConfigurationProfiles[i] != nil {

			if swag.IsZero(m.OsxConfigurationProfiles[i]) { // not required
				return nil
			}

			if err := m.OsxConfigurationProfiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("os_x_configuration_profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("os_x_configuration_profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidatePatchPolicies(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PatchPolicies); i++ {

		if m.PatchPolicies[i] != nil {

			if swag.IsZero(m.PatchPolicies[i]) { // not required
				return nil
			}

			if err := m.PatchPolicies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patch_policies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patch_policies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidatePatchReportingSoftwareTitles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PatchReportingSoftwareTitles); i++ {

		if m.PatchReportingSoftwareTitles[i] != nil {

			if swag.IsZero(m.PatchReportingSoftwareTitles[i]) { // not required
				return nil
			}

			if err := m.PatchReportingSoftwareTitles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patch_reporting_software_titles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patch_reporting_software_titles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidatePolicies(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Policies); i++ {

		if m.Policies[i] != nil {

			if swag.IsZero(m.Policies[i]) { // not required
				return nil
			}

			if err := m.Policies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("policies" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("policies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateRestrictedSoftware(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RestrictedSoftware); i++ {

		if m.RestrictedSoftware[i] != nil {

			if swag.IsZero(m.RestrictedSoftware[i]) { // not required
				return nil
			}

			if err := m.RestrictedSoftware[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("restricted_software" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("restricted_software" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateSmartGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SmartGroups); i++ {

		if m.SmartGroups[i] != nil {

			if swag.IsZero(m.SmartGroups[i]) { // not required
				return nil
			}

			if err := m.SmartGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("smart_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("smart_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerManagement) contextValidateStaticGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StaticGroups); i++ {

		if m.StaticGroups[i] != nil {

			if swag.IsZero(m.StaticGroups[i]) { // not required
				return nil
			}

			if err := m.StaticGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("static_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("static_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagement) UnmarshalBinary(b []byte) error {
	var res ComputerManagement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementEbooksItems0 computer management ebooks items0
//
// swagger:model ComputerManagementEbooksItems0
type ComputerManagementEbooksItems0 struct {

	// ebook
	Ebook *IDName `json:"ebook,omitempty"`
}

// Validate validates this computer management ebooks items0
func (m *ComputerManagementEbooksItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEbook(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementEbooksItems0) validateEbook(formats strfmt.Registry) error {
	if swag.IsZero(m.Ebook) { // not required
		return nil
	}

	if m.Ebook != nil {
		if err := m.Ebook.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ebook")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ebook")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management ebooks items0 based on the context it is used
func (m *ComputerManagementEbooksItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEbook(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementEbooksItems0) contextValidateEbook(ctx context.Context, formats strfmt.Registry) error {

	if m.Ebook != nil {

		if swag.IsZero(m.Ebook) { // not required
			return nil
		}

		if err := m.Ebook.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ebook")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ebook")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementEbooksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementEbooksItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementEbooksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementGeneral computer management general
//
// swagger:model ComputerManagementGeneral
type ComputerManagementGeneral struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// mac address
	// Example: E0:AC:CB:97:36:G4
	MacAddress string `json:"mac_address,omitempty"`

	// Name of the computer
	// Example: Steves iMac
	Name string `json:"name,omitempty"`

	// serial number
	// Example: C02Q7KHTGFWF
	SerialNumber string `json:"serial_number,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this computer management general
func (m *ComputerManagementGeneral) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer management general based on context it is used
func (m *ComputerManagementGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementGeneral) UnmarshalBinary(b []byte) error {
	var res ComputerManagementGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementMacAppStoreAppsItems0 computer management mac app store apps items0
//
// swagger:model ComputerManagementMacAppStoreAppsItems0
type ComputerManagementMacAppStoreAppsItems0 struct {

	// mac app store app
	MacAppStoreApp *IDName `json:"mac_app_store_app,omitempty"`
}

// Validate validates this computer management mac app store apps items0
func (m *ComputerManagementMacAppStoreAppsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMacAppStoreApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementMacAppStoreAppsItems0) validateMacAppStoreApp(formats strfmt.Registry) error {
	if swag.IsZero(m.MacAppStoreApp) { // not required
		return nil
	}

	if m.MacAppStoreApp != nil {
		if err := m.MacAppStoreApp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app_store_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app_store_app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management mac app store apps items0 based on the context it is used
func (m *ComputerManagementMacAppStoreAppsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMacAppStoreApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementMacAppStoreAppsItems0) contextValidateMacAppStoreApp(ctx context.Context, formats strfmt.Registry) error {

	if m.MacAppStoreApp != nil {

		if swag.IsZero(m.MacAppStoreApp) { // not required
			return nil
		}

		if err := m.MacAppStoreApp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app_store_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app_store_app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementMacAppStoreAppsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementMacAppStoreAppsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementMacAppStoreAppsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementManagedPreferenceProfilesItems0 computer management managed preference profiles items0
//
// swagger:model ComputerManagementManagedPreferenceProfilesItems0
type ComputerManagementManagedPreferenceProfilesItems0 struct {

	// profile
	Profile *IDName `json:"profile,omitempty"`
}

// Validate validates this computer management managed preference profiles items0
func (m *ComputerManagementManagedPreferenceProfilesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProfile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementManagedPreferenceProfilesItems0) validateProfile(formats strfmt.Registry) error {
	if swag.IsZero(m.Profile) { // not required
		return nil
	}

	if m.Profile != nil {
		if err := m.Profile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management managed preference profiles items0 based on the context it is used
func (m *ComputerManagementManagedPreferenceProfilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProfile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementManagedPreferenceProfilesItems0) contextValidateProfile(ctx context.Context, formats strfmt.Registry) error {

	if m.Profile != nil {

		if swag.IsZero(m.Profile) { // not required
			return nil
		}

		if err := m.Profile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementManagedPreferenceProfilesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementManagedPreferenceProfilesItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementManagedPreferenceProfilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementOsxConfigurationProfilesItems0 computer management osx configuration profiles items0
//
// swagger:model ComputerManagementOsxConfigurationProfilesItems0
type ComputerManagementOsxConfigurationProfilesItems0 struct {

	// profile
	Profile *IDName `json:"profile,omitempty"`
}

// Validate validates this computer management osx configuration profiles items0
func (m *ComputerManagementOsxConfigurationProfilesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProfile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementOsxConfigurationProfilesItems0) validateProfile(formats strfmt.Registry) error {
	if swag.IsZero(m.Profile) { // not required
		return nil
	}

	if m.Profile != nil {
		if err := m.Profile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management osx configuration profiles items0 based on the context it is used
func (m *ComputerManagementOsxConfigurationProfilesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProfile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementOsxConfigurationProfilesItems0) contextValidateProfile(ctx context.Context, formats strfmt.Registry) error {

	if m.Profile != nil {

		if swag.IsZero(m.Profile) { // not required
			return nil
		}

		if err := m.Profile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementOsxConfigurationProfilesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementOsxConfigurationProfilesItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementOsxConfigurationProfilesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementPatchPoliciesItems0 computer management patch policies items0
//
// swagger:model ComputerManagementPatchPoliciesItems0
type ComputerManagementPatchPoliciesItems0 struct {

	// patch policy
	PatchPolicy *IDName `json:"patch_policy,omitempty"`
}

// Validate validates this computer management patch policies items0
func (m *ComputerManagementPatchPoliciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePatchPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPatchPoliciesItems0) validatePatchPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.PatchPolicy) { // not required
		return nil
	}

	if m.PatchPolicy != nil {
		if err := m.PatchPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patch_policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patch_policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management patch policies items0 based on the context it is used
func (m *ComputerManagementPatchPoliciesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePatchPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPatchPoliciesItems0) contextValidatePatchPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.PatchPolicy != nil {

		if swag.IsZero(m.PatchPolicy) { // not required
			return nil
		}

		if err := m.PatchPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patch_policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patch_policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementPatchPoliciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementPatchPoliciesItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementPatchPoliciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementPatchReportingSoftwareTitlesItems0 computer management patch reporting software titles items0
//
// swagger:model ComputerManagementPatchReportingSoftwareTitlesItems0
type ComputerManagementPatchReportingSoftwareTitlesItems0 struct {

	// title
	Title *ComputerManagementPatchReportingSoftwareTitlesItems0Title `json:"title,omitempty"`
}

// Validate validates this computer management patch reporting software titles items0
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(m.Title) { // not required
		return nil
	}

	if m.Title != nil {
		if err := m.Title.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("title")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("title")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management patch reporting software titles items0 based on the context it is used
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTitle(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) contextValidateTitle(ctx context.Context, formats strfmt.Registry) error {

	if m.Title != nil {

		if swag.IsZero(m.Title) { // not required
			return nil
		}

		if err := m.Title.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("title")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("title")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementPatchReportingSoftwareTitlesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementPatchReportingSoftwareTitlesItems0Title computer management patch reporting software titles items0 title
//
// swagger:model ComputerManagementPatchReportingSoftwareTitlesItems0Title
type ComputerManagementPatchReportingSoftwareTitlesItems0Title struct {

	// installed version
	// Example: 63.0.3239.132
	InstalledVersion string `json:"installed_version,omitempty"`

	// latest version
	// Example: 64.0.3282.119
	LatestVersion string `json:"latest_version,omitempty"`

	// name
	// Example: Google Chrome
	Name string `json:"name,omitempty"`
}

// Validate validates this computer management patch reporting software titles items0 title
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0Title) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer management patch reporting software titles items0 title based on context it is used
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0Title) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0Title) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementPatchReportingSoftwareTitlesItems0Title) UnmarshalBinary(b []byte) error {
	var res ComputerManagementPatchReportingSoftwareTitlesItems0Title
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementPoliciesItems0 computer management policies items0
//
// swagger:model ComputerManagementPoliciesItems0
type ComputerManagementPoliciesItems0 struct {

	// policy
	Policy *ComputerManagementPoliciesItems0Policy `json:"policy,omitempty"`
}

// Validate validates this computer management policies items0
func (m *ComputerManagementPoliciesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPoliciesItems0) validatePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.Policy) { // not required
		return nil
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("policy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management policies items0 based on the context it is used
func (m *ComputerManagementPoliciesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementPoliciesItems0) contextValidatePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.Policy != nil {

		if swag.IsZero(m.Policy) { // not required
			return nil
		}

		if err := m.Policy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("policy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("policy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementPoliciesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementPoliciesItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementPoliciesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementPoliciesItems0Policy computer management policies items0 policy
//
// swagger:model ComputerManagementPoliciesItems0Policy
type ComputerManagementPoliciesItems0Policy struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Update Inventory
	Name string `json:"name,omitempty"`

	// trigger
	// Example: Self Service, Check-in
	Trigger string `json:"trigger,omitempty"`
}

// Validate validates this computer management policies items0 policy
func (m *ComputerManagementPoliciesItems0Policy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer management policies items0 policy based on context it is used
func (m *ComputerManagementPoliciesItems0Policy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementPoliciesItems0Policy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementPoliciesItems0Policy) UnmarshalBinary(b []byte) error {
	var res ComputerManagementPoliciesItems0Policy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementRestrictedSoftwareItems0 computer management restricted software items0
//
// swagger:model ComputerManagementRestrictedSoftwareItems0
type ComputerManagementRestrictedSoftwareItems0 struct {

	// software
	Software *IDName `json:"software,omitempty"`
}

// Validate validates this computer management restricted software items0
func (m *ComputerManagementRestrictedSoftwareItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSoftware(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementRestrictedSoftwareItems0) validateSoftware(formats strfmt.Registry) error {
	if swag.IsZero(m.Software) { // not required
		return nil
	}

	if m.Software != nil {
		if err := m.Software.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management restricted software items0 based on the context it is used
func (m *ComputerManagementRestrictedSoftwareItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSoftware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementRestrictedSoftwareItems0) contextValidateSoftware(ctx context.Context, formats strfmt.Registry) error {

	if m.Software != nil {

		if swag.IsZero(m.Software) { // not required
			return nil
		}

		if err := m.Software.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementRestrictedSoftwareItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementRestrictedSoftwareItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementRestrictedSoftwareItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementSmartGroupsItems0 computer management smart groups items0
//
// swagger:model ComputerManagementSmartGroupsItems0
type ComputerManagementSmartGroupsItems0 struct {

	// group
	Group *IDName `json:"group,omitempty"`
}

// Validate validates this computer management smart groups items0
func (m *ComputerManagementSmartGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementSmartGroupsItems0) validateGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Group) { // not required
		return nil
	}

	if m.Group != nil {
		if err := m.Group.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management smart groups items0 based on the context it is used
func (m *ComputerManagementSmartGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementSmartGroupsItems0) contextValidateGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Group != nil {

		if swag.IsZero(m.Group) { // not required
			return nil
		}

		if err := m.Group.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementSmartGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementSmartGroupsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementSmartGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerManagementStaticGroupsItems0 computer management static groups items0
//
// swagger:model ComputerManagementStaticGroupsItems0
type ComputerManagementStaticGroupsItems0 struct {

	// group
	Group *IDName `json:"group,omitempty"`
}

// Validate validates this computer management static groups items0
func (m *ComputerManagementStaticGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementStaticGroupsItems0) validateGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.Group) { // not required
		return nil
	}

	if m.Group != nil {
		if err := m.Group.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer management static groups items0 based on the context it is used
func (m *ComputerManagementStaticGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerManagementStaticGroupsItems0) contextValidateGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.Group != nil {

		if swag.IsZero(m.Group) { // not required
			return nil
		}

		if err := m.Group.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerManagementStaticGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerManagementStaticGroupsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerManagementStaticGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
