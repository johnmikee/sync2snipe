// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PolicyPost policy post
//
// swagger:model policy_post
type PolicyPost struct {

	// general
	General *PolicyPostGeneral `json:"general,omitempty"`
}

// Validate validates this policy post
func (m *PolicyPost) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPost) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy post based on the context it is used
func (m *PolicyPost) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPost) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPost) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPost) UnmarshalBinary(b []byte) error {
	var res PolicyPost
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPostGeneral policy post general
//
// swagger:model PolicyPostGeneral
type PolicyPostGeneral struct {

	// category
	Category *CategoryObject `json:"category,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// frequency
	// Enum: [Once per computer Once per user per computer Once per user Once every day Once every week Once every month Ongoing]
	Frequency string `json:"frequency,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// location user only
	LocationUserOnly *bool `json:"location_user_only,omitempty"`

	// name
	// Example: Disk Encryption
	// Required: true
	Name *string `json:"name"`

	// network limitations
	NetworkLimitations *PolicyPostGeneralNetworkLimitations `json:"network_limitations,omitempty"`

	// network requirements
	// Enum: [Any Ethernet]
	NetworkRequirements string `json:"network_requirements,omitempty"`

	// offline
	Offline *bool `json:"offline,omitempty"`

	// site
	Site *SiteObject `json:"site,omitempty"`

	// target drive
	// Example: /
	TargetDrive string `json:"target_drive,omitempty"`

	// trigger
	Trigger string `json:"trigger,omitempty"`

	// trigger checkin
	TriggerCheckin *bool `json:"trigger_checkin,omitempty"`

	// trigger enrollment complete
	TriggerEnrollmentComplete *bool `json:"trigger_enrollment_complete,omitempty"`

	// trigger login
	TriggerLogin *bool `json:"trigger_login,omitempty"`

	// trigger logout
	TriggerLogout *bool `json:"trigger_logout,omitempty"`

	// trigger network state changed
	TriggerNetworkStateChanged *bool `json:"trigger_network_state_changed,omitempty"`

	// trigger other
	TriggerOther string `json:"trigger_other,omitempty"`

	// trigger startup
	TriggerStartup *bool `json:"trigger_startup,omitempty"`
}

// Validate validates this policy post general
func (m *PolicyPostGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkLimitations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkRequirements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPostGeneral) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

var policyPostGeneralTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Once per computer","Once per user per computer","Once per user","Once every day","Once every week","Once every month","Ongoing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyPostGeneralTypeFrequencyPropEnum = append(policyPostGeneralTypeFrequencyPropEnum, v)
	}
}

const (

	// PolicyPostGeneralFrequencyOncePerComputer captures enum value "Once per computer"
	PolicyPostGeneralFrequencyOncePerComputer string = "Once per computer"

	// PolicyPostGeneralFrequencyOncePerUserPerComputer captures enum value "Once per user per computer"
	PolicyPostGeneralFrequencyOncePerUserPerComputer string = "Once per user per computer"

	// PolicyPostGeneralFrequencyOncePerUser captures enum value "Once per user"
	PolicyPostGeneralFrequencyOncePerUser string = "Once per user"

	// PolicyPostGeneralFrequencyOnceEveryDay captures enum value "Once every day"
	PolicyPostGeneralFrequencyOnceEveryDay string = "Once every day"

	// PolicyPostGeneralFrequencyOnceEveryWeek captures enum value "Once every week"
	PolicyPostGeneralFrequencyOnceEveryWeek string = "Once every week"

	// PolicyPostGeneralFrequencyOnceEveryMonth captures enum value "Once every month"
	PolicyPostGeneralFrequencyOnceEveryMonth string = "Once every month"

	// PolicyPostGeneralFrequencyOngoing captures enum value "Ongoing"
	PolicyPostGeneralFrequencyOngoing string = "Ongoing"
)

// prop value enum
func (m *PolicyPostGeneral) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyPostGeneralTypeFrequencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyPostGeneral) validateFrequency(formats strfmt.Registry) error {
	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencyEnum("general"+"."+"frequency", "body", m.Frequency); err != nil {
		return err
	}

	return nil
}

func (m *PolicyPostGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *PolicyPostGeneral) validateNetworkLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkLimitations) { // not required
		return nil
	}

	if m.NetworkLimitations != nil {
		if err := m.NetworkLimitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "network_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "network_limitations")
			}
			return err
		}
	}

	return nil
}

var policyPostGeneralTypeNetworkRequirementsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Any","Ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyPostGeneralTypeNetworkRequirementsPropEnum = append(policyPostGeneralTypeNetworkRequirementsPropEnum, v)
	}
}

const (

	// PolicyPostGeneralNetworkRequirementsAny captures enum value "Any"
	PolicyPostGeneralNetworkRequirementsAny string = "Any"

	// PolicyPostGeneralNetworkRequirementsEthernet captures enum value "Ethernet"
	PolicyPostGeneralNetworkRequirementsEthernet string = "Ethernet"
)

// prop value enum
func (m *PolicyPostGeneral) validateNetworkRequirementsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyPostGeneralTypeNetworkRequirementsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyPostGeneral) validateNetworkRequirements(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkRequirements) { // not required
		return nil
	}

	// value enum
	if err := m.validateNetworkRequirementsEnum("general"+"."+"network_requirements", "body", m.NetworkRequirements); err != nil {
		return err
	}

	return nil
}

func (m *PolicyPostGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy post general based on the context it is used
func (m *PolicyPostGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPostGeneral) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPostGeneral) contextValidateNetworkLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkLimitations != nil {

		if swag.IsZero(m.NetworkLimitations) { // not required
			return nil
		}

		if err := m.NetworkLimitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "network_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "network_limitations")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPostGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPostGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPostGeneral) UnmarshalBinary(b []byte) error {
	var res PolicyPostGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPostGeneralNetworkLimitations policy post general network limitations
//
// swagger:model PolicyPostGeneralNetworkLimitations
type PolicyPostGeneralNetworkLimitations struct {

	// any ip address
	AnyIPAddress bool `json:"any_ip_address,omitempty"`

	// minimum network connection
	// Enum: [No Minimum Ethernet]
	MinimumNetworkConnection string `json:"minimum_network_connection,omitempty"`
}

// Validate validates this policy post general network limitations
func (m *PolicyPostGeneralNetworkLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMinimumNetworkConnection(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyPostGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["No Minimum","Ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyPostGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum = append(policyPostGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum, v)
	}
}

const (

	// PolicyPostGeneralNetworkLimitationsMinimumNetworkConnectionNoMinimum captures enum value "No Minimum"
	PolicyPostGeneralNetworkLimitationsMinimumNetworkConnectionNoMinimum string = "No Minimum"

	// PolicyPostGeneralNetworkLimitationsMinimumNetworkConnectionEthernet captures enum value "Ethernet"
	PolicyPostGeneralNetworkLimitationsMinimumNetworkConnectionEthernet string = "Ethernet"
)

// prop value enum
func (m *PolicyPostGeneralNetworkLimitations) validateMinimumNetworkConnectionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyPostGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyPostGeneralNetworkLimitations) validateMinimumNetworkConnection(formats strfmt.Registry) error {
	if swag.IsZero(m.MinimumNetworkConnection) { // not required
		return nil
	}

	// value enum
	if err := m.validateMinimumNetworkConnectionEnum("general"+"."+"network_limitations"+"."+"minimum_network_connection", "body", m.MinimumNetworkConnection); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy post general network limitations based on context it is used
func (m *PolicyPostGeneralNetworkLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPostGeneralNetworkLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPostGeneralNetworkLimitations) UnmarshalBinary(b []byte) error {
	var res PolicyPostGeneralNetworkLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
