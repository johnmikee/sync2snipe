// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VppAssignment vpp assignment
//
// swagger:model vpp_assignment
type VppAssignment struct {

	// ebooks
	Ebooks []*VppAssignmentEbooksItems0 `json:"ebooks"`

	// general
	General *VppAssignmentGeneral `json:"general,omitempty"`

	// ios apps
	IosApps []*VppAssignmentIosAppsItems0 `json:"ios_apps"`

	// mac apps
	MacApps []*VppAssignmentMacAppsItems0 `json:"mac_apps"`

	// scope
	Scope *VppAssignmentScope `json:"scope,omitempty"`
}

// Validate validates this vpp assignment
func (m *VppAssignment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEbooks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIosApps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMacApps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignment) validateEbooks(formats strfmt.Registry) error {
	if swag.IsZero(m.Ebooks) { // not required
		return nil
	}

	for i := 0; i < len(m.Ebooks); i++ {
		if swag.IsZero(m.Ebooks[i]) { // not required
			continue
		}

		if m.Ebooks[i] != nil {
			if err := m.Ebooks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ebooks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ebooks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *VppAssignment) validateIosApps(formats strfmt.Registry) error {
	if swag.IsZero(m.IosApps) { // not required
		return nil
	}

	for i := 0; i < len(m.IosApps); i++ {
		if swag.IsZero(m.IosApps[i]) { // not required
			continue
		}

		if m.IosApps[i] != nil {
			if err := m.IosApps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ios_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ios_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) validateMacApps(formats strfmt.Registry) error {
	if swag.IsZero(m.MacApps) { // not required
		return nil
	}

	for i := 0; i < len(m.MacApps); i++ {
		if swag.IsZero(m.MacApps[i]) { // not required
			continue
		}

		if m.MacApps[i] != nil {
			if err := m.MacApps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment based on the context it is used
func (m *VppAssignment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEbooks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIosApps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacApps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignment) contextValidateEbooks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ebooks); i++ {

		if m.Ebooks[i] != nil {

			if swag.IsZero(m.Ebooks[i]) { // not required
				return nil
			}

			if err := m.Ebooks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ebooks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ebooks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *VppAssignment) contextValidateIosApps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IosApps); i++ {

		if m.IosApps[i] != nil {

			if swag.IsZero(m.IosApps[i]) { // not required
				return nil
			}

			if err := m.IosApps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ios_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ios_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) contextValidateMacApps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MacApps); i++ {

		if m.MacApps[i] != nil {

			if swag.IsZero(m.MacApps[i]) { // not required
				return nil
			}

			if err := m.MacApps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_apps" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_apps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignment) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignment) UnmarshalBinary(b []byte) error {
	var res VppAssignment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentEbooksItems0 vpp assignment ebooks items0
//
// swagger:model VppAssignmentEbooksItems0
type VppAssignmentEbooksItems0 struct {

	// ebook
	Ebook *VppAssignmentEbooksItems0Ebook `json:"ebook,omitempty"`
}

// Validate validates this vpp assignment ebooks items0
func (m *VppAssignmentEbooksItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEbook(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentEbooksItems0) validateEbook(formats strfmt.Registry) error {
	if swag.IsZero(m.Ebook) { // not required
		return nil
	}

	if m.Ebook != nil {
		if err := m.Ebook.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ebook")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ebook")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment ebooks items0 based on the context it is used
func (m *VppAssignmentEbooksItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEbook(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentEbooksItems0) contextValidateEbook(ctx context.Context, formats strfmt.Registry) error {

	if m.Ebook != nil {

		if swag.IsZero(m.Ebook) { // not required
			return nil
		}

		if err := m.Ebook.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ebook")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ebook")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentEbooksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentEbooksItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentEbooksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentEbooksItems0Ebook vpp assignment ebooks items0 ebook
//
// swagger:model VppAssignmentEbooksItems0Ebook
type VppAssignmentEbooksItems0Ebook struct {

	// adam id
	// Example: 1058120411
	AdamID int64 `json:"adam_id,omitempty"`

	// name
	// Example: Algebra 1
	Name string `json:"name,omitempty"`
}

// Validate validates this vpp assignment ebooks items0 ebook
func (m *VppAssignmentEbooksItems0Ebook) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp assignment ebooks items0 ebook based on context it is used
func (m *VppAssignmentEbooksItems0Ebook) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentEbooksItems0Ebook) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentEbooksItems0Ebook) UnmarshalBinary(b []byte) error {
	var res VppAssignmentEbooksItems0Ebook
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentGeneral vpp assignment general
//
// swagger:model VppAssignmentGeneral
type VppAssignmentGeneral struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: 9th Grade VPP Assignments
	// Required: true
	Name *string `json:"name"`

	// vpp admin account id
	// Example: 1
	// Required: true
	VppAdminAccountID *int64 `json:"vpp_admin_account_id"`

	// vpp admin account name
	// Example: Company Name
	VppAdminAccountName string `json:"vpp_admin_account_name,omitempty"`
}

// Validate validates this vpp assignment general
func (m *VppAssignmentGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVppAdminAccountID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *VppAssignmentGeneral) validateVppAdminAccountID(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"vpp_admin_account_id", "body", m.VppAdminAccountID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this vpp assignment general based on context it is used
func (m *VppAssignmentGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentGeneral) UnmarshalBinary(b []byte) error {
	var res VppAssignmentGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentIosAppsItems0 vpp assignment ios apps items0
//
// swagger:model VppAssignmentIosAppsItems0
type VppAssignmentIosAppsItems0 struct {

	// ios app
	IosApp *VppAssignmentIosAppsItems0IosApp `json:"ios_app,omitempty"`
}

// Validate validates this vpp assignment ios apps items0
func (m *VppAssignmentIosAppsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIosApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentIosAppsItems0) validateIosApp(formats strfmt.Registry) error {
	if swag.IsZero(m.IosApp) { // not required
		return nil
	}

	if m.IosApp != nil {
		if err := m.IosApp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ios_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ios_app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment ios apps items0 based on the context it is used
func (m *VppAssignmentIosAppsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIosApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentIosAppsItems0) contextValidateIosApp(ctx context.Context, formats strfmt.Registry) error {

	if m.IosApp != nil {

		if swag.IsZero(m.IosApp) { // not required
			return nil
		}

		if err := m.IosApp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ios_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ios_app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentIosAppsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentIosAppsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentIosAppsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentIosAppsItems0IosApp vpp assignment ios apps items0 ios app
//
// swagger:model VppAssignmentIosAppsItems0IosApp
type VppAssignmentIosAppsItems0IosApp struct {

	// adam id
	// Example: 767319014
	AdamID int64 `json:"adam_id,omitempty"`

	// name
	// Example: Angry Birds
	Name string `json:"name,omitempty"`
}

// Validate validates this vpp assignment ios apps items0 ios app
func (m *VppAssignmentIosAppsItems0IosApp) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp assignment ios apps items0 ios app based on context it is used
func (m *VppAssignmentIosAppsItems0IosApp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentIosAppsItems0IosApp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentIosAppsItems0IosApp) UnmarshalBinary(b []byte) error {
	var res VppAssignmentIosAppsItems0IosApp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentMacAppsItems0 vpp assignment mac apps items0
//
// swagger:model VppAssignmentMacAppsItems0
type VppAssignmentMacAppsItems0 struct {

	// mac app
	MacApp *VppAssignmentMacAppsItems0MacApp `json:"mac_app,omitempty"`
}

// Validate validates this vpp assignment mac apps items0
func (m *VppAssignmentMacAppsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMacApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentMacAppsItems0) validateMacApp(formats strfmt.Registry) error {
	if swag.IsZero(m.MacApp) { // not required
		return nil
	}

	if m.MacApp != nil {
		if err := m.MacApp.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment mac apps items0 based on the context it is used
func (m *VppAssignmentMacAppsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMacApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentMacAppsItems0) contextValidateMacApp(ctx context.Context, formats strfmt.Registry) error {

	if m.MacApp != nil {

		if swag.IsZero(m.MacApp) { // not required
			return nil
		}

		if err := m.MacApp.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentMacAppsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentMacAppsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentMacAppsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentMacAppsItems0MacApp vpp assignment mac apps items0 mac app
//
// swagger:model VppAssignmentMacAppsItems0MacApp
type VppAssignmentMacAppsItems0MacApp struct {

	// adam id
	// Example: 803453959
	AdamID int64 `json:"adam_id,omitempty"`

	// name
	// Example: Slack
	Name string `json:"name,omitempty"`
}

// Validate validates this vpp assignment mac apps items0 mac app
func (m *VppAssignmentMacAppsItems0MacApp) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp assignment mac apps items0 mac app based on context it is used
func (m *VppAssignmentMacAppsItems0MacApp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentMacAppsItems0MacApp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentMacAppsItems0MacApp) UnmarshalBinary(b []byte) error {
	var res VppAssignmentMacAppsItems0MacApp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScope vpp assignment scope
//
// swagger:model VppAssignmentScope
type VppAssignmentScope struct {

	// all jss users
	AllJssUsers bool `json:"all_jss_users,omitempty"`

	// exclusions
	Exclusions *VppAssignmentScopeExclusions `json:"exclusions,omitempty"`

	// jss user groups
	JssUserGroups []*VppAssignmentScopeJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*VppAssignmentScopeJssUsersItems0 `json:"jss_users"`

	// limitations
	Limitations *VppAssignmentScopeLimitations `json:"limitations,omitempty"`
}

// Validate validates this vpp assignment scope
func (m *VppAssignmentScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *VppAssignmentScope) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScope) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope based on the context it is used
func (m *VppAssignmentScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *VppAssignmentScope) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScope) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScope) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeExclusions vpp assignment scope exclusions
//
// swagger:model VppAssignmentScopeExclusions
type VppAssignmentScopeExclusions struct {

	// jss user groups
	JssUserGroups []*VppAssignmentScopeExclusionsJssUserGroupsItems0 `json:"jss_user_groups"`

	// jss users
	JssUsers []*VppAssignmentScopeExclusionsJssUsersItems0 `json:"jss_users"`

	// user groups
	UserGroups []*VppAssignmentScopeExclusionsUserGroupsItems0 `json:"user_groups"`
}

// Validate validates this vpp assignment scope exclusions
func (m *VppAssignmentScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateJssUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJssUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusions) validateJssUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUserGroups); i++ {
		if swag.IsZero(m.JssUserGroups[i]) { // not required
			continue
		}

		if m.JssUserGroups[i] != nil {
			if err := m.JssUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScopeExclusions) validateJssUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.JssUsers) { // not required
		return nil
	}

	for i := 0; i < len(m.JssUsers); i++ {
		if swag.IsZero(m.JssUsers[i]) { // not required
			continue
		}

		if m.JssUsers[i] != nil {
			if err := m.JssUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScopeExclusions) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this vpp assignment scope exclusions based on the context it is used
func (m *VppAssignmentScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateJssUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJssUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusions) contextValidateJssUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUserGroups); i++ {

		if m.JssUserGroups[i] != nil {

			if swag.IsZero(m.JssUserGroups[i]) { // not required
				return nil
			}

			if err := m.JssUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScopeExclusions) contextValidateJssUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JssUsers); i++ {

		if m.JssUsers[i] != nil {

			if swag.IsZero(m.JssUsers[i]) { // not required
				return nil
			}

			if err := m.JssUsers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "jss_users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VppAssignmentScopeExclusions) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeExclusions) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeExclusionsJssUserGroupsItems0 vpp assignment scope exclusions jss user groups items0
//
// swagger:model VppAssignmentScopeExclusionsJssUserGroupsItems0
type VppAssignmentScopeExclusionsJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp assignment scope exclusions jss user groups items0
func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope exclusions jss user groups items0 based on the context it is used
func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeExclusionsJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeExclusionsJssUsersItems0 vpp assignment scope exclusions jss users items0
//
// swagger:model VppAssignmentScopeExclusionsJssUsersItems0
type VppAssignmentScopeExclusionsJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this vpp assignment scope exclusions jss users items0
func (m *VppAssignmentScopeExclusionsJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope exclusions jss users items0 based on the context it is used
func (m *VppAssignmentScopeExclusionsJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeExclusionsJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeExclusionsUserGroupsItems0 vpp assignment scope exclusions user groups items0
//
// swagger:model VppAssignmentScopeExclusionsUserGroupsItems0
type VppAssignmentScopeExclusionsUserGroupsItems0 struct {

	// user group
	UserGroup *VppAssignmentScopeExclusionsUserGroupsItems0UserGroup `json:"user_group,omitempty"`
}

// Validate validates this vpp assignment scope exclusions user groups items0
func (m *VppAssignmentScopeExclusionsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope exclusions user groups items0 based on the context it is used
func (m *VppAssignmentScopeExclusionsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeExclusionsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeExclusionsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeExclusionsUserGroupsItems0UserGroup vpp assignment scope exclusions user groups items0 user group
//
// swagger:model VppAssignmentScopeExclusionsUserGroupsItems0UserGroup
type VppAssignmentScopeExclusionsUserGroupsItems0UserGroup struct {

	// name
	// Example: LDAP User Group Name
	Name string `json:"name,omitempty"`
}

// Validate validates this vpp assignment scope exclusions user groups items0 user group
func (m *VppAssignmentScopeExclusionsUserGroupsItems0UserGroup) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this vpp assignment scope exclusions user groups items0 user group based on context it is used
func (m *VppAssignmentScopeExclusionsUserGroupsItems0UserGroup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsUserGroupsItems0UserGroup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeExclusionsUserGroupsItems0UserGroup) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeExclusionsUserGroupsItems0UserGroup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeJssUserGroupsItems0 vpp assignment scope jss user groups items0
//
// swagger:model VppAssignmentScopeJssUserGroupsItems0
type VppAssignmentScopeJssUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp assignment scope jss user groups items0
func (m *VppAssignmentScopeJssUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeJssUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope jss user groups items0 based on the context it is used
func (m *VppAssignmentScopeJssUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeJssUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeJssUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeJssUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeJssUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeJssUsersItems0 vpp assignment scope jss users items0
//
// swagger:model VppAssignmentScopeJssUsersItems0
type VppAssignmentScopeJssUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this vpp assignment scope jss users items0
func (m *VppAssignmentScopeJssUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeJssUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope jss users items0 based on the context it is used
func (m *VppAssignmentScopeJssUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeJssUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeJssUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeJssUsersItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeJssUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeLimitations vpp assignment scope limitations
//
// swagger:model VppAssignmentScopeLimitations
type VppAssignmentScopeLimitations struct {

	// user groups
	UserGroups []*VppAssignmentScopeLimitationsUserGroupsItems0 `json:"user_groups"`
}

// Validate validates this vpp assignment scope limitations
func (m *VppAssignmentScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeLimitations) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this vpp assignment scope limitations based on the context it is used
func (m *VppAssignmentScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeLimitations) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeLimitations) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// VppAssignmentScopeLimitationsUserGroupsItems0 vpp assignment scope limitations user groups items0
//
// swagger:model VppAssignmentScopeLimitationsUserGroupsItems0
type VppAssignmentScopeLimitationsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this vpp assignment scope limitations user groups items0
func (m *VppAssignmentScopeLimitationsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeLimitationsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this vpp assignment scope limitations user groups items0 based on the context it is used
func (m *VppAssignmentScopeLimitationsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VppAssignmentScopeLimitationsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VppAssignmentScopeLimitationsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VppAssignmentScopeLimitationsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res VppAssignmentScopeLimitationsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
