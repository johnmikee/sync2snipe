// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ComputerHistory computer history
//
// swagger:model computer_history
type ComputerHistory struct {

	// audits
	Audits []*ComputerHistoryAuditsItems0 `json:"audits"`

	// casper imaging logs
	CasperImagingLogs []*ComputerHistoryCasperImagingLogsItems0 `json:"casper_imaging_logs"`

	// casper remote logs
	CasperRemoteLogs []*ComputerHistoryCasperRemoteLogsItems0 `json:"casper_remote_logs"`

	// commands
	Commands *ComputerHistoryCommands `json:"commands,omitempty"`

	// computer usage logs
	ComputerUsageLogs []*ComputerHistoryComputerUsageLogsItems0 `json:"computer_usage_logs"`

	// general
	General *ComputerHistoryGeneral `json:"general,omitempty"`

	// mac app store applications
	MacAppStoreApplications *ComputerHistoryMacAppStoreApplications `json:"mac_app_store_applications,omitempty"`

	// policy logs
	PolicyLogs []*ComputerHistoryPolicyLogsItems0 `json:"policy_logs"`

	// screen sharing logs
	ScreenSharingLogs []*ComputerHistoryScreenSharingLogsItems0 `json:"screen_sharing_logs"`

	// user location
	UserLocation []*ComputerHistoryUserLocationItems0 `json:"user_location"`
}

// Validate validates this computer history
func (m *ComputerHistory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAudits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCasperImagingLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCasperRemoteLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommands(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerUsageLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMacAppStoreApplications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScreenSharingLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserLocation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistory) validateAudits(formats strfmt.Registry) error {
	if swag.IsZero(m.Audits) { // not required
		return nil
	}

	for i := 0; i < len(m.Audits); i++ {
		if swag.IsZero(m.Audits[i]) { // not required
			continue
		}

		if m.Audits[i] != nil {
			if err := m.Audits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("audits" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("audits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateCasperImagingLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.CasperImagingLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.CasperImagingLogs); i++ {
		if swag.IsZero(m.CasperImagingLogs[i]) { // not required
			continue
		}

		if m.CasperImagingLogs[i] != nil {
			if err := m.CasperImagingLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("casper_imaging_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("casper_imaging_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateCasperRemoteLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.CasperRemoteLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.CasperRemoteLogs); i++ {
		if swag.IsZero(m.CasperRemoteLogs[i]) { // not required
			continue
		}

		if m.CasperRemoteLogs[i] != nil {
			if err := m.CasperRemoteLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("casper_remote_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("casper_remote_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateCommands(formats strfmt.Registry) error {
	if swag.IsZero(m.Commands) { // not required
		return nil
	}

	if m.Commands != nil {
		if err := m.Commands.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commands")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("commands")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) validateComputerUsageLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerUsageLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerUsageLogs); i++ {
		if swag.IsZero(m.ComputerUsageLogs[i]) { // not required
			continue
		}

		if m.ComputerUsageLogs[i] != nil {
			if err := m.ComputerUsageLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("computer_usage_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("computer_usage_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) validateMacAppStoreApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.MacAppStoreApplications) { // not required
		return nil
	}

	if m.MacAppStoreApplications != nil {
		if err := m.MacAppStoreApplications.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app_store_applications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app_store_applications")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) validatePolicyLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.PolicyLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.PolicyLogs); i++ {
		if swag.IsZero(m.PolicyLogs[i]) { // not required
			continue
		}

		if m.PolicyLogs[i] != nil {
			if err := m.PolicyLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("policy_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("policy_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateScreenSharingLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.ScreenSharingLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.ScreenSharingLogs); i++ {
		if swag.IsZero(m.ScreenSharingLogs[i]) { // not required
			continue
		}

		if m.ScreenSharingLogs[i] != nil {
			if err := m.ScreenSharingLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("screen_sharing_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("screen_sharing_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) validateUserLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.UserLocation) { // not required
		return nil
	}

	for i := 0; i < len(m.UserLocation); i++ {
		if swag.IsZero(m.UserLocation[i]) { // not required
			continue
		}

		if m.UserLocation[i] != nil {
			if err := m.UserLocation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_location" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("user_location" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this computer history based on the context it is used
func (m *ComputerHistory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAudits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCasperImagingLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCasperRemoteLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCommands(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerUsageLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMacAppStoreApplications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePolicyLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScreenSharingLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistory) contextValidateAudits(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Audits); i++ {

		if m.Audits[i] != nil {

			if swag.IsZero(m.Audits[i]) { // not required
				return nil
			}

			if err := m.Audits[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("audits" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("audits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateCasperImagingLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CasperImagingLogs); i++ {

		if m.CasperImagingLogs[i] != nil {

			if swag.IsZero(m.CasperImagingLogs[i]) { // not required
				return nil
			}

			if err := m.CasperImagingLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("casper_imaging_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("casper_imaging_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateCasperRemoteLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CasperRemoteLogs); i++ {

		if m.CasperRemoteLogs[i] != nil {

			if swag.IsZero(m.CasperRemoteLogs[i]) { // not required
				return nil
			}

			if err := m.CasperRemoteLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("casper_remote_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("casper_remote_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateCommands(ctx context.Context, formats strfmt.Registry) error {

	if m.Commands != nil {

		if swag.IsZero(m.Commands) { // not required
			return nil
		}

		if err := m.Commands.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commands")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("commands")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) contextValidateComputerUsageLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerUsageLogs); i++ {

		if m.ComputerUsageLogs[i] != nil {

			if swag.IsZero(m.ComputerUsageLogs[i]) { // not required
				return nil
			}

			if err := m.ComputerUsageLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("computer_usage_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("computer_usage_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) contextValidateMacAppStoreApplications(ctx context.Context, formats strfmt.Registry) error {

	if m.MacAppStoreApplications != nil {

		if swag.IsZero(m.MacAppStoreApplications) { // not required
			return nil
		}

		if err := m.MacAppStoreApplications.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_app_store_applications")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mac_app_store_applications")
			}
			return err
		}
	}

	return nil
}

func (m *ComputerHistory) contextValidatePolicyLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PolicyLogs); i++ {

		if m.PolicyLogs[i] != nil {

			if swag.IsZero(m.PolicyLogs[i]) { // not required
				return nil
			}

			if err := m.PolicyLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("policy_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("policy_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateScreenSharingLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ScreenSharingLogs); i++ {

		if m.ScreenSharingLogs[i] != nil {

			if swag.IsZero(m.ScreenSharingLogs[i]) { // not required
				return nil
			}

			if err := m.ScreenSharingLogs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("screen_sharing_logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("screen_sharing_logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistory) contextValidateUserLocation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserLocation); i++ {

		if m.UserLocation[i] != nil {

			if swag.IsZero(m.UserLocation[i]) { // not required
				return nil
			}

			if err := m.UserLocation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_location" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("user_location" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistory) UnmarshalBinary(b []byte) error {
	var res ComputerHistory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryAuditsItems0 computer history audits items0
//
// swagger:model ComputerHistoryAuditsItems0
type ComputerHistoryAuditsItems0 struct {

	// audit
	Audit *ComputerHistoryAuditsItems0Audit `json:"audit,omitempty"`
}

// Validate validates this computer history audits items0
func (m *ComputerHistoryAuditsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAudit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryAuditsItems0) validateAudit(formats strfmt.Registry) error {
	if swag.IsZero(m.Audit) { // not required
		return nil
	}

	if m.Audit != nil {
		if err := m.Audit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history audits items0 based on the context it is used
func (m *ComputerHistoryAuditsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAudit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryAuditsItems0) contextValidateAudit(ctx context.Context, formats strfmt.Registry) error {

	if m.Audit != nil {

		if swag.IsZero(m.Audit) { // not required
			return nil
		}

		if err := m.Audit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("audit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("audit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryAuditsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryAuditsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryAuditsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryAuditsItems0Audit computer history audits items0 audit
//
// swagger:model ComputerHistoryAuditsItems0Audit
type ComputerHistoryAuditsItems0Audit struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// event
	// Example: Viewed FileVault Encryption Key
	Event string `json:"event,omitempty"`

	// username
	// Example: Jamf Pro Admin
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history audits items0 audit
func (m *ComputerHistoryAuditsItems0Audit) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history audits items0 audit based on context it is used
func (m *ComputerHistoryAuditsItems0Audit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryAuditsItems0Audit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryAuditsItems0Audit) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryAuditsItems0Audit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCasperImagingLogsItems0 computer history casper imaging logs items0
//
// swagger:model ComputerHistoryCasperImagingLogsItems0
type ComputerHistoryCasperImagingLogsItems0 struct {

	// casper imaging log
	CasperImagingLog *ComputerHistoryCasperImagingLogsItems0CasperImagingLog `json:"casper_imaging_log,omitempty"`
}

// Validate validates this computer history casper imaging logs items0
func (m *ComputerHistoryCasperImagingLogsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCasperImagingLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCasperImagingLogsItems0) validateCasperImagingLog(formats strfmt.Registry) error {
	if swag.IsZero(m.CasperImagingLog) { // not required
		return nil
	}

	if m.CasperImagingLog != nil {
		if err := m.CasperImagingLog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("casper_imaging_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("casper_imaging_log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history casper imaging logs items0 based on the context it is used
func (m *ComputerHistoryCasperImagingLogsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCasperImagingLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCasperImagingLogsItems0) contextValidateCasperImagingLog(ctx context.Context, formats strfmt.Registry) error {

	if m.CasperImagingLog != nil {

		if swag.IsZero(m.CasperImagingLog) { // not required
			return nil
		}

		if err := m.CasperImagingLog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("casper_imaging_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("casper_imaging_log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCasperImagingLogsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCasperImagingLogsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCasperImagingLogsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCasperImagingLogsItems0CasperImagingLog computer history casper imaging logs items0 casper imaging log
//
// swagger:model ComputerHistoryCasperImagingLogsItems0CasperImagingLog
type ComputerHistoryCasperImagingLogsItems0CasperImagingLog struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// status
	// Example: Completed
	Status string `json:"status,omitempty"`
}

// Validate validates this computer history casper imaging logs items0 casper imaging log
func (m *ComputerHistoryCasperImagingLogsItems0CasperImagingLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history casper imaging logs items0 casper imaging log based on context it is used
func (m *ComputerHistoryCasperImagingLogsItems0CasperImagingLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCasperImagingLogsItems0CasperImagingLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCasperImagingLogsItems0CasperImagingLog) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCasperImagingLogsItems0CasperImagingLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCasperRemoteLogsItems0 computer history casper remote logs items0
//
// swagger:model ComputerHistoryCasperRemoteLogsItems0
type ComputerHistoryCasperRemoteLogsItems0 struct {

	// casper remote log
	CasperRemoteLog *ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog `json:"casper_remote_log,omitempty"`
}

// Validate validates this computer history casper remote logs items0
func (m *ComputerHistoryCasperRemoteLogsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCasperRemoteLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCasperRemoteLogsItems0) validateCasperRemoteLog(formats strfmt.Registry) error {
	if swag.IsZero(m.CasperRemoteLog) { // not required
		return nil
	}

	if m.CasperRemoteLog != nil {
		if err := m.CasperRemoteLog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("casper_remote_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("casper_remote_log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history casper remote logs items0 based on the context it is used
func (m *ComputerHistoryCasperRemoteLogsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCasperRemoteLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCasperRemoteLogsItems0) contextValidateCasperRemoteLog(ctx context.Context, formats strfmt.Registry) error {

	if m.CasperRemoteLog != nil {

		if swag.IsZero(m.CasperRemoteLog) { // not required
			return nil
		}

		if err := m.CasperRemoteLog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("casper_remote_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("casper_remote_log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCasperRemoteLogsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCasperRemoteLogsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCasperRemoteLogsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog computer history casper remote logs items0 casper remote log
//
// swagger:model ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog
type ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// status
	// Example: Completed
	Status string `json:"status,omitempty"`
}

// Validate validates this computer history casper remote logs items0 casper remote log
func (m *ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history casper remote logs items0 casper remote log based on context it is used
func (m *ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCasperRemoteLogsItems0CasperRemoteLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommands computer history commands
//
// swagger:model ComputerHistoryCommands
type ComputerHistoryCommands struct {

	// completed
	Completed []*ComputerHistoryCommandsCompletedItems0 `json:"completed"`

	// failed
	Failed []*ComputerHistoryCommandsFailedItems0 `json:"failed"`

	// pending
	Pending []*ComputerHistoryCommandsPendingItems0 `json:"pending"`
}

// Validate validates this computer history commands
func (m *ComputerHistoryCommands) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePending(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommands) validateCompleted(formats strfmt.Registry) error {
	if swag.IsZero(m.Completed) { // not required
		return nil
	}

	for i := 0; i < len(m.Completed); i++ {
		if swag.IsZero(m.Completed[i]) { // not required
			continue
		}

		if m.Completed[i] != nil {
			if err := m.Completed[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "completed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "completed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryCommands) validateFailed(formats strfmt.Registry) error {
	if swag.IsZero(m.Failed) { // not required
		return nil
	}

	for i := 0; i < len(m.Failed); i++ {
		if swag.IsZero(m.Failed[i]) { // not required
			continue
		}

		if m.Failed[i] != nil {
			if err := m.Failed[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "failed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "failed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryCommands) validatePending(formats strfmt.Registry) error {
	if swag.IsZero(m.Pending) { // not required
		return nil
	}

	for i := 0; i < len(m.Pending); i++ {
		if swag.IsZero(m.Pending[i]) { // not required
			continue
		}

		if m.Pending[i] != nil {
			if err := m.Pending[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "pending" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "pending" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this computer history commands based on the context it is used
func (m *ComputerHistoryCommands) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompleted(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePending(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommands) contextValidateCompleted(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Completed); i++ {

		if m.Completed[i] != nil {

			if swag.IsZero(m.Completed[i]) { // not required
				return nil
			}

			if err := m.Completed[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "completed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "completed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryCommands) contextValidateFailed(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Failed); i++ {

		if m.Failed[i] != nil {

			if swag.IsZero(m.Failed[i]) { // not required
				return nil
			}

			if err := m.Failed[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "failed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "failed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryCommands) contextValidatePending(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Pending); i++ {

		if m.Pending[i] != nil {

			if swag.IsZero(m.Pending[i]) { // not required
				return nil
			}

			if err := m.Pending[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("commands" + "." + "pending" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("commands" + "." + "pending" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommands) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommands) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommands
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsCompletedItems0 computer history commands completed items0
//
// swagger:model ComputerHistoryCommandsCompletedItems0
type ComputerHistoryCommandsCompletedItems0 struct {

	// command
	Command *ComputerHistoryCommandsCompletedItems0Command `json:"command,omitempty"`
}

// Validate validates this computer history commands completed items0
func (m *ComputerHistoryCommandsCompletedItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommand(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsCompletedItems0) validateCommand(formats strfmt.Registry) error {
	if swag.IsZero(m.Command) { // not required
		return nil
	}

	if m.Command != nil {
		if err := m.Command.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history commands completed items0 based on the context it is used
func (m *ComputerHistoryCommandsCompletedItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommand(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsCompletedItems0) contextValidateCommand(ctx context.Context, formats strfmt.Registry) error {

	if m.Command != nil {

		if swag.IsZero(m.Command) { // not required
			return nil
		}

		if err := m.Command.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsCompletedItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsCompletedItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsCompletedItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsCompletedItems0Command computer history commands completed items0 command
//
// swagger:model ComputerHistoryCommandsCompletedItems0Command
type ComputerHistoryCommandsCompletedItems0Command struct {

	// completed
	// Example: 2017/07/07 at 6:37 PM
	Completed string `json:"completed,omitempty"`

	// completed epoch
	// Example: 1499470624555
	CompletedEpoch string `json:"completed_epoch,omitempty"`

	// completed utc
	// Example: 2017-07-07T18:37:04.555-0500
	CompletedUtc string `json:"completed_utc,omitempty"`

	// name
	// Example: WiFi Configuration Profile
	Name string `json:"name,omitempty"`

	// username
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history commands completed items0 command
func (m *ComputerHistoryCommandsCompletedItems0Command) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history commands completed items0 command based on context it is used
func (m *ComputerHistoryCommandsCompletedItems0Command) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsCompletedItems0Command) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsCompletedItems0Command) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsCompletedItems0Command
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsFailedItems0 computer history commands failed items0
//
// swagger:model ComputerHistoryCommandsFailedItems0
type ComputerHistoryCommandsFailedItems0 struct {

	// command
	Command *ComputerHistoryCommandsFailedItems0Command `json:"command,omitempty"`
}

// Validate validates this computer history commands failed items0
func (m *ComputerHistoryCommandsFailedItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommand(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsFailedItems0) validateCommand(formats strfmt.Registry) error {
	if swag.IsZero(m.Command) { // not required
		return nil
	}

	if m.Command != nil {
		if err := m.Command.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history commands failed items0 based on the context it is used
func (m *ComputerHistoryCommandsFailedItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommand(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsFailedItems0) contextValidateCommand(ctx context.Context, formats strfmt.Registry) error {

	if m.Command != nil {

		if swag.IsZero(m.Command) { // not required
			return nil
		}

		if err := m.Command.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsFailedItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsFailedItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsFailedItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsFailedItems0Command computer history commands failed items0 command
//
// swagger:model ComputerHistoryCommandsFailedItems0Command
type ComputerHistoryCommandsFailedItems0Command struct {

	// failed
	// Example: 2017/07/07 at 6:38 PM
	Failed string `json:"failed,omitempty"`

	// failed epoch
	// Example: 1499470735555
	FailedEpoch string `json:"failed_epoch,omitempty"`

	// failed utc
	// Example: 2017-07-07T18:38:55.555-0500
	FailedUtc string `json:"failed_utc,omitempty"`

	// issued
	// Example: 2017/07/07 at 6:37 PM
	Issued string `json:"issued,omitempty"`

	// issued epoch
	// Example: 1499470624555
	IssuedEpoch string `json:"issued_epoch,omitempty"`

	// issued utc
	// Example: 2017-07-07T18:37:04.555-0500
	IssuedUtc string `json:"issued_utc,omitempty"`

	// name
	// Example: Install Configuration Profile AD Binding
	Name string `json:"name,omitempty"`

	// status
	// Example: The Directory Binding Account payload could not be installed
	Status string `json:"status,omitempty"`
}

// Validate validates this computer history commands failed items0 command
func (m *ComputerHistoryCommandsFailedItems0Command) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history commands failed items0 command based on context it is used
func (m *ComputerHistoryCommandsFailedItems0Command) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsFailedItems0Command) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsFailedItems0Command) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsFailedItems0Command
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsPendingItems0 computer history commands pending items0
//
// swagger:model ComputerHistoryCommandsPendingItems0
type ComputerHistoryCommandsPendingItems0 struct {

	// command
	Command *ComputerHistoryCommandsPendingItems0Command `json:"command,omitempty"`
}

// Validate validates this computer history commands pending items0
func (m *ComputerHistoryCommandsPendingItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommand(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsPendingItems0) validateCommand(formats strfmt.Registry) error {
	if swag.IsZero(m.Command) { // not required
		return nil
	}

	if m.Command != nil {
		if err := m.Command.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history commands pending items0 based on the context it is used
func (m *ComputerHistoryCommandsPendingItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommand(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryCommandsPendingItems0) contextValidateCommand(ctx context.Context, formats strfmt.Registry) error {

	if m.Command != nil {

		if swag.IsZero(m.Command) { // not required
			return nil
		}

		if err := m.Command.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("command")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("command")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsPendingItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsPendingItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsPendingItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryCommandsPendingItems0Command computer history commands pending items0 command
//
// swagger:model ComputerHistoryCommandsPendingItems0Command
type ComputerHistoryCommandsPendingItems0Command struct {

	// issued
	// Example: 2017/07/07 at 6:37 PM
	Issued string `json:"issued,omitempty"`

	// issued epoch
	// Example: 1499470624555
	IssuedEpoch string `json:"issued_epoch,omitempty"`

	// issued utc
	// Example: 2017-07-07T18:37:04.555-0500
	IssuedUtc string `json:"issued_utc,omitempty"`

	// last push
	// Example: 2017/07/07 at 6:38 PM
	LastPush string `json:"last_push,omitempty"`

	// last push epoch
	// Example: 1499470735555
	LastPushEpoch string `json:"last_push_epoch,omitempty"`

	// last push utc
	// Example: 2017-07-07T18:38:55.555-0500
	LastPushUtc string `json:"last_push_utc,omitempty"`

	// name
	// Example: ProfileList
	Name string `json:"name,omitempty"`

	// status
	// Example: Pending
	Status string `json:"status,omitempty"`

	// username
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history commands pending items0 command
func (m *ComputerHistoryCommandsPendingItems0Command) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history commands pending items0 command based on context it is used
func (m *ComputerHistoryCommandsPendingItems0Command) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryCommandsPendingItems0Command) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryCommandsPendingItems0Command) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryCommandsPendingItems0Command
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryComputerUsageLogsItems0 computer history computer usage logs items0
//
// swagger:model ComputerHistoryComputerUsageLogsItems0
type ComputerHistoryComputerUsageLogsItems0 struct {

	// usage log
	UsageLog *ComputerHistoryComputerUsageLogsItems0UsageLog `json:"usage_log,omitempty"`
}

// Validate validates this computer history computer usage logs items0
func (m *ComputerHistoryComputerUsageLogsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUsageLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryComputerUsageLogsItems0) validateUsageLog(formats strfmt.Registry) error {
	if swag.IsZero(m.UsageLog) { // not required
		return nil
	}

	if m.UsageLog != nil {
		if err := m.UsageLog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage_log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history computer usage logs items0 based on the context it is used
func (m *ComputerHistoryComputerUsageLogsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUsageLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryComputerUsageLogsItems0) contextValidateUsageLog(ctx context.Context, formats strfmt.Registry) error {

	if m.UsageLog != nil {

		if swag.IsZero(m.UsageLog) { // not required
			return nil
		}

		if err := m.UsageLog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("usage_log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryComputerUsageLogsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryComputerUsageLogsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryComputerUsageLogsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryComputerUsageLogsItems0UsageLog computer history computer usage logs items0 usage log
//
// swagger:model ComputerHistoryComputerUsageLogsItems0UsageLog
type ComputerHistoryComputerUsageLogsItems0UsageLog struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// event
	// Example: login
	Event string `json:"event,omitempty"`

	// username
	// Example: Admin
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history computer usage logs items0 usage log
func (m *ComputerHistoryComputerUsageLogsItems0UsageLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history computer usage logs items0 usage log based on context it is used
func (m *ComputerHistoryComputerUsageLogsItems0UsageLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryComputerUsageLogsItems0UsageLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryComputerUsageLogsItems0UsageLog) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryComputerUsageLogsItems0UsageLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryGeneral computer history general
//
// swagger:model ComputerHistoryGeneral
type ComputerHistoryGeneral struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// mac address
	// Example: E0:AC:CB:97:36:G4
	MacAddress string `json:"mac_address,omitempty"`

	// Name of the computer
	// Example: Admins MacBook Pro
	Name string `json:"name,omitempty"`

	// serial number
	// Example: C02Q7KHTGFWF
	SerialNumber string `json:"serial_number,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this computer history general
func (m *ComputerHistoryGeneral) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history general based on context it is used
func (m *ComputerHistoryGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryGeneral) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplications computer history mac app store applications
//
// swagger:model ComputerHistoryMacAppStoreApplications
type ComputerHistoryMacAppStoreApplications struct {

	// failed
	Failed []*ComputerHistoryMacAppStoreApplicationsFailedItems0 `json:"failed"`

	// installed
	Installed []*ComputerHistoryMacAppStoreApplicationsInstalledItems0 `json:"installed"`

	// pending
	Pending []*ComputerHistoryMacAppStoreApplicationsPendingItems0 `json:"pending"`
}

// Validate validates this computer history mac app store applications
func (m *ComputerHistoryMacAppStoreApplications) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstalled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePending(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) validateFailed(formats strfmt.Registry) error {
	if swag.IsZero(m.Failed) { // not required
		return nil
	}

	for i := 0; i < len(m.Failed); i++ {
		if swag.IsZero(m.Failed[i]) { // not required
			continue
		}

		if m.Failed[i] != nil {
			if err := m.Failed[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "failed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "failed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) validateInstalled(formats strfmt.Registry) error {
	if swag.IsZero(m.Installed) { // not required
		return nil
	}

	for i := 0; i < len(m.Installed); i++ {
		if swag.IsZero(m.Installed[i]) { // not required
			continue
		}

		if m.Installed[i] != nil {
			if err := m.Installed[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "installed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "installed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) validatePending(formats strfmt.Registry) error {
	if swag.IsZero(m.Pending) { // not required
		return nil
	}

	for i := 0; i < len(m.Pending); i++ {
		if swag.IsZero(m.Pending[i]) { // not required
			continue
		}

		if m.Pending[i] != nil {
			if err := m.Pending[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "pending" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "pending" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this computer history mac app store applications based on the context it is used
func (m *ComputerHistoryMacAppStoreApplications) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailed(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstalled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePending(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) contextValidateFailed(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Failed); i++ {

		if m.Failed[i] != nil {

			if swag.IsZero(m.Failed[i]) { // not required
				return nil
			}

			if err := m.Failed[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "failed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "failed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) contextValidateInstalled(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Installed); i++ {

		if m.Installed[i] != nil {

			if swag.IsZero(m.Installed[i]) { // not required
				return nil
			}

			if err := m.Installed[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "installed" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "installed" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerHistoryMacAppStoreApplications) contextValidatePending(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Pending); i++ {

		if m.Pending[i] != nil {

			if swag.IsZero(m.Pending[i]) { // not required
				return nil
			}

			if err := m.Pending[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mac_app_store_applications" + "." + "pending" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mac_app_store_applications" + "." + "pending" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplications) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplications) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplications
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsFailedItems0 computer history mac app store applications failed items0
//
// swagger:model ComputerHistoryMacAppStoreApplicationsFailedItems0
type ComputerHistoryMacAppStoreApplicationsFailedItems0 struct {

	// app
	App *ComputerHistoryMacAppStoreApplicationsFailedItems0App `json:"app,omitempty"`
}

// Validate validates this computer history mac app store applications failed items0
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) validateApp(formats strfmt.Registry) error {
	if swag.IsZero(m.App) { // not required
		return nil
	}

	if m.App != nil {
		if err := m.App.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history mac app store applications failed items0 based on the context it is used
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) contextValidateApp(ctx context.Context, formats strfmt.Registry) error {

	if m.App != nil {

		if swag.IsZero(m.App) { // not required
			return nil
		}

		if err := m.App.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsFailedItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsFailedItems0App computer history mac app store applications failed items0 app
//
// swagger:model ComputerHistoryMacAppStoreApplicationsFailedItems0App
type ComputerHistoryMacAppStoreApplicationsFailedItems0App struct {

	// deployed
	// Example: 2 minutes ago
	Deployed string `json:"deployed,omitempty"`

	// deployed epoch
	// Example: 1499470624555
	DeployedEpoch int64 `json:"deployed_epoch,omitempty"`

	// deployed utc
	// Example: 2018-02-22T16:55:14.000-0600
	DeployedUtc string `json:"deployed_utc,omitempty"`

	// last update
	// Example: 2 minutes ago
	LastUpdate string `json:"last_update,omitempty"`

	// last update epoch
	// Example: 1499470624555
	LastUpdateEpoch int64 `json:"last_update_epoch,omitempty"`

	// last update utc
	// Example: 2018-02-22T16:55:14.000-0600
	LastUpdateUtc string `json:"last_update_utc,omitempty"`

	// name
	// Example: Xcode
	Name string `json:"name,omitempty"`

	// status
	// Example: Failed
	Status string `json:"status,omitempty"`

	// version
	// Example: 8.3.2
	Version string `json:"version,omitempty"`
}

// Validate validates this computer history mac app store applications failed items0 app
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0App) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history mac app store applications failed items0 app based on context it is used
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0App) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0App) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsFailedItems0App) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsFailedItems0App
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsInstalledItems0 computer history mac app store applications installed items0
//
// swagger:model ComputerHistoryMacAppStoreApplicationsInstalledItems0
type ComputerHistoryMacAppStoreApplicationsInstalledItems0 struct {

	// app
	App *ComputerHistoryMacAppStoreApplicationsInstalledItems0App `json:"app,omitempty"`
}

// Validate validates this computer history mac app store applications installed items0
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) validateApp(formats strfmt.Registry) error {
	if swag.IsZero(m.App) { // not required
		return nil
	}

	if m.App != nil {
		if err := m.App.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history mac app store applications installed items0 based on the context it is used
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) contextValidateApp(ctx context.Context, formats strfmt.Registry) error {

	if m.App != nil {

		if swag.IsZero(m.App) { // not required
			return nil
		}

		if err := m.App.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsInstalledItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsInstalledItems0App computer history mac app store applications installed items0 app
//
// swagger:model ComputerHistoryMacAppStoreApplicationsInstalledItems0App
type ComputerHistoryMacAppStoreApplicationsInstalledItems0App struct {

	// name
	// Example: Xcode
	Name string `json:"name,omitempty"`

	// size mb
	// Example: 150
	SizeMb string `json:"size_mb,omitempty"`

	// version
	// Example: 8.3.3
	Version string `json:"version,omitempty"`
}

// Validate validates this computer history mac app store applications installed items0 app
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0App) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history mac app store applications installed items0 app based on context it is used
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0App) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0App) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsInstalledItems0App) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsInstalledItems0App
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsPendingItems0 computer history mac app store applications pending items0
//
// swagger:model ComputerHistoryMacAppStoreApplicationsPendingItems0
type ComputerHistoryMacAppStoreApplicationsPendingItems0 struct {

	// app
	App *ComputerHistoryMacAppStoreApplicationsPendingItems0App `json:"app,omitempty"`
}

// Validate validates this computer history mac app store applications pending items0
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) validateApp(formats strfmt.Registry) error {
	if swag.IsZero(m.App) { // not required
		return nil
	}

	if m.App != nil {
		if err := m.App.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history mac app store applications pending items0 based on the context it is used
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApp(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) contextValidateApp(ctx context.Context, formats strfmt.Registry) error {

	if m.App != nil {

		if swag.IsZero(m.App) { // not required
			return nil
		}

		if err := m.App.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("app")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("app")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsPendingItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryMacAppStoreApplicationsPendingItems0App computer history mac app store applications pending items0 app
//
// swagger:model ComputerHistoryMacAppStoreApplicationsPendingItems0App
type ComputerHistoryMacAppStoreApplicationsPendingItems0App struct {

	// deployed
	// Example: 2 minutes ago
	Deployed string `json:"deployed,omitempty"`

	// deployed epoch
	// Example: 1499470624555
	DeployedEpoch int64 `json:"deployed_epoch,omitempty"`

	// deployed utc
	// Example: 2018-02-22T16:55:14.000-0600
	DeployedUtc string `json:"deployed_utc,omitempty"`

	// last update
	// Example: 2 minutes ago
	LastUpdate string `json:"last_update,omitempty"`

	// last update epoch
	// Example: 1499470624555
	LastUpdateEpoch int64 `json:"last_update_epoch,omitempty"`

	// last update utc
	// Example: 2018-02-22T16:55:14.000-0600
	LastUpdateUtc string `json:"last_update_utc,omitempty"`

	// name
	// Example: Xcode
	Name string `json:"name,omitempty"`

	// version
	// Example: 8.3.2
	Version string `json:"version,omitempty"`
}

// Validate validates this computer history mac app store applications pending items0 app
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0App) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history mac app store applications pending items0 app based on context it is used
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0App) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0App) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryMacAppStoreApplicationsPendingItems0App) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryMacAppStoreApplicationsPendingItems0App
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryPolicyLogsItems0 computer history policy logs items0
//
// swagger:model ComputerHistoryPolicyLogsItems0
type ComputerHistoryPolicyLogsItems0 struct {

	// policy log
	PolicyLog *ComputerHistoryPolicyLogsItems0PolicyLog `json:"policy_log,omitempty"`
}

// Validate validates this computer history policy logs items0
func (m *ComputerHistoryPolicyLogsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePolicyLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryPolicyLogsItems0) validatePolicyLog(formats strfmt.Registry) error {
	if swag.IsZero(m.PolicyLog) { // not required
		return nil
	}

	if m.PolicyLog != nil {
		if err := m.PolicyLog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("policy_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("policy_log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history policy logs items0 based on the context it is used
func (m *ComputerHistoryPolicyLogsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePolicyLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryPolicyLogsItems0) contextValidatePolicyLog(ctx context.Context, formats strfmt.Registry) error {

	if m.PolicyLog != nil {

		if swag.IsZero(m.PolicyLog) { // not required
			return nil
		}

		if err := m.PolicyLog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("policy_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("policy_log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryPolicyLogsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryPolicyLogsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryPolicyLogsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryPolicyLogsItems0PolicyLog computer history policy logs items0 policy log
//
// swagger:model ComputerHistoryPolicyLogsItems0PolicyLog
type ComputerHistoryPolicyLogsItems0PolicyLog struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// policy id
	// Example: 1
	PolicyID int64 `json:"policy_id,omitempty"`

	// policy name
	// Example: Update Inventory
	PolicyName string `json:"policy_name,omitempty"`

	// status
	// Example: Completed
	Status string `json:"status,omitempty"`

	// username
	// Example: Username
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history policy logs items0 policy log
func (m *ComputerHistoryPolicyLogsItems0PolicyLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history policy logs items0 policy log based on context it is used
func (m *ComputerHistoryPolicyLogsItems0PolicyLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryPolicyLogsItems0PolicyLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryPolicyLogsItems0PolicyLog) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryPolicyLogsItems0PolicyLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryScreenSharingLogsItems0 computer history screen sharing logs items0
//
// swagger:model ComputerHistoryScreenSharingLogsItems0
type ComputerHistoryScreenSharingLogsItems0 struct {

	// screen sharing log
	ScreenSharingLog *ComputerHistoryScreenSharingLogsItems0ScreenSharingLog `json:"screen_sharing_log,omitempty"`
}

// Validate validates this computer history screen sharing logs items0
func (m *ComputerHistoryScreenSharingLogsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateScreenSharingLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryScreenSharingLogsItems0) validateScreenSharingLog(formats strfmt.Registry) error {
	if swag.IsZero(m.ScreenSharingLog) { // not required
		return nil
	}

	if m.ScreenSharingLog != nil {
		if err := m.ScreenSharingLog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("screen_sharing_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("screen_sharing_log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history screen sharing logs items0 based on the context it is used
func (m *ComputerHistoryScreenSharingLogsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateScreenSharingLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryScreenSharingLogsItems0) contextValidateScreenSharingLog(ctx context.Context, formats strfmt.Registry) error {

	if m.ScreenSharingLog != nil {

		if swag.IsZero(m.ScreenSharingLog) { // not required
			return nil
		}

		if err := m.ScreenSharingLog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("screen_sharing_log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("screen_sharing_log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryScreenSharingLogsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryScreenSharingLogsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryScreenSharingLogsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryScreenSharingLogsItems0ScreenSharingLog computer history screen sharing logs items0 screen sharing log
//
// swagger:model ComputerHistoryScreenSharingLogsItems0ScreenSharingLog
type ComputerHistoryScreenSharingLogsItems0ScreenSharingLog struct {

	// date time
	// Example: 2017-07-07 18:37:04
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// details
	// Example: admin authenticated to screen share with computer at 10.1.1.1
	Details string `json:"details,omitempty"`

	// status
	// Example: Completed
	Status string `json:"status,omitempty"`
}

// Validate validates this computer history screen sharing logs items0 screen sharing log
func (m *ComputerHistoryScreenSharingLogsItems0ScreenSharingLog) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history screen sharing logs items0 screen sharing log based on context it is used
func (m *ComputerHistoryScreenSharingLogsItems0ScreenSharingLog) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryScreenSharingLogsItems0ScreenSharingLog) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryScreenSharingLogsItems0ScreenSharingLog) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryScreenSharingLogsItems0ScreenSharingLog
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryUserLocationItems0 computer history user location items0
//
// swagger:model ComputerHistoryUserLocationItems0
type ComputerHistoryUserLocationItems0 struct {

	// location
	Location *ComputerHistoryUserLocationItems0Location `json:"location,omitempty"`
}

// Validate validates this computer history user location items0
func (m *ComputerHistoryUserLocationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryUserLocationItems0) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer history user location items0 based on the context it is used
func (m *ComputerHistoryUserLocationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerHistoryUserLocationItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {

		if swag.IsZero(m.Location) { // not required
			return nil
		}

		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryUserLocationItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryUserLocationItems0) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryUserLocationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerHistoryUserLocationItems0Location computer history user location items0 location
//
// swagger:model ComputerHistoryUserLocationItems0Location
type ComputerHistoryUserLocationItems0Location struct {

	// building
	// Example: Block D
	Building string `json:"building,omitempty"`

	// date time
	// Example: 2017/07/07 at 6:37 PM
	DateTime string `json:"date_time,omitempty"`

	// date time epoch
	// Example: 1499470624555
	DateTimeEpoch string `json:"date_time_epoch,omitempty"`

	// date time utc
	// Example: 2017-07-07T18:37:04.555-0500
	DateTimeUtc string `json:"date_time_utc,omitempty"`

	// department
	// Example: Information Technology
	Department string `json:"department,omitempty"`

	// email address
	// Example: betty.johnson@company.com
	EmailAddress string `json:"email_address,omitempty"`

	// full name
	// Example: Betty Johnson
	FullName string `json:"full_name,omitempty"`

	// phone number
	// Example: 555-555-5555
	PhoneNumber string `json:"phone_number,omitempty"`

	// position
	// Example: Chief of Everything
	Position string `json:"position,omitempty"`

	// room
	// Example: 134
	Room string `json:"room,omitempty"`

	// username
	// Example: Betty.Johnson
	Username string `json:"username,omitempty"`
}

// Validate validates this computer history user location items0 location
func (m *ComputerHistoryUserLocationItems0Location) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this computer history user location items0 location based on context it is used
func (m *ComputerHistoryUserLocationItems0Location) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerHistoryUserLocationItems0Location) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerHistoryUserLocationItems0Location) UnmarshalBinary(b []byte) error {
	var res ComputerHistoryUserLocationItems0Location
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
