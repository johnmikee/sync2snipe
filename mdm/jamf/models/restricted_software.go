// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RestrictedSoftware restricted software
//
// swagger:model restricted_software
type RestrictedSoftware struct {

	// general
	General *RestrictedSoftwareGeneral `json:"general,omitempty"`

	// scope
	Scope *RestrictedSoftwareScope `json:"scope,omitempty"`
}

// Validate validates this restricted software
func (m *RestrictedSoftware) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftware) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *RestrictedSoftware) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software based on the context it is used
func (m *RestrictedSoftware) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftware) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *RestrictedSoftware) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftware) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftware) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftware
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareGeneral restricted software general
//
// swagger:model RestrictedSoftwareGeneral
type RestrictedSoftwareGeneral struct {

	// delete executable
	DeleteExecutable bool `json:"delete_executable,omitempty"`

	// display message
	// Example: High Sierra is not yet supported, check Self Service after public release.
	DisplayMessage string `json:"display_message,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// kill process
	KillProcess bool `json:"kill_process,omitempty"`

	// match exact process name
	MatchExactProcessName bool `json:"match_exact_process_name,omitempty"`

	// Name of the restricted software
	// Example: Restrict High Sierra
	// Required: true
	Name *string `json:"name"`

	// process name
	// Example: Install macOS High Sierra.app
	// Required: true
	ProcessName *string `json:"process_name"`

	// send notification
	SendNotification bool `json:"send_notification,omitempty"`

	// site
	Site *SiteObject `json:"site,omitempty"`
}

// Validate validates this restricted software general
func (m *RestrictedSoftwareGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *RestrictedSoftwareGeneral) validateProcessName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"process_name", "body", m.ProcessName); err != nil {
		return err
	}

	return nil
}

func (m *RestrictedSoftwareGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software general based on the context it is used
func (m *RestrictedSoftwareGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareGeneral) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScope restricted software scope
//
// swagger:model RestrictedSoftwareScope
type RestrictedSoftwareScope struct {

	// all computers
	AllComputers bool `json:"all_computers,omitempty"`

	// buildings
	Buildings []*RestrictedSoftwareScopeBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*RestrictedSoftwareScopeComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*RestrictedSoftwareScopeComputersItems0 `json:"computers"`

	// departments
	Departments []*RestrictedSoftwareScopeDepartmentsItems0 `json:"departments"`

	// exclusions
	Exclusions *RestrictedSoftwareScopeExclusions `json:"exclusions,omitempty"`
}

// Validate validates this restricted software scope
func (m *RestrictedSoftwareScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScope) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope based on the context it is used
func (m *RestrictedSoftwareScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScope) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScope) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeBuildingsItems0 restricted software scope buildings items0
//
// swagger:model RestrictedSoftwareScopeBuildingsItems0
type RestrictedSoftwareScopeBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this restricted software scope buildings items0
func (m *RestrictedSoftwareScopeBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope buildings items0 based on the context it is used
func (m *RestrictedSoftwareScopeBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeComputerGroupsItems0 restricted software scope computer groups items0
//
// swagger:model RestrictedSoftwareScopeComputerGroupsItems0
type RestrictedSoftwareScopeComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this restricted software scope computer groups items0
func (m *RestrictedSoftwareScopeComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope computer groups items0 based on the context it is used
func (m *RestrictedSoftwareScopeComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeComputersItems0 restricted software scope computers items0
//
// swagger:model RestrictedSoftwareScopeComputersItems0
type RestrictedSoftwareScopeComputersItems0 struct {

	// computer
	Computer *IDName `json:"computer,omitempty"`
}

// Validate validates this restricted software scope computers items0
func (m *RestrictedSoftwareScopeComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope computers items0 based on the context it is used
func (m *RestrictedSoftwareScopeComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeComputersItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeDepartmentsItems0 restricted software scope departments items0
//
// swagger:model RestrictedSoftwareScopeDepartmentsItems0
type RestrictedSoftwareScopeDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this restricted software scope departments items0
func (m *RestrictedSoftwareScopeDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope departments items0 based on the context it is used
func (m *RestrictedSoftwareScopeDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusions restricted software scope exclusions
//
// swagger:model RestrictedSoftwareScopeExclusions
type RestrictedSoftwareScopeExclusions struct {

	// buildings
	Buildings []*RestrictedSoftwareScopeExclusionsBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*RestrictedSoftwareScopeExclusionsComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*RestrictedSoftwareScopeExclusionsComputersItems0 `json:"computers"`

	// departments
	Departments []*RestrictedSoftwareScopeExclusionsDepartmentsItems0 `json:"departments"`

	// users
	Users []*RestrictedSoftwareScopeExclusionsUsersItems0 `json:"users"`
}

// Validate validates this restricted software scope exclusions
func (m *RestrictedSoftwareScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusions) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions based on the context it is used
func (m *RestrictedSoftwareScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusions) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestrictedSoftwareScopeExclusions) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusions) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusionsBuildingsItems0 restricted software scope exclusions buildings items0
//
// swagger:model RestrictedSoftwareScopeExclusionsBuildingsItems0
type RestrictedSoftwareScopeExclusionsBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this restricted software scope exclusions buildings items0
func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions buildings items0 based on the context it is used
func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusionsBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusionsComputerGroupsItems0 restricted software scope exclusions computer groups items0
//
// swagger:model RestrictedSoftwareScopeExclusionsComputerGroupsItems0
type RestrictedSoftwareScopeExclusionsComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this restricted software scope exclusions computer groups items0
func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions computer groups items0 based on the context it is used
func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusionsComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusionsComputersItems0 restricted software scope exclusions computers items0
//
// swagger:model RestrictedSoftwareScopeExclusionsComputersItems0
type RestrictedSoftwareScopeExclusionsComputersItems0 struct {

	// computer
	Computer *IDName `json:"computer,omitempty"`
}

// Validate validates this restricted software scope exclusions computers items0
func (m *RestrictedSoftwareScopeExclusionsComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions computers items0 based on the context it is used
func (m *RestrictedSoftwareScopeExclusionsComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsComputersItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusionsComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusionsDepartmentsItems0 restricted software scope exclusions departments items0
//
// swagger:model RestrictedSoftwareScopeExclusionsDepartmentsItems0
type RestrictedSoftwareScopeExclusionsDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this restricted software scope exclusions departments items0
func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions departments items0 based on the context it is used
func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusionsDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// RestrictedSoftwareScopeExclusionsUsersItems0 restricted software scope exclusions users items0
//
// swagger:model RestrictedSoftwareScopeExclusionsUsersItems0
type RestrictedSoftwareScopeExclusionsUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this restricted software scope exclusions users items0
func (m *RestrictedSoftwareScopeExclusionsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restricted software scope exclusions users items0 based on the context it is used
func (m *RestrictedSoftwareScopeExclusionsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestrictedSoftwareScopeExclusionsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestrictedSoftwareScopeExclusionsUsersItems0) UnmarshalBinary(b []byte) error {
	var res RestrictedSoftwareScopeExclusionsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
