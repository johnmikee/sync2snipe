// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Policy policy
//
// swagger:model policy
type Policy struct {

	// account maintenance
	AccountMaintenance *PolicyAccountMaintenance `json:"account_maintenance,omitempty"`

	// disk encryption
	DiskEncryption *PolicyDiskEncryption `json:"disk_encryption,omitempty"`

	// dock items
	DockItems []*PolicyDockItemsItems0 `json:"dock_items"`

	// files processes
	FilesProcesses *PolicyFilesProcesses `json:"files_processes,omitempty"`

	// general
	General *PolicyGeneral `json:"general,omitempty"`

	// maintenance
	Maintenance *PolicyMaintenance `json:"maintenance,omitempty"`

	// package configuration
	PackageConfiguration *PolicyPackageConfiguration `json:"package_configuration,omitempty"`

	// printers
	Printers []*PolicyPrintersItems0 `json:"printers"`

	// scope
	Scope *PolicyScope `json:"scope,omitempty"`

	// scripts
	Scripts *PolicyScripts `json:"scripts,omitempty"`

	// self service
	SelfService *PolicySelfService `json:"self_service,omitempty"`

	// user interaction
	UserInteraction *PolicyUserInteraction `json:"user_interaction,omitempty"`
}

// Validate validates this policy
func (m *Policy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountMaintenance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskEncryption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDockItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesProcesses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaintenance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrinters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScripts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserInteraction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Policy) validateAccountMaintenance(formats strfmt.Registry) error {
	if swag.IsZero(m.AccountMaintenance) { // not required
		return nil
	}

	if m.AccountMaintenance != nil {
		if err := m.AccountMaintenance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateDiskEncryption(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskEncryption) { // not required
		return nil
	}

	if m.DiskEncryption != nil {
		if err := m.DiskEncryption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disk_encryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disk_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateDockItems(formats strfmt.Registry) error {
	if swag.IsZero(m.DockItems) { // not required
		return nil
	}

	for i := 0; i < len(m.DockItems); i++ {
		if swag.IsZero(m.DockItems[i]) { // not required
			continue
		}

		if m.DockItems[i] != nil {
			if err := m.DockItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dock_items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dock_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Policy) validateFilesProcesses(formats strfmt.Registry) error {
	if swag.IsZero(m.FilesProcesses) { // not required
		return nil
	}

	if m.FilesProcesses != nil {
		if err := m.FilesProcesses.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("files_processes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("files_processes")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateGeneral(formats strfmt.Registry) error {
	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateMaintenance(formats strfmt.Registry) error {
	if swag.IsZero(m.Maintenance) { // not required
		return nil
	}

	if m.Maintenance != nil {
		if err := m.Maintenance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("maintenance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("maintenance")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validatePackageConfiguration(formats strfmt.Registry) error {
	if swag.IsZero(m.PackageConfiguration) { // not required
		return nil
	}

	if m.PackageConfiguration != nil {
		if err := m.PackageConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("package_configuration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("package_configuration")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validatePrinters(formats strfmt.Registry) error {
	if swag.IsZero(m.Printers) { // not required
		return nil
	}

	for i := 0; i < len(m.Printers); i++ {
		if swag.IsZero(m.Printers[i]) { // not required
			continue
		}

		if m.Printers[i] != nil {
			if err := m.Printers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("printers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("printers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Policy) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	if m.Scope != nil {
		if err := m.Scope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateScripts(formats strfmt.Registry) error {
	if swag.IsZero(m.Scripts) { // not required
		return nil
	}

	if m.Scripts != nil {
		if err := m.Scripts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scripts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scripts")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateSelfService(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfService) { // not required
		return nil
	}

	if m.SelfService != nil {
		if err := m.SelfService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) validateUserInteraction(formats strfmt.Registry) error {
	if swag.IsZero(m.UserInteraction) { // not required
		return nil
	}

	if m.UserInteraction != nil {
		if err := m.UserInteraction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy based on the context it is used
func (m *Policy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccountMaintenance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDiskEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDockItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilesProcesses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeneral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaintenance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePackageConfiguration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrinters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScripts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserInteraction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Policy) contextValidateAccountMaintenance(ctx context.Context, formats strfmt.Registry) error {

	if m.AccountMaintenance != nil {

		if swag.IsZero(m.AccountMaintenance) { // not required
			return nil
		}

		if err := m.AccountMaintenance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateDiskEncryption(ctx context.Context, formats strfmt.Registry) error {

	if m.DiskEncryption != nil {

		if swag.IsZero(m.DiskEncryption) { // not required
			return nil
		}

		if err := m.DiskEncryption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disk_encryption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disk_encryption")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateDockItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DockItems); i++ {

		if m.DockItems[i] != nil {

			if swag.IsZero(m.DockItems[i]) { // not required
				return nil
			}

			if err := m.DockItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dock_items" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dock_items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Policy) contextValidateFilesProcesses(ctx context.Context, formats strfmt.Registry) error {

	if m.FilesProcesses != nil {

		if swag.IsZero(m.FilesProcesses) { // not required
			return nil
		}

		if err := m.FilesProcesses.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("files_processes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("files_processes")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateGeneral(ctx context.Context, formats strfmt.Registry) error {

	if m.General != nil {

		if swag.IsZero(m.General) { // not required
			return nil
		}

		if err := m.General.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateMaintenance(ctx context.Context, formats strfmt.Registry) error {

	if m.Maintenance != nil {

		if swag.IsZero(m.Maintenance) { // not required
			return nil
		}

		if err := m.Maintenance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("maintenance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("maintenance")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidatePackageConfiguration(ctx context.Context, formats strfmt.Registry) error {

	if m.PackageConfiguration != nil {

		if swag.IsZero(m.PackageConfiguration) { // not required
			return nil
		}

		if err := m.PackageConfiguration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("package_configuration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("package_configuration")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidatePrinters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Printers); i++ {

		if m.Printers[i] != nil {

			if swag.IsZero(m.Printers[i]) { // not required
				return nil
			}

			if err := m.Printers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("printers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("printers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Policy) contextValidateScope(ctx context.Context, formats strfmt.Registry) error {

	if m.Scope != nil {

		if swag.IsZero(m.Scope) { // not required
			return nil
		}

		if err := m.Scope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateScripts(ctx context.Context, formats strfmt.Registry) error {

	if m.Scripts != nil {

		if swag.IsZero(m.Scripts) { // not required
			return nil
		}

		if err := m.Scripts.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scripts")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scripts")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateSelfService(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfService != nil {

		if swag.IsZero(m.SelfService) { // not required
			return nil
		}

		if err := m.SelfService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service")
			}
			return err
		}
	}

	return nil
}

func (m *Policy) contextValidateUserInteraction(ctx context.Context, formats strfmt.Registry) error {

	if m.UserInteraction != nil {

		if swag.IsZero(m.UserInteraction) { // not required
			return nil
		}

		if err := m.UserInteraction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_interaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_interaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Policy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Policy) UnmarshalBinary(b []byte) error {
	var res Policy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenance policy account maintenance
//
// swagger:model PolicyAccountMaintenance
type PolicyAccountMaintenance struct {

	// accounts
	Accounts []*PolicyAccountMaintenanceAccountsItems0 `json:"accounts"`

	// directory bindings
	DirectoryBindings []*PolicyAccountMaintenanceDirectoryBindingsItems0 `json:"directory_bindings"`

	// management account
	ManagementAccount *PolicyAccountMaintenanceManagementAccount `json:"management_account,omitempty"`

	// open firmware efi password
	OpenFirmwareEfiPassword *PolicyAccountMaintenanceOpenFirmwareEfiPassword `json:"open_firmware_efi_password,omitempty"`
}

// Validate validates this policy account maintenance
func (m *PolicyAccountMaintenance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectoryBindings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenFirmwareEfiPassword(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenance) validateAccounts(formats strfmt.Registry) error {
	if swag.IsZero(m.Accounts) { // not required
		return nil
	}

	for i := 0; i < len(m.Accounts); i++ {
		if swag.IsZero(m.Accounts[i]) { // not required
			continue
		}

		if m.Accounts[i] != nil {
			if err := m.Accounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_maintenance" + "." + "accounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("account_maintenance" + "." + "accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyAccountMaintenance) validateDirectoryBindings(formats strfmt.Registry) error {
	if swag.IsZero(m.DirectoryBindings) { // not required
		return nil
	}

	for i := 0; i < len(m.DirectoryBindings); i++ {
		if swag.IsZero(m.DirectoryBindings[i]) { // not required
			continue
		}

		if m.DirectoryBindings[i] != nil {
			if err := m.DirectoryBindings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_maintenance" + "." + "directory_bindings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("account_maintenance" + "." + "directory_bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyAccountMaintenance) validateManagementAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementAccount) { // not required
		return nil
	}

	if m.ManagementAccount != nil {
		if err := m.ManagementAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance" + "." + "management_account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance" + "." + "management_account")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenance) validateOpenFirmwareEfiPassword(formats strfmt.Registry) error {
	if swag.IsZero(m.OpenFirmwareEfiPassword) { // not required
		return nil
	}

	if m.OpenFirmwareEfiPassword != nil {
		if err := m.OpenFirmwareEfiPassword.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance" + "." + "open_firmware_efi_password")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance" + "." + "open_firmware_efi_password")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy account maintenance based on the context it is used
func (m *PolicyAccountMaintenance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDirectoryBindings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenFirmwareEfiPassword(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenance) contextValidateAccounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Accounts); i++ {

		if m.Accounts[i] != nil {

			if swag.IsZero(m.Accounts[i]) { // not required
				return nil
			}

			if err := m.Accounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_maintenance" + "." + "accounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("account_maintenance" + "." + "accounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyAccountMaintenance) contextValidateDirectoryBindings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DirectoryBindings); i++ {

		if m.DirectoryBindings[i] != nil {

			if swag.IsZero(m.DirectoryBindings[i]) { // not required
				return nil
			}

			if err := m.DirectoryBindings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("account_maintenance" + "." + "directory_bindings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("account_maintenance" + "." + "directory_bindings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyAccountMaintenance) contextValidateManagementAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementAccount != nil {

		if swag.IsZero(m.ManagementAccount) { // not required
			return nil
		}

		if err := m.ManagementAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance" + "." + "management_account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance" + "." + "management_account")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenance) contextValidateOpenFirmwareEfiPassword(ctx context.Context, formats strfmt.Registry) error {

	if m.OpenFirmwareEfiPassword != nil {

		if swag.IsZero(m.OpenFirmwareEfiPassword) { // not required
			return nil
		}

		if err := m.OpenFirmwareEfiPassword.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account_maintenance" + "." + "open_firmware_efi_password")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account_maintenance" + "." + "open_firmware_efi_password")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenance) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenanceAccountsItems0 policy account maintenance accounts items0
//
// swagger:model PolicyAccountMaintenanceAccountsItems0
type PolicyAccountMaintenanceAccountsItems0 struct {

	// account
	Account *PolicyAccountMaintenanceAccountsItems0Account `json:"account,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy account maintenance accounts items0
func (m *PolicyAccountMaintenanceAccountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenanceAccountsItems0) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenanceAccountsItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy account maintenance accounts items0 based on the context it is used
func (m *PolicyAccountMaintenanceAccountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenanceAccountsItems0) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.Account != nil {

		if swag.IsZero(m.Account) { // not required
			return nil
		}

		if err := m.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("account")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenanceAccountsItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenanceAccountsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenanceAccountsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenanceAccountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenanceAccountsItems0Account policy account maintenance accounts items0 account
//
// swagger:model PolicyAccountMaintenanceAccountsItems0Account
type PolicyAccountMaintenanceAccountsItems0Account struct {

	// action
	// Enum: [Create Reset Delete DisableFileVault]
	Action string `json:"action,omitempty"`

	// admin
	Admin bool `json:"admin,omitempty"`

	// archive home directory
	ArchiveHomeDirectory bool `json:"archive_home_directory,omitempty"`

	// archive home directory to
	// Example: /Users/Deleted Users/admin.dmg
	ArchiveHomeDirectoryTo string `json:"archive_home_directory_to,omitempty"`

	// filevault enabled
	FilevaultEnabled bool `json:"filevault_enabled,omitempty"`

	// home
	// Example: /Users/admin
	Home string `json:"home,omitempty"`

	// password
	Password string `json:"password,omitempty"`

	// picture
	// Example: /Library/User Pictures/Animals/Eagle.tif
	Picture string `json:"picture,omitempty"`

	// realname
	// Example: Administrator
	Realname string `json:"realname,omitempty"`

	// username
	// Example: admin
	Username string `json:"username,omitempty"`
}

// Validate validates this policy account maintenance accounts items0 account
func (m *PolicyAccountMaintenanceAccountsItems0Account) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyAccountMaintenanceAccountsItems0AccountTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Create","Reset","Delete","DisableFileVault"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyAccountMaintenanceAccountsItems0AccountTypeActionPropEnum = append(policyAccountMaintenanceAccountsItems0AccountTypeActionPropEnum, v)
	}
}

const (

	// PolicyAccountMaintenanceAccountsItems0AccountActionCreate captures enum value "Create"
	PolicyAccountMaintenanceAccountsItems0AccountActionCreate string = "Create"

	// PolicyAccountMaintenanceAccountsItems0AccountActionReset captures enum value "Reset"
	PolicyAccountMaintenanceAccountsItems0AccountActionReset string = "Reset"

	// PolicyAccountMaintenanceAccountsItems0AccountActionDelete captures enum value "Delete"
	PolicyAccountMaintenanceAccountsItems0AccountActionDelete string = "Delete"

	// PolicyAccountMaintenanceAccountsItems0AccountActionDisableFileVault captures enum value "DisableFileVault"
	PolicyAccountMaintenanceAccountsItems0AccountActionDisableFileVault string = "DisableFileVault"
)

// prop value enum
func (m *PolicyAccountMaintenanceAccountsItems0Account) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyAccountMaintenanceAccountsItems0AccountTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyAccountMaintenanceAccountsItems0Account) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("account"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy account maintenance accounts items0 account based on context it is used
func (m *PolicyAccountMaintenanceAccountsItems0Account) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenanceAccountsItems0Account) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenanceAccountsItems0Account) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenanceAccountsItems0Account
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenanceDirectoryBindingsItems0 policy account maintenance directory bindings items0
//
// swagger:model PolicyAccountMaintenanceDirectoryBindingsItems0
type PolicyAccountMaintenanceDirectoryBindingsItems0 struct {

	// binding
	Binding *IDName `json:"binding,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy account maintenance directory bindings items0
func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBinding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) validateBinding(formats strfmt.Registry) error {
	if swag.IsZero(m.Binding) { // not required
		return nil
	}

	if m.Binding != nil {
		if err := m.Binding.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("binding")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("binding")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy account maintenance directory bindings items0 based on the context it is used
func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBinding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) contextValidateBinding(ctx context.Context, formats strfmt.Registry) error {

	if m.Binding != nil {

		if swag.IsZero(m.Binding) { // not required
			return nil
		}

		if err := m.Binding.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("binding")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("binding")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenanceDirectoryBindingsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenanceDirectoryBindingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenanceManagementAccount policy account maintenance management account
//
// swagger:model PolicyAccountMaintenanceManagementAccount
type PolicyAccountMaintenanceManagementAccount struct {

	// action
	// Enum: [rotate doNotChange]
	Action string `json:"action,omitempty"`

	// managed password
	ManagedPassword string `json:"managed_password,omitempty"`

	// Only necessary when utilizing the random action
	// Example: 8
	ManagedPasswordLength int64 `json:"managed_password_length,omitempty"`
}

// Validate validates this policy account maintenance management account
func (m *PolicyAccountMaintenanceManagementAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyAccountMaintenanceManagementAccountTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["rotate","doNotChange"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyAccountMaintenanceManagementAccountTypeActionPropEnum = append(policyAccountMaintenanceManagementAccountTypeActionPropEnum, v)
	}
}

const (

	// PolicyAccountMaintenanceManagementAccountActionRotate captures enum value "rotate"
	PolicyAccountMaintenanceManagementAccountActionRotate string = "rotate"

	// PolicyAccountMaintenanceManagementAccountActionDoNotChange captures enum value "doNotChange"
	PolicyAccountMaintenanceManagementAccountActionDoNotChange string = "doNotChange"
)

// prop value enum
func (m *PolicyAccountMaintenanceManagementAccount) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyAccountMaintenanceManagementAccountTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyAccountMaintenanceManagementAccount) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("account_maintenance"+"."+"management_account"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy account maintenance management account based on context it is used
func (m *PolicyAccountMaintenanceManagementAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenanceManagementAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenanceManagementAccount) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenanceManagementAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyAccountMaintenanceOpenFirmwareEfiPassword policy account maintenance open firmware efi password
//
// swagger:model PolicyAccountMaintenanceOpenFirmwareEfiPassword
type PolicyAccountMaintenanceOpenFirmwareEfiPassword struct {

	// of mode
	// Enum: [command none]
	OfMode string `json:"of_mode,omitempty"`

	// of password
	OfPassword string `json:"of_password,omitempty"`
}

// Validate validates this policy account maintenance open firmware efi password
func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOfMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyAccountMaintenanceOpenFirmwareEfiPasswordTypeOfModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["command","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyAccountMaintenanceOpenFirmwareEfiPasswordTypeOfModePropEnum = append(policyAccountMaintenanceOpenFirmwareEfiPasswordTypeOfModePropEnum, v)
	}
}

const (

	// PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeCommand captures enum value "command"
	PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeCommand string = "command"

	// PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeNone captures enum value "none"
	PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeNone string = "none"
)

// prop value enum
func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) validateOfModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyAccountMaintenanceOpenFirmwareEfiPasswordTypeOfModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) validateOfMode(formats strfmt.Registry) error {
	if swag.IsZero(m.OfMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateOfModeEnum("account_maintenance"+"."+"open_firmware_efi_password"+"."+"of_mode", "body", m.OfMode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy account maintenance open firmware efi password based on context it is used
func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyAccountMaintenanceOpenFirmwareEfiPassword) UnmarshalBinary(b []byte) error {
	var res PolicyAccountMaintenanceOpenFirmwareEfiPassword
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyDiskEncryption policy disk encryption
//
// swagger:model PolicyDiskEncryption
type PolicyDiskEncryption struct {

	// action
	// Enum: [apply remediate]
	Action string `json:"action,omitempty"`

	// auth restart
	AuthRestart bool `json:"auth_restart,omitempty"`

	// disk encryption configuration id
	// Example: 1
	DiskEncryptionConfigurationID int64 `json:"disk_encryption_configuration_id,omitempty"`

	// disk encryption ID to utilize for remediating institutional recovery key types.
	// Example: 1
	RemediateDiskEncryptionConfigurationID int64 `json:"remediate_disk_encryption_configuration_id,omitempty"`

	// remediate key type
	// Enum: [Individual Institutional Individual And Institutional]
	RemediateKeyType string `json:"remediate_key_type,omitempty"`
}

// Validate validates this policy disk encryption
func (m *PolicyDiskEncryption) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemediateKeyType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyDiskEncryptionTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["apply","remediate"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyDiskEncryptionTypeActionPropEnum = append(policyDiskEncryptionTypeActionPropEnum, v)
	}
}

const (

	// PolicyDiskEncryptionActionApply captures enum value "apply"
	PolicyDiskEncryptionActionApply string = "apply"

	// PolicyDiskEncryptionActionRemediate captures enum value "remediate"
	PolicyDiskEncryptionActionRemediate string = "remediate"
)

// prop value enum
func (m *PolicyDiskEncryption) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyDiskEncryptionTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyDiskEncryption) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("disk_encryption"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

var policyDiskEncryptionTypeRemediateKeyTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Individual","Institutional","Individual And Institutional"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyDiskEncryptionTypeRemediateKeyTypePropEnum = append(policyDiskEncryptionTypeRemediateKeyTypePropEnum, v)
	}
}

const (

	// PolicyDiskEncryptionRemediateKeyTypeIndividual captures enum value "Individual"
	PolicyDiskEncryptionRemediateKeyTypeIndividual string = "Individual"

	// PolicyDiskEncryptionRemediateKeyTypeInstitutional captures enum value "Institutional"
	PolicyDiskEncryptionRemediateKeyTypeInstitutional string = "Institutional"

	// PolicyDiskEncryptionRemediateKeyTypeIndividualAndInstitutional captures enum value "Individual And Institutional"
	PolicyDiskEncryptionRemediateKeyTypeIndividualAndInstitutional string = "Individual And Institutional"
)

// prop value enum
func (m *PolicyDiskEncryption) validateRemediateKeyTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyDiskEncryptionTypeRemediateKeyTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyDiskEncryption) validateRemediateKeyType(formats strfmt.Registry) error {
	if swag.IsZero(m.RemediateKeyType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemediateKeyTypeEnum("disk_encryption"+"."+"remediate_key_type", "body", m.RemediateKeyType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy disk encryption based on context it is used
func (m *PolicyDiskEncryption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyDiskEncryption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyDiskEncryption) UnmarshalBinary(b []byte) error {
	var res PolicyDiskEncryption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyDockItemsItems0 policy dock items items0
//
// swagger:model PolicyDockItemsItems0
type PolicyDockItemsItems0 struct {

	// dock item
	DockItem *PolicyDockItemsItems0DockItem `json:"dock_item,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy dock items items0
func (m *PolicyDockItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDockItem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyDockItemsItems0) validateDockItem(formats strfmt.Registry) error {
	if swag.IsZero(m.DockItem) { // not required
		return nil
	}

	if m.DockItem != nil {
		if err := m.DockItem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dock_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dock_item")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyDockItemsItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy dock items items0 based on the context it is used
func (m *PolicyDockItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDockItem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyDockItemsItems0) contextValidateDockItem(ctx context.Context, formats strfmt.Registry) error {

	if m.DockItem != nil {

		if swag.IsZero(m.DockItem) { // not required
			return nil
		}

		if err := m.DockItem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dock_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dock_item")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyDockItemsItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyDockItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyDockItemsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyDockItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyDockItemsItems0DockItem policy dock items items0 dock item
//
// swagger:model PolicyDockItemsItems0DockItem
type PolicyDockItemsItems0DockItem struct {

	// action
	// Enum: [Add To Beginning Add To End Remove]
	Action string `json:"action,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Safari
	Name string `json:"name,omitempty"`
}

// Validate validates this policy dock items items0 dock item
func (m *PolicyDockItemsItems0DockItem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyDockItemsItems0DockItemTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Add To Beginning","Add To End","Remove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyDockItemsItems0DockItemTypeActionPropEnum = append(policyDockItemsItems0DockItemTypeActionPropEnum, v)
	}
}

const (

	// PolicyDockItemsItems0DockItemActionAddToBeginning captures enum value "Add To Beginning"
	PolicyDockItemsItems0DockItemActionAddToBeginning string = "Add To Beginning"

	// PolicyDockItemsItems0DockItemActionAddToEnd captures enum value "Add To End"
	PolicyDockItemsItems0DockItemActionAddToEnd string = "Add To End"

	// PolicyDockItemsItems0DockItemActionRemove captures enum value "Remove"
	PolicyDockItemsItems0DockItemActionRemove string = "Remove"
)

// prop value enum
func (m *PolicyDockItemsItems0DockItem) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyDockItemsItems0DockItemTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyDockItemsItems0DockItem) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("dock_item"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy dock items items0 dock item based on context it is used
func (m *PolicyDockItemsItems0DockItem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyDockItemsItems0DockItem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyDockItemsItems0DockItem) UnmarshalBinary(b []byte) error {
	var res PolicyDockItemsItems0DockItem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyFilesProcesses policy files processes
//
// swagger:model PolicyFilesProcesses
type PolicyFilesProcesses struct {

	// delete file
	DeleteFile bool `json:"delete_file,omitempty"`

	// kill process
	KillProcess bool `json:"kill_process,omitempty"`

	// locate file
	// Example: /Library/Fonts/testFont.ttc
	LocateFile string `json:"locate_file,omitempty"`

	// run command
	// Example: echo \"foobar\
	RunCommand string `json:"run_command,omitempty"`

	// search by path
	// Example: /Applications/appName.app
	SearchByPath string `json:"search_by_path,omitempty"`

	// search for process
	// Example: processName
	SearchForProcess string `json:"search_for_process,omitempty"`

	// spotlight search
	// Example: Screenshot.pdf
	SpotlightSearch string `json:"spotlight_search,omitempty"`

	// update locate database
	UpdateLocateDatabase bool `json:"update_locate_database,omitempty"`
}

// Validate validates this policy files processes
func (m *PolicyFilesProcesses) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy files processes based on context it is used
func (m *PolicyFilesProcesses) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyFilesProcesses) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyFilesProcesses) UnmarshalBinary(b []byte) error {
	var res PolicyFilesProcesses
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyGeneral policy general
//
// swagger:model PolicyGeneral
type PolicyGeneral struct {

	// category
	Category *CategoryObject `json:"category,omitempty"`

	// date time limitations
	DateTimeLimitations *PolicyGeneralDateTimeLimitations `json:"date_time_limitations,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// frequency
	// Enum: [Once per computer Once per user per computer Once per user Once every day Once every week Once every month Ongoing]
	Frequency string `json:"frequency,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// location user only
	LocationUserOnly bool `json:"location_user_only,omitempty"`

	// name
	// Example: Disk Encryption
	// Required: true
	Name *string `json:"name"`

	// network limitations
	NetworkLimitations *PolicyGeneralNetworkLimitations `json:"network_limitations,omitempty"`

	// network requirements
	// Enum: [Any Ethernet]
	NetworkRequirements string `json:"network_requirements,omitempty"`

	// notify on each failed retry
	NotifyOnEachFailedRetry *bool `json:"notify_on_each_failed_retry,omitempty"`

	// offline
	Offline bool `json:"offline,omitempty"`

	// override default settings
	OverrideDefaultSettings *PolicyGeneralOverrideDefaultSettings `json:"override_default_settings,omitempty"`

	// retry attempts
	RetryAttempts *int64 `json:"retry_attempts,omitempty"`

	// retry event
	// Enum: [none trigger check-in]
	RetryEvent *string `json:"retry_event,omitempty"`

	// site
	Site *SiteObject `json:"site,omitempty"`

	// target drive
	// Example: /
	TargetDrive string `json:"target_drive,omitempty"`

	// trigger
	Trigger string `json:"trigger,omitempty"`

	// trigger checkin
	TriggerCheckin *bool `json:"trigger_checkin,omitempty"`

	// trigger enrollment complete
	TriggerEnrollmentComplete *bool `json:"trigger_enrollment_complete,omitempty"`

	// trigger login
	TriggerLogin *bool `json:"trigger_login,omitempty"`

	// trigger logout
	TriggerLogout *bool `json:"trigger_logout,omitempty"`

	// trigger network state changed
	TriggerNetworkStateChanged *bool `json:"trigger_network_state_changed,omitempty"`

	// trigger other
	TriggerOther string `json:"trigger_other,omitempty"`

	// trigger startup
	TriggerStartup *bool `json:"trigger_startup,omitempty"`
}

// Validate validates this policy general
func (m *PolicyGeneral) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateTimeLimitations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkLimitations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkRequirements(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverrideDefaultSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetryEvent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyGeneral) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyGeneral) validateDateTimeLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.DateTimeLimitations) { // not required
		return nil
	}

	if m.DateTimeLimitations != nil {
		if err := m.DateTimeLimitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "date_time_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "date_time_limitations")
			}
			return err
		}
	}

	return nil
}

var policyGeneralTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Once per computer","Once per user per computer","Once per user","Once every day","Once every week","Once every month","Ongoing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyGeneralTypeFrequencyPropEnum = append(policyGeneralTypeFrequencyPropEnum, v)
	}
}

const (

	// PolicyGeneralFrequencyOncePerComputer captures enum value "Once per computer"
	PolicyGeneralFrequencyOncePerComputer string = "Once per computer"

	// PolicyGeneralFrequencyOncePerUserPerComputer captures enum value "Once per user per computer"
	PolicyGeneralFrequencyOncePerUserPerComputer string = "Once per user per computer"

	// PolicyGeneralFrequencyOncePerUser captures enum value "Once per user"
	PolicyGeneralFrequencyOncePerUser string = "Once per user"

	// PolicyGeneralFrequencyOnceEveryDay captures enum value "Once every day"
	PolicyGeneralFrequencyOnceEveryDay string = "Once every day"

	// PolicyGeneralFrequencyOnceEveryWeek captures enum value "Once every week"
	PolicyGeneralFrequencyOnceEveryWeek string = "Once every week"

	// PolicyGeneralFrequencyOnceEveryMonth captures enum value "Once every month"
	PolicyGeneralFrequencyOnceEveryMonth string = "Once every month"

	// PolicyGeneralFrequencyOngoing captures enum value "Ongoing"
	PolicyGeneralFrequencyOngoing string = "Ongoing"
)

// prop value enum
func (m *PolicyGeneral) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyGeneralTypeFrequencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyGeneral) validateFrequency(formats strfmt.Registry) error {
	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	// value enum
	if err := m.validateFrequencyEnum("general"+"."+"frequency", "body", m.Frequency); err != nil {
		return err
	}

	return nil
}

func (m *PolicyGeneral) validateName(formats strfmt.Registry) error {

	if err := validate.Required("general"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *PolicyGeneral) validateNetworkLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkLimitations) { // not required
		return nil
	}

	if m.NetworkLimitations != nil {
		if err := m.NetworkLimitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "network_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "network_limitations")
			}
			return err
		}
	}

	return nil
}

var policyGeneralTypeNetworkRequirementsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Any","Ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyGeneralTypeNetworkRequirementsPropEnum = append(policyGeneralTypeNetworkRequirementsPropEnum, v)
	}
}

const (

	// PolicyGeneralNetworkRequirementsAny captures enum value "Any"
	PolicyGeneralNetworkRequirementsAny string = "Any"

	// PolicyGeneralNetworkRequirementsEthernet captures enum value "Ethernet"
	PolicyGeneralNetworkRequirementsEthernet string = "Ethernet"
)

// prop value enum
func (m *PolicyGeneral) validateNetworkRequirementsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyGeneralTypeNetworkRequirementsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyGeneral) validateNetworkRequirements(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkRequirements) { // not required
		return nil
	}

	// value enum
	if err := m.validateNetworkRequirementsEnum("general"+"."+"network_requirements", "body", m.NetworkRequirements); err != nil {
		return err
	}

	return nil
}

func (m *PolicyGeneral) validateOverrideDefaultSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.OverrideDefaultSettings) { // not required
		return nil
	}

	if m.OverrideDefaultSettings != nil {
		if err := m.OverrideDefaultSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "override_default_settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "override_default_settings")
			}
			return err
		}
	}

	return nil
}

var policyGeneralTypeRetryEventPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","trigger","check-in"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyGeneralTypeRetryEventPropEnum = append(policyGeneralTypeRetryEventPropEnum, v)
	}
}

const (

	// PolicyGeneralRetryEventNone captures enum value "none"
	PolicyGeneralRetryEventNone string = "none"

	// PolicyGeneralRetryEventTrigger captures enum value "trigger"
	PolicyGeneralRetryEventTrigger string = "trigger"

	// PolicyGeneralRetryEventCheckDashIn captures enum value "check-in"
	PolicyGeneralRetryEventCheckDashIn string = "check-in"
)

// prop value enum
func (m *PolicyGeneral) validateRetryEventEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyGeneralTypeRetryEventPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyGeneral) validateRetryEvent(formats strfmt.Registry) error {
	if swag.IsZero(m.RetryEvent) { // not required
		return nil
	}

	// value enum
	if err := m.validateRetryEventEnum("general"+"."+"retry_event", "body", *m.RetryEvent); err != nil {
		return err
	}

	return nil
}

func (m *PolicyGeneral) validateSite(formats strfmt.Registry) error {
	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy general based on the context it is used
func (m *PolicyGeneral) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDateTimeLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverrideDefaultSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyGeneral) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "category")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyGeneral) contextValidateDateTimeLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.DateTimeLimitations != nil {

		if swag.IsZero(m.DateTimeLimitations) { // not required
			return nil
		}

		if err := m.DateTimeLimitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "date_time_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "date_time_limitations")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyGeneral) contextValidateNetworkLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkLimitations != nil {

		if swag.IsZero(m.NetworkLimitations) { // not required
			return nil
		}

		if err := m.NetworkLimitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "network_limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "network_limitations")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyGeneral) contextValidateOverrideDefaultSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.OverrideDefaultSettings != nil {

		if swag.IsZero(m.OverrideDefaultSettings) { // not required
			return nil
		}

		if err := m.OverrideDefaultSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "override_default_settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "override_default_settings")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyGeneral) contextValidateSite(ctx context.Context, formats strfmt.Registry) error {

	if m.Site != nil {

		if swag.IsZero(m.Site) { // not required
			return nil
		}

		if err := m.Site.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "site")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "site")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyGeneral) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyGeneral) UnmarshalBinary(b []byte) error {
	var res PolicyGeneral
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyGeneralDateTimeLimitations policy general date time limitations
//
// swagger:model PolicyGeneralDateTimeLimitations
type PolicyGeneralDateTimeLimitations struct {

	// activation date
	// Example: 2017-07-07 18:37:04
	ActivationDate string `json:"activation_date,omitempty"`

	// activation date epoch
	// Example: 1499470624555
	ActivationDateEpoch int64 `json:"activation_date_epoch,omitempty"`

	// activation date utc
	// Example: 2017-07-07T18:37:04.555-0500
	ActivationDateUtc string `json:"activation_date_utc,omitempty"`

	// expiration date
	// Example: 2017-07-07 18:37:04
	ExpirationDate string `json:"expiration_date,omitempty"`

	// expiration date epoch
	// Example: 1499470624555
	ExpirationDateEpoch int64 `json:"expiration_date_epoch,omitempty"`

	// expiration date utc
	// Example: 2017-07-07T18:37:04.555-0500
	ExpirationDateUtc string `json:"expiration_date_utc,omitempty"`

	// no execute end
	// Example: 4:00 AM
	NoExecuteEnd string `json:"no_execute_end,omitempty"`

	// no execute on
	NoExecuteOn *PolicyGeneralDateTimeLimitationsNoExecuteOn `json:"no_execute_on,omitempty"`

	// no execute start
	// Example: 2:00 AM
	NoExecuteStart string `json:"no_execute_start,omitempty"`
}

// Validate validates this policy general date time limitations
func (m *PolicyGeneralDateTimeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNoExecuteOn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyGeneralDateTimeLimitations) validateNoExecuteOn(formats strfmt.Registry) error {
	if swag.IsZero(m.NoExecuteOn) { // not required
		return nil
	}

	if m.NoExecuteOn != nil {
		if err := m.NoExecuteOn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "date_time_limitations" + "." + "no_execute_on")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "date_time_limitations" + "." + "no_execute_on")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy general date time limitations based on the context it is used
func (m *PolicyGeneralDateTimeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNoExecuteOn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyGeneralDateTimeLimitations) contextValidateNoExecuteOn(ctx context.Context, formats strfmt.Registry) error {

	if m.NoExecuteOn != nil {

		if swag.IsZero(m.NoExecuteOn) { // not required
			return nil
		}

		if err := m.NoExecuteOn.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general" + "." + "date_time_limitations" + "." + "no_execute_on")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("general" + "." + "date_time_limitations" + "." + "no_execute_on")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyGeneralDateTimeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyGeneralDateTimeLimitations) UnmarshalBinary(b []byte) error {
	var res PolicyGeneralDateTimeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyGeneralDateTimeLimitationsNoExecuteOn policy general date time limitations no execute on
//
// swagger:model PolicyGeneralDateTimeLimitationsNoExecuteOn
type PolicyGeneralDateTimeLimitationsNoExecuteOn struct {

	// day
	// Enum: [Sun Mon Tue Wed Thu Fri Sat]
	Day string `json:"day,omitempty"`
}

// Validate validates this policy general date time limitations no execute on
func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDay(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyGeneralDateTimeLimitationsNoExecuteOnTypeDayPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Sun","Mon","Tue","Wed","Thu","Fri","Sat"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyGeneralDateTimeLimitationsNoExecuteOnTypeDayPropEnum = append(policyGeneralDateTimeLimitationsNoExecuteOnTypeDayPropEnum, v)
	}
}

const (

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDaySun captures enum value "Sun"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDaySun string = "Sun"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDayMon captures enum value "Mon"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayMon string = "Mon"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDayTue captures enum value "Tue"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayTue string = "Tue"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDayWed captures enum value "Wed"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayWed string = "Wed"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDayThu captures enum value "Thu"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayThu string = "Thu"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDayFri captures enum value "Fri"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayFri string = "Fri"

	// PolicyGeneralDateTimeLimitationsNoExecuteOnDaySat captures enum value "Sat"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDaySat string = "Sat"
)

// prop value enum
func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) validateDayEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyGeneralDateTimeLimitationsNoExecuteOnTypeDayPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) validateDay(formats strfmt.Registry) error {
	if swag.IsZero(m.Day) { // not required
		return nil
	}

	// value enum
	if err := m.validateDayEnum("general"+"."+"date_time_limitations"+"."+"no_execute_on"+"."+"day", "body", m.Day); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy general date time limitations no execute on based on context it is used
func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyGeneralDateTimeLimitationsNoExecuteOn) UnmarshalBinary(b []byte) error {
	var res PolicyGeneralDateTimeLimitationsNoExecuteOn
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyGeneralNetworkLimitations policy general network limitations
//
// swagger:model PolicyGeneralNetworkLimitations
type PolicyGeneralNetworkLimitations struct {

	// any ip address
	AnyIPAddress bool `json:"any_ip_address,omitempty"`

	// minimum network connection
	// Enum: [No Minimum Ethernet]
	MinimumNetworkConnection string `json:"minimum_network_connection,omitempty"`
}

// Validate validates this policy general network limitations
func (m *PolicyGeneralNetworkLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMinimumNetworkConnection(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["No Minimum","Ethernet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum = append(policyGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum, v)
	}
}

const (

	// PolicyGeneralNetworkLimitationsMinimumNetworkConnectionNoMinimum captures enum value "No Minimum"
	PolicyGeneralNetworkLimitationsMinimumNetworkConnectionNoMinimum string = "No Minimum"

	// PolicyGeneralNetworkLimitationsMinimumNetworkConnectionEthernet captures enum value "Ethernet"
	PolicyGeneralNetworkLimitationsMinimumNetworkConnectionEthernet string = "Ethernet"
)

// prop value enum
func (m *PolicyGeneralNetworkLimitations) validateMinimumNetworkConnectionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyGeneralNetworkLimitationsTypeMinimumNetworkConnectionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyGeneralNetworkLimitations) validateMinimumNetworkConnection(formats strfmt.Registry) error {
	if swag.IsZero(m.MinimumNetworkConnection) { // not required
		return nil
	}

	// value enum
	if err := m.validateMinimumNetworkConnectionEnum("general"+"."+"network_limitations"+"."+"minimum_network_connection", "body", m.MinimumNetworkConnection); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy general network limitations based on context it is used
func (m *PolicyGeneralNetworkLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyGeneralNetworkLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyGeneralNetworkLimitations) UnmarshalBinary(b []byte) error {
	var res PolicyGeneralNetworkLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyGeneralOverrideDefaultSettings policy general override default settings
//
// swagger:model PolicyGeneralOverrideDefaultSettings
type PolicyGeneralOverrideDefaultSettings struct {

	// distribution point
	DistributionPoint string `json:"distribution_point,omitempty"`

	// force afp smb
	ForceAfpSmb bool `json:"force_afp_smb,omitempty"`

	// sus
	Sus string `json:"sus,omitempty"`

	// target drive
	TargetDrive string `json:"target_drive,omitempty"`
}

// Validate validates this policy general override default settings
func (m *PolicyGeneralOverrideDefaultSettings) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy general override default settings based on context it is used
func (m *PolicyGeneralOverrideDefaultSettings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyGeneralOverrideDefaultSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyGeneralOverrideDefaultSettings) UnmarshalBinary(b []byte) error {
	var res PolicyGeneralOverrideDefaultSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyMaintenance policy maintenance
//
// swagger:model PolicyMaintenance
type PolicyMaintenance struct {

	// byhost
	Byhost bool `json:"byhost,omitempty"`

	// heal
	Heal bool `json:"heal,omitempty"`

	// install all cached packages
	InstallAllCachedPackages bool `json:"install_all_cached_packages,omitempty"`

	// permissions
	Permissions bool `json:"permissions,omitempty"`

	// prebindings
	Prebindings bool `json:"prebindings,omitempty"`

	// recon
	Recon bool `json:"recon,omitempty"`

	// reset name
	ResetName bool `json:"reset_name,omitempty"`

	// system cache
	SystemCache bool `json:"system_cache,omitempty"`

	// user cache
	UserCache bool `json:"user_cache,omitempty"`

	// verify
	Verify bool `json:"verify,omitempty"`
}

// Validate validates this policy maintenance
func (m *PolicyMaintenance) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy maintenance based on context it is used
func (m *PolicyMaintenance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyMaintenance) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyMaintenance) UnmarshalBinary(b []byte) error {
	var res PolicyMaintenance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPackageConfiguration policy package configuration
//
// swagger:model PolicyPackageConfiguration
type PolicyPackageConfiguration struct {

	// packages
	Packages []*PolicyPackageConfigurationPackagesItems0 `json:"packages"`
}

// Validate validates this policy package configuration
func (m *PolicyPackageConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePackages(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPackageConfiguration) validatePackages(formats strfmt.Registry) error {
	if swag.IsZero(m.Packages) { // not required
		return nil
	}

	for i := 0; i < len(m.Packages); i++ {
		if swag.IsZero(m.Packages[i]) { // not required
			continue
		}

		if m.Packages[i] != nil {
			if err := m.Packages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("package_configuration" + "." + "packages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("package_configuration" + "." + "packages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this policy package configuration based on the context it is used
func (m *PolicyPackageConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePackages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPackageConfiguration) contextValidatePackages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Packages); i++ {

		if m.Packages[i] != nil {

			if swag.IsZero(m.Packages[i]) { // not required
				return nil
			}

			if err := m.Packages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("package_configuration" + "." + "packages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("package_configuration" + "." + "packages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPackageConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPackageConfiguration) UnmarshalBinary(b []byte) error {
	var res PolicyPackageConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPackageConfigurationPackagesItems0 policy package configuration packages items0
//
// swagger:model PolicyPackageConfigurationPackagesItems0
type PolicyPackageConfigurationPackagesItems0 struct {

	// package
	Package *PolicyPackageConfigurationPackagesItems0Package `json:"package,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy package configuration packages items0
func (m *PolicyPackageConfigurationPackagesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePackage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPackageConfigurationPackagesItems0) validatePackage(formats strfmt.Registry) error {
	if swag.IsZero(m.Package) { // not required
		return nil
	}

	if m.Package != nil {
		if err := m.Package.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("package")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("package")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPackageConfigurationPackagesItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy package configuration packages items0 based on the context it is used
func (m *PolicyPackageConfigurationPackagesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePackage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPackageConfigurationPackagesItems0) contextValidatePackage(ctx context.Context, formats strfmt.Registry) error {

	if m.Package != nil {

		if swag.IsZero(m.Package) { // not required
			return nil
		}

		if err := m.Package.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("package")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("package")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPackageConfigurationPackagesItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPackageConfigurationPackagesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPackageConfigurationPackagesItems0) UnmarshalBinary(b []byte) error {
	var res PolicyPackageConfigurationPackagesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPackageConfigurationPackagesItems0Package policy package configuration packages items0 package
//
// swagger:model PolicyPackageConfigurationPackagesItems0Package
type PolicyPackageConfigurationPackagesItems0Package struct {

	// action
	// Enum: [Install Cache Install Cached]
	Action string `json:"action,omitempty"`

	// feu
	Feu bool `json:"feu,omitempty"`

	// fut
	Fut bool `json:"fut,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Firefox.dmg
	Name string `json:"name,omitempty"`

	// update autorun
	UpdateAutorun bool `json:"update_autorun,omitempty"`
}

// Validate validates this policy package configuration packages items0 package
func (m *PolicyPackageConfigurationPackagesItems0Package) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyPackageConfigurationPackagesItems0PackageTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Install","Cache","Install Cached"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyPackageConfigurationPackagesItems0PackageTypeActionPropEnum = append(policyPackageConfigurationPackagesItems0PackageTypeActionPropEnum, v)
	}
}

const (

	// PolicyPackageConfigurationPackagesItems0PackageActionInstall captures enum value "Install"
	PolicyPackageConfigurationPackagesItems0PackageActionInstall string = "Install"

	// PolicyPackageConfigurationPackagesItems0PackageActionCache captures enum value "Cache"
	PolicyPackageConfigurationPackagesItems0PackageActionCache string = "Cache"

	// PolicyPackageConfigurationPackagesItems0PackageActionInstallCached captures enum value "Install Cached"
	PolicyPackageConfigurationPackagesItems0PackageActionInstallCached string = "Install Cached"
)

// prop value enum
func (m *PolicyPackageConfigurationPackagesItems0Package) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyPackageConfigurationPackagesItems0PackageTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyPackageConfigurationPackagesItems0Package) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("package"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy package configuration packages items0 package based on context it is used
func (m *PolicyPackageConfigurationPackagesItems0Package) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPackageConfigurationPackagesItems0Package) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPackageConfigurationPackagesItems0Package) UnmarshalBinary(b []byte) error {
	var res PolicyPackageConfigurationPackagesItems0Package
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPrintersItems0 policy printers items0
//
// swagger:model PolicyPrintersItems0
type PolicyPrintersItems0 struct {

	// leave existing default
	LeaveExistingDefault string `json:"leave_existing_default,omitempty"`

	// printer
	Printer *PolicyPrintersItems0Printer `json:"printer,omitempty"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy printers items0
func (m *PolicyPrintersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePrinter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPrintersItems0) validatePrinter(formats strfmt.Registry) error {
	if swag.IsZero(m.Printer) { // not required
		return nil
	}

	if m.Printer != nil {
		if err := m.Printer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("printer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("printer")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPrintersItems0) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy printers items0 based on the context it is used
func (m *PolicyPrintersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePrinter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyPrintersItems0) contextValidatePrinter(ctx context.Context, formats strfmt.Registry) error {

	if m.Printer != nil {

		if swag.IsZero(m.Printer) { // not required
			return nil
		}

		if err := m.Printer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("printer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("printer")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyPrintersItems0) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPrintersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPrintersItems0) UnmarshalBinary(b []byte) error {
	var res PolicyPrintersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyPrintersItems0Printer policy printers items0 printer
//
// swagger:model PolicyPrintersItems0Printer
type PolicyPrintersItems0Printer struct {

	// action
	// Enum: [install uninstall]
	Action string `json:"action,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// make default
	MakeDefault bool `json:"make_default,omitempty"`

	// name
	// Example: Kyocera
	Name string `json:"name,omitempty"`
}

// Validate validates this policy printers items0 printer
func (m *PolicyPrintersItems0Printer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyPrintersItems0PrinterTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["install","uninstall"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyPrintersItems0PrinterTypeActionPropEnum = append(policyPrintersItems0PrinterTypeActionPropEnum, v)
	}
}

const (

	// PolicyPrintersItems0PrinterActionInstall captures enum value "install"
	PolicyPrintersItems0PrinterActionInstall string = "install"

	// PolicyPrintersItems0PrinterActionUninstall captures enum value "uninstall"
	PolicyPrintersItems0PrinterActionUninstall string = "uninstall"
)

// prop value enum
func (m *PolicyPrintersItems0Printer) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyPrintersItems0PrinterTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyPrintersItems0Printer) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("printer"+"."+"action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy printers items0 printer based on context it is used
func (m *PolicyPrintersItems0Printer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyPrintersItems0Printer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyPrintersItems0Printer) UnmarshalBinary(b []byte) error {
	var res PolicyPrintersItems0Printer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScope policy scope
//
// swagger:model PolicyScope
type PolicyScope struct {

	// all computers
	AllComputers *bool `json:"all_computers,omitempty"`

	// buildings
	Buildings []*PolicyScopeBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*PolicyScopeComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*PolicyScopeComputersItems0 `json:"computers"`

	// departments
	Departments []*PolicyScopeDepartmentsItems0 `json:"departments"`

	// exclusions
	Exclusions *PolicyScopeExclusions `json:"exclusions,omitempty"`

	// limit to users
	LimitToUsers *PolicyScopeLimitToUsers `json:"limit_to_users,omitempty"`

	// limitations
	Limitations *PolicyScopeLimitations `json:"limitations,omitempty"`
}

// Validate validates this policy scope
func (m *PolicyScope) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitToUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLimitations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScope) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) validateExclusions(formats strfmt.Registry) error {
	if swag.IsZero(m.Exclusions) { // not required
		return nil
	}

	if m.Exclusions != nil {
		if err := m.Exclusions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyScope) validateLimitToUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.LimitToUsers) { // not required
		return nil
	}

	if m.LimitToUsers != nil {
		if err := m.LimitToUsers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limit_to_users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limit_to_users")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyScope) validateLimitations(formats strfmt.Registry) error {
	if swag.IsZero(m.Limitations) { // not required
		return nil
	}

	if m.Limitations != nil {
		if err := m.Limitations.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope based on the context it is used
func (m *PolicyScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitToUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLimitations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScope) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScope) contextValidateExclusions(ctx context.Context, formats strfmt.Registry) error {

	if m.Exclusions != nil {

		if swag.IsZero(m.Exclusions) { // not required
			return nil
		}

		if err := m.Exclusions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "exclusions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "exclusions")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyScope) contextValidateLimitToUsers(ctx context.Context, formats strfmt.Registry) error {

	if m.LimitToUsers != nil {

		if swag.IsZero(m.LimitToUsers) { // not required
			return nil
		}

		if err := m.LimitToUsers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limit_to_users")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limit_to_users")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyScope) contextValidateLimitations(ctx context.Context, formats strfmt.Registry) error {

	if m.Limitations != nil {

		if swag.IsZero(m.Limitations) { // not required
			return nil
		}

		if err := m.Limitations.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scope" + "." + "limitations")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scope" + "." + "limitations")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScope) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScope) UnmarshalBinary(b []byte) error {
	var res PolicyScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeBuildingsItems0 policy scope buildings items0
//
// swagger:model PolicyScopeBuildingsItems0
type PolicyScopeBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this policy scope buildings items0
func (m *PolicyScopeBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope buildings items0 based on the context it is used
func (m *PolicyScopeBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeComputerGroupsItems0 policy scope computer groups items0
//
// swagger:model PolicyScopeComputerGroupsItems0
type PolicyScopeComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this policy scope computer groups items0
func (m *PolicyScopeComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope computer groups items0 based on the context it is used
func (m *PolicyScopeComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeComputersItems0 policy scope computers items0
//
// swagger:model PolicyScopeComputersItems0
type PolicyScopeComputersItems0 struct {

	// computer
	Computer *PolicyScopeComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this policy scope computers items0
func (m *PolicyScopeComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope computers items0 based on the context it is used
func (m *PolicyScopeComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeComputersItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeComputersItems0Computer policy scope computers items0 computer
//
// swagger:model PolicyScopeComputersItems0Computer
type PolicyScopeComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Admins MacBook Pro
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this policy scope computers items0 computer
func (m *PolicyScopeComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy scope computers items0 computer based on context it is used
func (m *PolicyScopeComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res PolicyScopeComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeDepartmentsItems0 policy scope departments items0
//
// swagger:model PolicyScopeDepartmentsItems0
type PolicyScopeDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this policy scope departments items0
func (m *PolicyScopeDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope departments items0 based on the context it is used
func (m *PolicyScopeDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusions policy scope exclusions
//
// swagger:model PolicyScopeExclusions
type PolicyScopeExclusions struct {

	// buildings
	Buildings []*PolicyScopeExclusionsBuildingsItems0 `json:"buildings"`

	// computer groups
	ComputerGroups []*PolicyScopeExclusionsComputerGroupsItems0 `json:"computer_groups"`

	// computers
	Computers []*PolicyScopeExclusionsComputersItems0 `json:"computers"`

	// departments
	Departments []*PolicyScopeExclusionsDepartmentsItems0 `json:"departments"`

	// ibeacons
	Ibeacons []*PolicyScopeExclusionsIbeaconsItems0 `json:"ibeacons"`

	// network segments
	NetworkSegments []*PolicyScopeExclusionsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*PolicyScopeExclusionsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*PolicyScopeExclusionsUsersItems0 `json:"users"`
}

// Validate validates this policy scope exclusions
func (m *PolicyScopeExclusions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuildings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputerGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComputers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbeacons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusions) validateBuildings(formats strfmt.Registry) error {
	if swag.IsZero(m.Buildings) { // not required
		return nil
	}

	for i := 0; i < len(m.Buildings); i++ {
		if swag.IsZero(m.Buildings[i]) { // not required
			continue
		}

		if m.Buildings[i] != nil {
			if err := m.Buildings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateComputerGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ComputerGroups); i++ {
		if swag.IsZero(m.ComputerGroups[i]) { // not required
			continue
		}

		if m.ComputerGroups[i] != nil {
			if err := m.ComputerGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateComputers(formats strfmt.Registry) error {
	if swag.IsZero(m.Computers) { // not required
		return nil
	}

	for i := 0; i < len(m.Computers); i++ {
		if swag.IsZero(m.Computers[i]) { // not required
			continue
		}

		if m.Computers[i] != nil {
			if err := m.Computers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateDepartments(formats strfmt.Registry) error {
	if swag.IsZero(m.Departments) { // not required
		return nil
	}

	for i := 0; i < len(m.Departments); i++ {
		if swag.IsZero(m.Departments[i]) { // not required
			continue
		}

		if m.Departments[i] != nil {
			if err := m.Departments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateIbeacons(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacons) { // not required
		return nil
	}

	for i := 0; i < len(m.Ibeacons); i++ {
		if swag.IsZero(m.Ibeacons[i]) { // not required
			continue
		}

		if m.Ibeacons[i] != nil {
			if err := m.Ibeacons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this policy scope exclusions based on the context it is used
func (m *PolicyScopeExclusions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuildings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputerGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateComputers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDepartments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIbeacons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusions) contextValidateBuildings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Buildings); i++ {

		if m.Buildings[i] != nil {

			if swag.IsZero(m.Buildings[i]) { // not required
				return nil
			}

			if err := m.Buildings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "buildings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateComputerGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ComputerGroups); i++ {

		if m.ComputerGroups[i] != nil {

			if swag.IsZero(m.ComputerGroups[i]) { // not required
				return nil
			}

			if err := m.ComputerGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computer_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateComputers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Computers); i++ {

		if m.Computers[i] != nil {

			if swag.IsZero(m.Computers[i]) { // not required
				return nil
			}

			if err := m.Computers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "computers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateDepartments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Departments); i++ {

		if m.Departments[i] != nil {

			if swag.IsZero(m.Departments[i]) { // not required
				return nil
			}

			if err := m.Departments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "departments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateIbeacons(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ibeacons); i++ {

		if m.Ibeacons[i] != nil {

			if swag.IsZero(m.Ibeacons[i]) { // not required
				return nil
			}

			if err := m.Ibeacons[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeExclusions) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "exclusions" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusions) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsBuildingsItems0 policy scope exclusions buildings items0
//
// swagger:model PolicyScopeExclusionsBuildingsItems0
type PolicyScopeExclusionsBuildingsItems0 struct {

	// building
	Building *IDName `json:"building,omitempty"`
}

// Validate validates this policy scope exclusions buildings items0
func (m *PolicyScopeExclusionsBuildingsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuilding(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsBuildingsItems0) validateBuilding(formats strfmt.Registry) error {
	if swag.IsZero(m.Building) { // not required
		return nil
	}

	if m.Building != nil {
		if err := m.Building.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions buildings items0 based on the context it is used
func (m *PolicyScopeExclusionsBuildingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBuilding(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsBuildingsItems0) contextValidateBuilding(ctx context.Context, formats strfmt.Registry) error {

	if m.Building != nil {

		if swag.IsZero(m.Building) { // not required
			return nil
		}

		if err := m.Building.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("building")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("building")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsBuildingsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsBuildingsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsBuildingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsComputerGroupsItems0 policy scope exclusions computer groups items0
//
// swagger:model PolicyScopeExclusionsComputerGroupsItems0
type PolicyScopeExclusionsComputerGroupsItems0 struct {

	// computer group
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

// Validate validates this policy scope exclusions computer groups items0
func (m *PolicyScopeExclusionsComputerGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputerGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsComputerGroupsItems0) validateComputerGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.ComputerGroup) { // not required
		return nil
	}

	if m.ComputerGroup != nil {
		if err := m.ComputerGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions computer groups items0 based on the context it is used
func (m *PolicyScopeExclusionsComputerGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputerGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsComputerGroupsItems0) contextValidateComputerGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.ComputerGroup != nil {

		if swag.IsZero(m.ComputerGroup) { // not required
			return nil
		}

		if err := m.ComputerGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputerGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputerGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsComputerGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsComputersItems0 policy scope exclusions computers items0
//
// swagger:model PolicyScopeExclusionsComputersItems0
type PolicyScopeExclusionsComputersItems0 struct {

	// computer
	Computer *PolicyScopeExclusionsComputersItems0Computer `json:"computer,omitempty"`
}

// Validate validates this policy scope exclusions computers items0
func (m *PolicyScopeExclusionsComputersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComputer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsComputersItems0) validateComputer(formats strfmt.Registry) error {
	if swag.IsZero(m.Computer) { // not required
		return nil
	}

	if m.Computer != nil {
		if err := m.Computer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions computers items0 based on the context it is used
func (m *PolicyScopeExclusionsComputersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComputer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsComputersItems0) contextValidateComputer(ctx context.Context, formats strfmt.Registry) error {

	if m.Computer != nil {

		if swag.IsZero(m.Computer) { // not required
			return nil
		}

		if err := m.Computer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("computer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("computer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputersItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsComputersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsComputersItems0Computer policy scope exclusions computers items0 computer
//
// swagger:model PolicyScopeExclusionsComputersItems0Computer
type PolicyScopeExclusionsComputersItems0Computer struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// Name of the computer
	// Example: Johns iMac
	Name string `json:"name,omitempty"`

	// udid
	// Example: 55900BDC-347C-58B1-D249-F32244B11D30
	Udid string `json:"udid,omitempty"`
}

// Validate validates this policy scope exclusions computers items0 computer
func (m *PolicyScopeExclusionsComputersItems0Computer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy scope exclusions computers items0 computer based on context it is used
func (m *PolicyScopeExclusionsComputersItems0Computer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputersItems0Computer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsComputersItems0Computer) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsComputersItems0Computer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsDepartmentsItems0 policy scope exclusions departments items0
//
// swagger:model PolicyScopeExclusionsDepartmentsItems0
type PolicyScopeExclusionsDepartmentsItems0 struct {

	// department
	Department *IDName `json:"department,omitempty"`
}

// Validate validates this policy scope exclusions departments items0
func (m *PolicyScopeExclusionsDepartmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsDepartmentsItems0) validateDepartment(formats strfmt.Registry) error {
	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions departments items0 based on the context it is used
func (m *PolicyScopeExclusionsDepartmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDepartment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsDepartmentsItems0) contextValidateDepartment(ctx context.Context, formats strfmt.Registry) error {

	if m.Department != nil {

		if swag.IsZero(m.Department) { // not required
			return nil
		}

		if err := m.Department.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsDepartmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsDepartmentsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsDepartmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsIbeaconsItems0 policy scope exclusions ibeacons items0
//
// swagger:model PolicyScopeExclusionsIbeaconsItems0
type PolicyScopeExclusionsIbeaconsItems0 struct {

	// ibeacon
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

// Validate validates this policy scope exclusions ibeacons items0
func (m *PolicyScopeExclusionsIbeaconsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsIbeaconsItems0) validateIbeacon(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacon) { // not required
		return nil
	}

	if m.Ibeacon != nil {
		if err := m.Ibeacon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions ibeacons items0 based on the context it is used
func (m *PolicyScopeExclusionsIbeaconsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsIbeaconsItems0) contextValidateIbeacon(ctx context.Context, formats strfmt.Registry) error {

	if m.Ibeacon != nil {

		if swag.IsZero(m.Ibeacon) { // not required
			return nil
		}

		if err := m.Ibeacon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsIbeaconsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsIbeaconsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsIbeaconsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsNetworkSegmentsItems0 policy scope exclusions network segments items0
//
// swagger:model PolicyScopeExclusionsNetworkSegmentsItems0
type PolicyScopeExclusionsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment `json:"network_segment,omitempty"`
}

// Validate validates this policy scope exclusions network segments items0
func (m *PolicyScopeExclusionsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions network segments items0 based on the context it is used
func (m *PolicyScopeExclusionsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment policy scope exclusions network segments items0 network segment
//
// swagger:model PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment
type PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment struct {

	// id
	ID int64 `json:"id,omitempty"`

	// Name of the network segment
	// Example: New York
	Name string `json:"name,omitempty"`

	// uid
	UID string `json:"uid,omitempty"`
}

// Validate validates this policy scope exclusions network segments items0 network segment
func (m *PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy scope exclusions network segments items0 network segment based on context it is used
func (m *PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsNetworkSegmentsItems0NetworkSegment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsUserGroupsItems0 policy scope exclusions user groups items0
//
// swagger:model PolicyScopeExclusionsUserGroupsItems0
type PolicyScopeExclusionsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this policy scope exclusions user groups items0
func (m *PolicyScopeExclusionsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions user groups items0 based on the context it is used
func (m *PolicyScopeExclusionsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsUsersItems0 policy scope exclusions users items0
//
// swagger:model PolicyScopeExclusionsUsersItems0
type PolicyScopeExclusionsUsersItems0 struct {

	// user
	User *PolicyScopeExclusionsUsersItems0User `json:"user,omitempty"`
}

// Validate validates this policy scope exclusions users items0
func (m *PolicyScopeExclusionsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope exclusions users items0 based on the context it is used
func (m *PolicyScopeExclusionsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeExclusionsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsUsersItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeExclusionsUsersItems0User policy scope exclusions users items0 user
//
// swagger:model PolicyScopeExclusionsUsersItems0User
type PolicyScopeExclusionsUsersItems0User struct {

	// name
	// Example: Adam
	Name string `json:"name,omitempty"`
}

// Validate validates this policy scope exclusions users items0 user
func (m *PolicyScopeExclusionsUsersItems0User) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy scope exclusions users items0 user based on context it is used
func (m *PolicyScopeExclusionsUsersItems0User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeExclusionsUsersItems0User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeExclusionsUsersItems0User) UnmarshalBinary(b []byte) error {
	var res PolicyScopeExclusionsUsersItems0User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitToUsers policy scope limit to users
//
// swagger:model PolicyScopeLimitToUsers
type PolicyScopeLimitToUsers struct {

	// user groups
	UserGroups []*PolicyScopeLimitToUsersUserGroupsItems0 `json:"user_groups"`
}

// Validate validates this policy scope limit to users
func (m *PolicyScopeLimitToUsers) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitToUsers) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limit_to_users" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limit_to_users" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this policy scope limit to users based on the context it is used
func (m *PolicyScopeLimitToUsers) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitToUsers) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limit_to_users" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limit_to_users" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitToUsers) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitToUsers) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitToUsers
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitToUsersUserGroupsItems0 policy scope limit to users user groups items0
//
// swagger:model PolicyScopeLimitToUsersUserGroupsItems0
type PolicyScopeLimitToUsersUserGroupsItems0 struct {

	// user group
	// Example: Teachers
	UserGroup string `json:"user_group,omitempty"`
}

// Validate validates this policy scope limit to users user groups items0
func (m *PolicyScopeLimitToUsersUserGroupsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy scope limit to users user groups items0 based on context it is used
func (m *PolicyScopeLimitToUsersUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitToUsersUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitToUsersUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitToUsersUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitations policy scope limitations
//
// swagger:model PolicyScopeLimitations
type PolicyScopeLimitations struct {

	// ibeacons
	Ibeacons []*PolicyScopeLimitationsIbeaconsItems0 `json:"ibeacons"`

	// network segments
	NetworkSegments []*PolicyScopeLimitationsNetworkSegmentsItems0 `json:"network_segments"`

	// user groups
	UserGroups []*PolicyScopeLimitationsUserGroupsItems0 `json:"user_groups"`

	// users
	Users []*PolicyScopeLimitationsUsersItems0 `json:"users"`
}

// Validate validates this policy scope limitations
func (m *PolicyScopeLimitations) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitations) validateIbeacons(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacons) { // not required
		return nil
	}

	for i := 0; i < len(m.Ibeacons); i++ {
		if swag.IsZero(m.Ibeacons[i]) { // not required
			continue
		}

		if m.Ibeacons[i] != nil {
			if err := m.Ibeacons[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) validateNetworkSegments(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegments) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkSegments); i++ {
		if swag.IsZero(m.NetworkSegments[i]) { // not required
			continue
		}

		if m.NetworkSegments[i] != nil {
			if err := m.NetworkSegments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) validateUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.UserGroups); i++ {
		if swag.IsZero(m.UserGroups[i]) { // not required
			continue
		}

		if m.UserGroups[i] != nil {
			if err := m.UserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) validateUsers(formats strfmt.Registry) error {
	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this policy scope limitations based on the context it is used
func (m *PolicyScopeLimitations) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkSegments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitations) contextValidateIbeacons(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ibeacons); i++ {

		if m.Ibeacons[i] != nil {

			if swag.IsZero(m.Ibeacons[i]) { // not required
				return nil
			}

			if err := m.Ibeacons[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "ibeacons" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) contextValidateNetworkSegments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkSegments); i++ {

		if m.NetworkSegments[i] != nil {

			if swag.IsZero(m.NetworkSegments[i]) { // not required
				return nil
			}

			if err := m.NetworkSegments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "network_segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) contextValidateUserGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserGroups); i++ {

		if m.UserGroups[i] != nil {

			if swag.IsZero(m.UserGroups[i]) { // not required
				return nil
			}

			if err := m.UserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScopeLimitations) contextValidateUsers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Users); i++ {

		if m.Users[i] != nil {

			if swag.IsZero(m.Users[i]) { // not required
				return nil
			}

			if err := m.Users[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scope" + "." + "limitations" + "." + "users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitations) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitations) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitations
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitationsIbeaconsItems0 policy scope limitations ibeacons items0
//
// swagger:model PolicyScopeLimitationsIbeaconsItems0
type PolicyScopeLimitationsIbeaconsItems0 struct {

	// ibeacon
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

// Validate validates this policy scope limitations ibeacons items0
func (m *PolicyScopeLimitationsIbeaconsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIbeacon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsIbeaconsItems0) validateIbeacon(formats strfmt.Registry) error {
	if swag.IsZero(m.Ibeacon) { // not required
		return nil
	}

	if m.Ibeacon != nil {
		if err := m.Ibeacon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope limitations ibeacons items0 based on the context it is used
func (m *PolicyScopeLimitationsIbeaconsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIbeacon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsIbeaconsItems0) contextValidateIbeacon(ctx context.Context, formats strfmt.Registry) error {

	if m.Ibeacon != nil {

		if swag.IsZero(m.Ibeacon) { // not required
			return nil
		}

		if err := m.Ibeacon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ibeacon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ibeacon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitationsIbeaconsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitationsIbeaconsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitationsIbeaconsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitationsNetworkSegmentsItems0 policy scope limitations network segments items0
//
// swagger:model PolicyScopeLimitationsNetworkSegmentsItems0
type PolicyScopeLimitationsNetworkSegmentsItems0 struct {

	// network segment
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

// Validate validates this policy scope limitations network segments items0
func (m *PolicyScopeLimitationsNetworkSegmentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkSegment(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsNetworkSegmentsItems0) validateNetworkSegment(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkSegment) { // not required
		return nil
	}

	if m.NetworkSegment != nil {
		if err := m.NetworkSegment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope limitations network segments items0 based on the context it is used
func (m *PolicyScopeLimitationsNetworkSegmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkSegment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsNetworkSegmentsItems0) contextValidateNetworkSegment(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkSegment != nil {

		if swag.IsZero(m.NetworkSegment) { // not required
			return nil
		}

		if err := m.NetworkSegment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("network_segment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("network_segment")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitationsNetworkSegmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitationsNetworkSegmentsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitationsNetworkSegmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitationsUserGroupsItems0 policy scope limitations user groups items0
//
// swagger:model PolicyScopeLimitationsUserGroupsItems0
type PolicyScopeLimitationsUserGroupsItems0 struct {

	// user group
	UserGroup *IDName `json:"user_group,omitempty"`
}

// Validate validates this policy scope limitations user groups items0
func (m *PolicyScopeLimitationsUserGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserGroup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsUserGroupsItems0) validateUserGroup(formats strfmt.Registry) error {
	if swag.IsZero(m.UserGroup) { // not required
		return nil
	}

	if m.UserGroup != nil {
		if err := m.UserGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope limitations user groups items0 based on the context it is used
func (m *PolicyScopeLimitationsUserGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsUserGroupsItems0) contextValidateUserGroup(ctx context.Context, formats strfmt.Registry) error {

	if m.UserGroup != nil {

		if swag.IsZero(m.UserGroup) { // not required
			return nil
		}

		if err := m.UserGroup.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_group")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user_group")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitationsUserGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitationsUserGroupsItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitationsUserGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScopeLimitationsUsersItems0 policy scope limitations users items0
//
// swagger:model PolicyScopeLimitationsUsersItems0
type PolicyScopeLimitationsUsersItems0 struct {

	// user
	User *IDName `json:"user,omitempty"`
}

// Validate validates this policy scope limitations users items0
func (m *PolicyScopeLimitationsUsersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsUsersItems0) validateUser(formats strfmt.Registry) error {
	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy scope limitations users items0 based on the context it is used
func (m *PolicyScopeLimitationsUsersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScopeLimitationsUsersItems0) contextValidateUser(ctx context.Context, formats strfmt.Registry) error {

	if m.User != nil {

		if swag.IsZero(m.User) { // not required
			return nil
		}

		if err := m.User.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScopeLimitationsUsersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScopeLimitationsUsersItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScopeLimitationsUsersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScripts policy scripts
//
// swagger:model PolicyScripts
type PolicyScripts struct {

	// script
	Script []*PolicyScriptsScriptItems0 `json:"script"`

	// size
	Size Size `json:"size,omitempty"`
}

// Validate validates this policy scripts
func (m *PolicyScripts) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScripts) validateScript(formats strfmt.Registry) error {
	if swag.IsZero(m.Script) { // not required
		return nil
	}

	for i := 0; i < len(m.Script); i++ {
		if swag.IsZero(m.Script[i]) { // not required
			continue
		}

		if m.Script[i] != nil {
			if err := m.Script[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scripts" + "." + "script" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scripts" + "." + "script" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScripts) validateSize(formats strfmt.Registry) error {
	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("scripts" + "." + "size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("scripts" + "." + "size")
		}
		return err
	}

	return nil
}

// ContextValidate validate this policy scripts based on the context it is used
func (m *PolicyScripts) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyScripts) contextValidateScript(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Script); i++ {

		if m.Script[i] != nil {

			if swag.IsZero(m.Script[i]) { // not required
				return nil
			}

			if err := m.Script[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scripts" + "." + "script" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("scripts" + "." + "script" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PolicyScripts) contextValidateSize(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Size) { // not required
		return nil
	}

	if err := m.Size.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("scripts" + "." + "size")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("scripts" + "." + "size")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScripts) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScripts) UnmarshalBinary(b []byte) error {
	var res PolicyScripts
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyScriptsScriptItems0 policy scripts script items0
//
// swagger:model PolicyScriptsScriptItems0
type PolicyScriptsScriptItems0 struct {

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// name
	// Example: mountNetworkShare.sh
	Name string `json:"name,omitempty"`

	// parameter10
	Parameter10 string `json:"parameter10,omitempty"`

	// parameter11
	Parameter11 string `json:"parameter11,omitempty"`

	// parameter4
	Parameter4 string `json:"parameter4,omitempty"`

	// parameter5
	Parameter5 string `json:"parameter5,omitempty"`

	// parameter6
	Parameter6 string `json:"parameter6,omitempty"`

	// parameter7
	Parameter7 string `json:"parameter7,omitempty"`

	// parameter8
	Parameter8 string `json:"parameter8,omitempty"`

	// parameter9
	Parameter9 string `json:"parameter9,omitempty"`

	// priority
	// Enum: [Before After]
	Priority string `json:"priority,omitempty"`
}

// Validate validates this policy scripts script items0
func (m *PolicyScriptsScriptItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePriority(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var policyScriptsScriptItems0TypePriorityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Before","After"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		policyScriptsScriptItems0TypePriorityPropEnum = append(policyScriptsScriptItems0TypePriorityPropEnum, v)
	}
}

const (

	// PolicyScriptsScriptItems0PriorityBefore captures enum value "Before"
	PolicyScriptsScriptItems0PriorityBefore string = "Before"

	// PolicyScriptsScriptItems0PriorityAfter captures enum value "After"
	PolicyScriptsScriptItems0PriorityAfter string = "After"
)

// prop value enum
func (m *PolicyScriptsScriptItems0) validatePriorityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, policyScriptsScriptItems0TypePriorityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PolicyScriptsScriptItems0) validatePriority(formats strfmt.Registry) error {
	if swag.IsZero(m.Priority) { // not required
		return nil
	}

	// value enum
	if err := m.validatePriorityEnum("priority", "body", m.Priority); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this policy scripts script items0 based on context it is used
func (m *PolicyScriptsScriptItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyScriptsScriptItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyScriptsScriptItems0) UnmarshalBinary(b []byte) error {
	var res PolicyScriptsScriptItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicySelfService policy self service
//
// swagger:model PolicySelfService
type PolicySelfService struct {

	// feature on main page
	FeatureOnMainPage *bool `json:"feature_on_main_page,omitempty"`

	// force users to view description
	ForceUsersToViewDescription *bool `json:"force_users_to_view_description,omitempty"`

	// install button text
	// Example: Encrypt
	InstallButtonText string `json:"install_button_text,omitempty"`

	// re install button text
	// Example: Re-encrypt
	ReInstallButtonText string `json:"re-install_button_text,omitempty"`

	// self service categories
	SelfServiceCategories *PolicySelfServiceSelfServiceCategories `json:"self_service_categories,omitempty"`

	// self service description
	// Example: Encrypt the boot drive of this device
	SelfServiceDescription string `json:"self_service_description,omitempty"`

	// self service display name
	// Example: Disk Encryption
	SelfServiceDisplayName string `json:"self_service_display_name,omitempty"`

	// self service icon
	SelfServiceIcon *PolicySelfServiceSelfServiceIcon `json:"self_service_icon,omitempty"`

	// use for self service
	UseForSelfService *bool `json:"use_for_self_service,omitempty"`
}

// Validate validates this policy self service
func (m *PolicySelfService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSelfServiceCategories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfServiceIcon(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicySelfService) validateSelfServiceCategories(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceCategories) { // not required
		return nil
	}

	if m.SelfServiceCategories != nil {
		if err := m.SelfServiceCategories.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories")
			}
			return err
		}
	}

	return nil
}

func (m *PolicySelfService) validateSelfServiceIcon(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfServiceIcon) { // not required
		return nil
	}

	if m.SelfServiceIcon != nil {
		if err := m.SelfServiceIcon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy self service based on the context it is used
func (m *PolicySelfService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSelfServiceCategories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfServiceIcon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicySelfService) contextValidateSelfServiceCategories(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceCategories != nil {

		if swag.IsZero(m.SelfServiceCategories) { // not required
			return nil
		}

		if err := m.SelfServiceCategories.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories")
			}
			return err
		}
	}

	return nil
}

func (m *PolicySelfService) contextValidateSelfServiceIcon(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfServiceIcon != nil {

		if swag.IsZero(m.SelfServiceIcon) { // not required
			return nil
		}

		if err := m.SelfServiceIcon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_icon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_icon")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicySelfService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicySelfService) UnmarshalBinary(b []byte) error {
	var res PolicySelfService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicySelfServiceSelfServiceCategories policy self service self service categories
//
// swagger:model PolicySelfServiceSelfServiceCategories
type PolicySelfServiceSelfServiceCategories struct {

	// category
	Category *PolicySelfServiceSelfServiceCategoriesCategory `json:"category,omitempty"`
}

// Validate validates this policy self service self service categories
func (m *PolicySelfServiceSelfServiceCategories) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicySelfServiceSelfServiceCategories) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	if m.Category != nil {
		if err := m.Category.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy self service self service categories based on the context it is used
func (m *PolicySelfServiceSelfServiceCategories) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCategory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicySelfServiceSelfServiceCategories) contextValidateCategory(ctx context.Context, formats strfmt.Registry) error {

	if m.Category != nil {

		if swag.IsZero(m.Category) { // not required
			return nil
		}

		if err := m.Category.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("self_service" + "." + "self_service_categories" + "." + "category")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceCategories) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceCategories) UnmarshalBinary(b []byte) error {
	var res PolicySelfServiceSelfServiceCategories
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicySelfServiceSelfServiceCategoriesCategory policy self service self service categories category
//
// swagger:model PolicySelfServiceSelfServiceCategoriesCategory
type PolicySelfServiceSelfServiceCategoriesCategory struct {

	// display in
	DisplayIn *bool `json:"display_in,omitempty"`

	// feature in
	FeatureIn *bool `json:"feature_in,omitempty"`

	// id
	// Example: 2
	ID int64 `json:"id,omitempty"`

	// name
	// Example: Compliance
	Name string `json:"name,omitempty"`
}

// Validate validates this policy self service self service categories category
func (m *PolicySelfServiceSelfServiceCategoriesCategory) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy self service self service categories category based on context it is used
func (m *PolicySelfServiceSelfServiceCategoriesCategory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceCategoriesCategory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceCategoriesCategory) UnmarshalBinary(b []byte) error {
	var res PolicySelfServiceSelfServiceCategoriesCategory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicySelfServiceSelfServiceIcon policy self service self service icon
//
// swagger:model PolicySelfServiceSelfServiceIcon
type PolicySelfServiceSelfServiceIcon struct {

	// filename
	// Example: Encryption.png
	Filename string `json:"filename,omitempty"`

	// id
	// Example: 1
	ID int64 `json:"id,omitempty"`

	// uri
	// Example: https://jssURL.jamfcloud.com/iconservlet/?id=1
	URI string `json:"uri,omitempty"`
}

// Validate validates this policy self service self service icon
func (m *PolicySelfServiceSelfServiceIcon) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy self service self service icon based on context it is used
func (m *PolicySelfServiceSelfServiceIcon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceIcon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicySelfServiceSelfServiceIcon) UnmarshalBinary(b []byte) error {
	var res PolicySelfServiceSelfServiceIcon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PolicyUserInteraction policy user interaction
//
// swagger:model PolicyUserInteraction
type PolicyUserInteraction struct {

	// allow deferral minutes
	// Example: 0
	AllowDeferralMinutes int64 `json:"allow_deferral_minutes,omitempty"`

	// allow deferral until utc
	// Example: 2019-01-01T01:00:00.000-0600
	AllowDeferralUntilUtc string `json:"allow_deferral_until_utc,omitempty"`

	// allow user to defer
	AllowUserToDefer bool `json:"allow_user_to_defer,omitempty"`

	// message finish
	// Example: Policy completed
	MessageFinish string `json:"message_finish,omitempty"`

	// message start
	// Example: Policy is begining execution
	MessageStart string `json:"message_start,omitempty"`
}

// Validate validates this policy user interaction
func (m *PolicyUserInteraction) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this policy user interaction based on context it is used
func (m *PolicyUserInteraction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PolicyUserInteraction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyUserInteraction) UnmarshalBinary(b []byte) error {
	var res PolicyUserInteraction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
