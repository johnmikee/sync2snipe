// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ComputerInventoryCollection computer inventory collection
//
// swagger:model computer_inventory_collection
type ComputerInventoryCollection struct {

	// active services
	ActiveServices bool `json:"active_services,omitempty"`

	// applications
	Applications []*ComputerInventoryCollectionApplicationsItems0 `json:"applications"`

	// available software updates
	AvailableSoftwareUpdates bool `json:"available_software_updates,omitempty"`

	// computer location information
	ComputerLocationInformation bool `json:"computer_location_information,omitempty"`

	// fonts
	Fonts []*ComputerInventoryCollectionFontsItems0 `json:"fonts"`

	// hidden accounts
	HiddenAccounts bool `json:"hidden_accounts,omitempty"`

	// home directory sizes
	HomeDirectorySizes bool `json:"home_directory_sizes,omitempty"`

	// inclue applications
	InclueApplications bool `json:"inclue_applications,omitempty"`

	// inclue fonts
	InclueFonts bool `json:"inclue_fonts,omitempty"`

	// inclue plugins
	IncluePlugins bool `json:"inclue_plugins,omitempty"`

	// local user accounts
	LocalUserAccounts bool `json:"local_user_accounts,omitempty"`

	// mobile device app purchasing info
	MobileDeviceAppPurchasingInfo bool `json:"mobile_device_app_purchasing_info,omitempty"`

	// package receipts
	PackageReceipts bool `json:"package_receipts,omitempty"`

	// plugins
	Plugins []*ComputerInventoryCollectionPluginsItems0 `json:"plugins"`

	// printers
	Printers bool `json:"printers,omitempty"`
}

// Validate validates this computer inventory collection
func (m *ComputerInventoryCollection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFonts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlugins(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollection) validateApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.Applications) { // not required
		return nil
	}

	for i := 0; i < len(m.Applications); i++ {
		if swag.IsZero(m.Applications[i]) { // not required
			continue
		}

		if m.Applications[i] != nil {
			if err := m.Applications[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerInventoryCollection) validateFonts(formats strfmt.Registry) error {
	if swag.IsZero(m.Fonts) { // not required
		return nil
	}

	for i := 0; i < len(m.Fonts); i++ {
		if swag.IsZero(m.Fonts[i]) { // not required
			continue
		}

		if m.Fonts[i] != nil {
			if err := m.Fonts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fonts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fonts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerInventoryCollection) validatePlugins(formats strfmt.Registry) error {
	if swag.IsZero(m.Plugins) { // not required
		return nil
	}

	for i := 0; i < len(m.Plugins); i++ {
		if swag.IsZero(m.Plugins[i]) { // not required
			continue
		}

		if m.Plugins[i] != nil {
			if err := m.Plugins[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugins" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this computer inventory collection based on the context it is used
func (m *ComputerInventoryCollection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFonts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlugins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollection) contextValidateApplications(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Applications); i++ {

		if m.Applications[i] != nil {

			if swag.IsZero(m.Applications[i]) { // not required
				return nil
			}

			if err := m.Applications[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerInventoryCollection) contextValidateFonts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Fonts); i++ {

		if m.Fonts[i] != nil {

			if swag.IsZero(m.Fonts[i]) { // not required
				return nil
			}

			if err := m.Fonts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fonts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fonts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ComputerInventoryCollection) contextValidatePlugins(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Plugins); i++ {

		if m.Plugins[i] != nil {

			if swag.IsZero(m.Plugins[i]) { // not required
				return nil
			}

			if err := m.Plugins[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugins" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollection) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionApplicationsItems0 computer inventory collection applications items0
//
// swagger:model ComputerInventoryCollectionApplicationsItems0
type ComputerInventoryCollectionApplicationsItems0 struct {

	// application
	Application *ComputerInventoryCollectionApplicationsItems0Application `json:"application,omitempty"`
}

// Validate validates this computer inventory collection applications items0
func (m *ComputerInventoryCollectionApplicationsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplication(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionApplicationsItems0) validateApplication(formats strfmt.Registry) error {
	if swag.IsZero(m.Application) { // not required
		return nil
	}

	if m.Application != nil {
		if err := m.Application.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer inventory collection applications items0 based on the context it is used
func (m *ComputerInventoryCollectionApplicationsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionApplicationsItems0) contextValidateApplication(ctx context.Context, formats strfmt.Registry) error {

	if m.Application != nil {

		if swag.IsZero(m.Application) { // not required
			return nil
		}

		if err := m.Application.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionApplicationsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionApplicationsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionApplicationsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionApplicationsItems0Application computer inventory collection applications items0 application
//
// swagger:model ComputerInventoryCollectionApplicationsItems0Application
type ComputerInventoryCollectionApplicationsItems0Application struct {

	// path
	// Example: ~/Applications
	Path string `json:"path,omitempty"`

	// platform
	// Enum: [Mac Windows]
	Platform string `json:"platform,omitempty"`
}

// Validate validates this computer inventory collection applications items0 application
func (m *ComputerInventoryCollectionApplicationsItems0Application) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var computerInventoryCollectionApplicationsItems0ApplicationTypePlatformPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mac","Windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		computerInventoryCollectionApplicationsItems0ApplicationTypePlatformPropEnum = append(computerInventoryCollectionApplicationsItems0ApplicationTypePlatformPropEnum, v)
	}
}

const (

	// ComputerInventoryCollectionApplicationsItems0ApplicationPlatformMac captures enum value "Mac"
	ComputerInventoryCollectionApplicationsItems0ApplicationPlatformMac string = "Mac"

	// ComputerInventoryCollectionApplicationsItems0ApplicationPlatformWindows captures enum value "Windows"
	ComputerInventoryCollectionApplicationsItems0ApplicationPlatformWindows string = "Windows"
)

// prop value enum
func (m *ComputerInventoryCollectionApplicationsItems0Application) validatePlatformEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, computerInventoryCollectionApplicationsItems0ApplicationTypePlatformPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ComputerInventoryCollectionApplicationsItems0Application) validatePlatform(formats strfmt.Registry) error {
	if swag.IsZero(m.Platform) { // not required
		return nil
	}

	// value enum
	if err := m.validatePlatformEnum("application"+"."+"platform", "body", m.Platform); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this computer inventory collection applications items0 application based on context it is used
func (m *ComputerInventoryCollectionApplicationsItems0Application) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionApplicationsItems0Application) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionApplicationsItems0Application) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionApplicationsItems0Application
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionFontsItems0 computer inventory collection fonts items0
//
// swagger:model ComputerInventoryCollectionFontsItems0
type ComputerInventoryCollectionFontsItems0 struct {

	// font
	Font *ComputerInventoryCollectionFontsItems0Font `json:"font,omitempty"`
}

// Validate validates this computer inventory collection fonts items0
func (m *ComputerInventoryCollectionFontsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFont(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionFontsItems0) validateFont(formats strfmt.Registry) error {
	if swag.IsZero(m.Font) { // not required
		return nil
	}

	if m.Font != nil {
		if err := m.Font.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("font")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("font")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer inventory collection fonts items0 based on the context it is used
func (m *ComputerInventoryCollectionFontsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFont(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionFontsItems0) contextValidateFont(ctx context.Context, formats strfmt.Registry) error {

	if m.Font != nil {

		if swag.IsZero(m.Font) { // not required
			return nil
		}

		if err := m.Font.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("font")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("font")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionFontsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionFontsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionFontsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionFontsItems0Font computer inventory collection fonts items0 font
//
// swagger:model ComputerInventoryCollectionFontsItems0Font
type ComputerInventoryCollectionFontsItems0Font struct {

	// path
	// Example: ~/Library/Fonts
	Path string `json:"path,omitempty"`

	// platform
	// Enum: [Mac Windows]
	Platform string `json:"platform,omitempty"`
}

// Validate validates this computer inventory collection fonts items0 font
func (m *ComputerInventoryCollectionFontsItems0Font) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var computerInventoryCollectionFontsItems0FontTypePlatformPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mac","Windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		computerInventoryCollectionFontsItems0FontTypePlatformPropEnum = append(computerInventoryCollectionFontsItems0FontTypePlatformPropEnum, v)
	}
}

const (

	// ComputerInventoryCollectionFontsItems0FontPlatformMac captures enum value "Mac"
	ComputerInventoryCollectionFontsItems0FontPlatformMac string = "Mac"

	// ComputerInventoryCollectionFontsItems0FontPlatformWindows captures enum value "Windows"
	ComputerInventoryCollectionFontsItems0FontPlatformWindows string = "Windows"
)

// prop value enum
func (m *ComputerInventoryCollectionFontsItems0Font) validatePlatformEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, computerInventoryCollectionFontsItems0FontTypePlatformPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ComputerInventoryCollectionFontsItems0Font) validatePlatform(formats strfmt.Registry) error {
	if swag.IsZero(m.Platform) { // not required
		return nil
	}

	// value enum
	if err := m.validatePlatformEnum("font"+"."+"platform", "body", m.Platform); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this computer inventory collection fonts items0 font based on context it is used
func (m *ComputerInventoryCollectionFontsItems0Font) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionFontsItems0Font) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionFontsItems0Font) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionFontsItems0Font
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionPluginsItems0 computer inventory collection plugins items0
//
// swagger:model ComputerInventoryCollectionPluginsItems0
type ComputerInventoryCollectionPluginsItems0 struct {

	// plugin
	Plugin *ComputerInventoryCollectionPluginsItems0Plugin `json:"plugin,omitempty"`
}

// Validate validates this computer inventory collection plugins items0
func (m *ComputerInventoryCollectionPluginsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlugin(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionPluginsItems0) validatePlugin(formats strfmt.Registry) error {
	if swag.IsZero(m.Plugin) { // not required
		return nil
	}

	if m.Plugin != nil {
		if err := m.Plugin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugin")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this computer inventory collection plugins items0 based on the context it is used
func (m *ComputerInventoryCollectionPluginsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePlugin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ComputerInventoryCollectionPluginsItems0) contextValidatePlugin(ctx context.Context, formats strfmt.Registry) error {

	if m.Plugin != nil {

		if swag.IsZero(m.Plugin) { // not required
			return nil
		}

		if err := m.Plugin.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plugin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plugin")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionPluginsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionPluginsItems0) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionPluginsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ComputerInventoryCollectionPluginsItems0Plugin computer inventory collection plugins items0 plugin
//
// swagger:model ComputerInventoryCollectionPluginsItems0Plugin
type ComputerInventoryCollectionPluginsItems0Plugin struct {

	// path
	// Example: ~/Library/Internet Plug-Ins
	Path string `json:"path,omitempty"`

	// platform
	// Enum: [Mac Windows]
	Platform string `json:"platform,omitempty"`
}

// Validate validates this computer inventory collection plugins items0 plugin
func (m *ComputerInventoryCollectionPluginsItems0Plugin) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var computerInventoryCollectionPluginsItems0PluginTypePlatformPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Mac","Windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		computerInventoryCollectionPluginsItems0PluginTypePlatformPropEnum = append(computerInventoryCollectionPluginsItems0PluginTypePlatformPropEnum, v)
	}
}

const (

	// ComputerInventoryCollectionPluginsItems0PluginPlatformMac captures enum value "Mac"
	ComputerInventoryCollectionPluginsItems0PluginPlatformMac string = "Mac"

	// ComputerInventoryCollectionPluginsItems0PluginPlatformWindows captures enum value "Windows"
	ComputerInventoryCollectionPluginsItems0PluginPlatformWindows string = "Windows"
)

// prop value enum
func (m *ComputerInventoryCollectionPluginsItems0Plugin) validatePlatformEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, computerInventoryCollectionPluginsItems0PluginTypePlatformPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ComputerInventoryCollectionPluginsItems0Plugin) validatePlatform(formats strfmt.Registry) error {
	if swag.IsZero(m.Platform) { // not required
		return nil
	}

	// value enum
	if err := m.validatePlatformEnum("plugin"+"."+"platform", "body", m.Platform); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this computer inventory collection plugins items0 plugin based on context it is used
func (m *ComputerInventoryCollectionPluginsItems0Plugin) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ComputerInventoryCollectionPluginsItems0Plugin) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ComputerInventoryCollectionPluginsItems0Plugin) UnmarshalBinary(b []byte) error {
	var res ComputerInventoryCollectionPluginsItems0Plugin
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
